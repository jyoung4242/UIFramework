import type { Entity } from './Entity';
import { Observable } from '../Util/Observable';
import type { Component, ComponentCtor } from '../EntityComponentSystem/Component';
export type ComponentInstance<T> = T extends ComponentCtor<infer R> ? R : never;
/**
 * Turns `Entity<A | B>` into `Entity<A> | Entity<B>`
 */
export type DistributeEntity<T> = T extends infer U extends Component ? Entity<U> : never;
export interface QueryParams<TKnownComponentCtors extends ComponentCtor<Component> = never, TAnyComponentCtors extends ComponentCtor<Component> = never> {
    components?: {
        all?: TKnownComponentCtors[];
        any?: TAnyComponentCtors[];
        not?: ComponentCtor<Component>[];
    };
    tags?: {
        all?: string[];
        any?: string[];
        not?: string[];
    };
}
export type QueryEntity<TAllComponentCtors extends ComponentCtor<Component> = never, TAnyComponentCtors extends ComponentCtor<Component> = never> = [TAnyComponentCtors] extends [never] ? Entity<ComponentInstance<TAllComponentCtors>> : Entity<ComponentInstance<TAllComponentCtors>> | DistributeEntity<ComponentInstance<TAnyComponentCtors>>;
/**
 * Represents query for entities that match a list of types that is cached and observable
 *
 * Queries can be strongly typed by supplying a type union in the optional type parameter
 * ```typescript
 * const queryAB = new ex.Query<ComponentTypeA | ComponentTypeB>(['A', 'B']);
 * ```
 */
export declare class Query<TAllComponentCtors extends ComponentCtor<Component> = never, TAnyComponentCtors extends ComponentCtor<Component> = never> {
    readonly id: string;
    private _entities;
    get entities(): QueryEntity<TAllComponentCtors, TAnyComponentCtors>[];
    entitiesSet: Set<QueryEntity<TAllComponentCtors, TAnyComponentCtors>>;
    /**
     * This fires right after the component or tag is added
     */
    entityAdded$: Observable<QueryEntity<TAllComponentCtors, TAnyComponentCtors>>;
    /**
     * This fires right before the component or tag is actually removed from the entity, it will still be available for cleanup purposes
     */
    entityRemoved$: Observable<QueryEntity<TAllComponentCtors, TAnyComponentCtors>>;
    readonly filter: {
        components: {
            all: Set<TAllComponentCtors>;
            any: Set<TAnyComponentCtors>;
            not: Set<ComponentCtor<Component>>;
        };
        tags: {
            all: Set<string>;
            any: Set<string>;
            not: Set<string>;
        };
    };
    private _dirty;
    constructor(params: TAllComponentCtors[] | QueryParams<TAllComponentCtors, TAnyComponentCtors>);
    static createId(params: Function[] | QueryParams<any, any>): string;
    static hashTags(set: Set<string>): string;
    static hashComponents(set: Set<ComponentCtor<Component>>): string;
    matchesNotFilter(entity: Entity, removedComponent?: ComponentCtor<Component>): boolean;
    matches(entity: Entity, removedComponent?: ComponentCtor<Component>): boolean;
    /**
     * Potentially adds or removes an entity from a query index, returns true if added, false if not added or was removed.
     * @param entity
     * @param [optional] removedComponent that should be treated as removed from the entity
     */
    checkAndModify(entity: Entity, removedComponent?: ComponentCtor<Component>): boolean;
    removeEntity(entity: Entity): void;
    /**
     * Returns a list of entities that match the query
     * @param sort Optional sorting function to sort entities returned from the query
     */
    getEntities(sort?: (a: Entity, b: Entity) => number): QueryEntity<TAllComponentCtors, TAnyComponentCtors>[];
}
