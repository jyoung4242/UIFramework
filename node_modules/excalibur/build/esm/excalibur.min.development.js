/*! excalibur - 0.32.0 - 2025-12-23
https://github.com/excaliburjs/Excalibur
Copyright (c) 2025 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>
Licensed BSD-2-Clause
@preserve */
function hn() {
  if (typeof window == "undefined" && (window = {
    audioContext: function() {
    }
  }), typeof window != "undefined" && !window.requestAnimationFrame && (window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(r) {
    window.setInterval(r, 1e3 / 60);
  }), typeof window != "undefined" && !window.cancelAnimationFrame && (window.cancelAnimationFrame = window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function() {
  }), typeof window != "undefined" && !window.AudioContext) {
    if (window.webkitAudioContext) {
      const t = window.webkitAudioContext.prototype.decodeAudioData;
      window.webkitAudioContext.prototype.decodeAudioData = function(e) {
        return new Promise((i, s) => {
          t.call(this, e, i, s);
        });
      };
    }
    window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext || window.oAudioContext;
  }
  typeof window != "undefined" && !window.devicePixelRatio && (window.devicePixelRatio = window.devicePixelRatio || 1), typeof window != "undefined" && !window.requestIdleCallback && (window.requestIdleCallback = window.requestIdleCallback || function(r) {
    const t = Date.now();
    return setTimeout(function() {
      r({
        didTimeout: !1,
        timeRemaining: function() {
          return Math.max(0, 50 - (Date.now() - t));
        }
      });
    }, 1);
  }, window.cancelIdleCallback = window.cancelIdleCallback || function(r) {
    clearTimeout(r);
  });
}
const ls = class Ut {
  /**
   * Force excalibur to load the Canvas 2D graphics context fallback
   * @warning not all features of excalibur are supported in the Canvas 2D fallback
   */
  static useCanvasGraphicsContext() {
    Ut.enable("use-canvas-context");
  }
  /**
   * Force excalibur to use the less optimized image renderer
   */
  static useLegacyImageRenderer() {
    Ut.enable("use-legacy-image-renderer");
  }
  /**
   * Freeze all flag modifications making them readonly
   */
  static freeze() {
    Ut._FROZEN = !0;
  }
  /**
   * Resets internal flag state, not meant to be called by users. Only used for testing.
   *
   * Calling this in your game is UNSUPPORTED
   * @internal
   */
  static _reset() {
    Ut._FROZEN = !1, Ut._FLAGS = {};
  }
  /**
   * Enable a specific feature flag by name. **Note: can only be set before {@apilink Engine} constructor time**
   * @param flagName
   */
  static enable(t) {
    if (this._FROZEN)
      throw Error("Feature flags can only be enabled before Engine constructor time");
    Ut._FLAGS[t] = !0;
  }
  /**
   * Disable a specific feature flag by name. **Note: can only be set before {@apilink Engine} constructor time**
   * @param flagName
   */
  static disable(t) {
    if (this._FROZEN)
      throw Error("Feature flags can only be disabled before Engine constructor time");
    Ut._FLAGS[t] = !1;
  }
  /**
   * Check if a flag is enabled. If the flag is disabled or does not exist `false` is returned
   * @param flagName
   */
  static isEnabled(t) {
    return !!Ut._FLAGS[t];
  }
  /**
   * Show a list of currently known flags
   */
  static show() {
    return Object.keys(Ut._FLAGS);
  }
};
ls._FROZEN = !1;
ls._FLAGS = {};
let We = ls;
function Pe(r, t) {
  return { type: r, value: t };
}
class yt {
  constructor() {
    this._isCompleted = !1, this.promise = new Promise((t, e) => {
      this._resolver = t, this._rejecter = e;
    });
  }
  get isCompleted() {
    return this._isCompleted;
  }
  resolve(t) {
    this._isCompleted || (this._isCompleted = !0, this._resolver(t));
  }
  reject(t) {
    this._isCompleted || (this._isCompleted = !0, this._rejecter(t));
  }
}
class X {
  constructor() {
    this._paused = !1, this._empty = !0, this._listeners = {}, this._listenersOnce = {}, this._pipes = [];
  }
  /**
   * Removes all listeners and pipes
   */
  clear() {
    this._listeners = {}, this._listenersOnce = {}, this._pipes.length = 0, this._empty = !0;
  }
  on(t, e) {
    var i;
    return this._empty = !1, this._listeners[t] = (i = this._listeners[t]) != null ? i : [], this._listeners[t].push(e), {
      close: () => this.off(t, e)
    };
  }
  once(t, e) {
    var i;
    return this._empty = !1, this._listenersOnce[t] = (i = this._listenersOnce[t]) != null ? i : [], this._listenersOnce[t].push(e), {
      close: () => this.off(t, e)
    };
  }
  off(t, e) {
    var i, s;
    if (e) {
      const n = (i = this._listeners[t]) == null ? void 0 : i.filter((a) => a !== e);
      this._listeners[t] = n;
      const o = (s = this._listenersOnce[t]) == null ? void 0 : s.filter((a) => a !== e);
      this._listenersOnce[t] = o;
    } else
      delete this._listeners[t];
  }
  emit(t, e) {
    if (this._empty || this._paused)
      return;
    const i = this._listeners[t];
    if (i)
      for (let n = 0; n < i.length; n++)
        i[n](e);
    const s = this._listenersOnce[t];
    if (this._listenersOnce[t] = [], s)
      for (let n = 0; n < s.length; n++)
        s[n](e);
    for (let n = 0; n < this._pipes.length; n++)
      this._pipes[n].emit(t, e);
  }
  /**
   * Replay events from this emitter to another
   * @param emitter
   */
  pipe(t) {
    if (this === t)
      throw Error("Cannot pipe to self");
    return this._empty = !1, this._pipes.push(t), {
      close: () => {
        const e = this._pipes.indexOf(t);
        e > -1 && this._pipes.splice(e, 1);
      }
    };
  }
  /**
   * Remove any piped emitters
   * @param emitter
   */
  unpipe(t) {
    const e = this._pipes.indexOf(t);
    e > -1 && this._pipes.splice(e, 1);
  }
  /**
   * Paused event emitters do not emit events
   */
  pause() {
    this._paused = !0;
  }
  /**
   * Unpaused event emitter do emit events
   */
  unpause() {
    this._paused = !1;
  }
}
var $e = /* @__PURE__ */ ((r) => (r.Canvas = "Canvas", r.Document = "Document", r))($e || {}), J = /* @__PURE__ */ ((r) => (r.ShortestPath = "shortest-path", r.LongestPath = "longest-path", r.Clockwise = "clockwise", r.CounterClockwise = "counter-clockwise", r))(J || {});
const zi = 4294967295, eo = Date.now();
let io = 0;
class ge {
  /**
   * If no seed is specified, the Date.now() is used
   */
  constructor(t) {
    this._lowerMask = 2147483647, this._upperMask = 2147483648, this._w = 32, this._n = 624, this._m = 397, this._a = 2567483615, this._u = 11, this._s = 7, this._b = 2636928640, this._t = 15, this._c = 4022730752, this._l = 18, this._f = 1812433253, this._mt = new Array(this._n), this._mt[0] = (t || eo + io++) >>> 0, this._seed = this._mt[0];
    for (let e = 1; e < this._n; e++) {
      const i = this._mt[e - 1] ^ this._mt[e - 1] >>> this._w - 2;
      this._mt[e] = (this._f * ((i & 4294901760) >>> 16) << 16) + this._f * (i & 65535) + e >>> 0;
    }
    this._index = this._n;
  }
  /**
   * Apply the twist
   */
  _twist() {
    const t = [0, this._a];
    let e = 0, i = 0;
    for (; i < this._n - this._m; i++)
      e = this._mt[i] & this._upperMask | this._mt[i + 1] & this._lowerMask, this._mt[i] = this._mt[i + this._m] ^ e >>> 1 ^ t[e & 1] & zi;
    for (; i < this._n - 1; i++)
      e = this._mt[i] & this._upperMask | this._mt[i + 1] & this._lowerMask, this._mt[i] = this._mt[i + (this._m - this._n)] ^ e >>> 1 ^ t[e & 1] & zi;
    e = this._mt[this._n - 1] & this._upperMask | this._mt[0] & this._lowerMask, this._mt[this._n - 1] = this._mt[this._m - 1] ^ e >>> 1 ^ t[e & 1] & zi, this._index = 0;
  }
  /**
   * Return next 32 bit integer number in sequence
   */
  nextInt() {
    this._index >= this._n && this._twist();
    let t = this._mt[this._index++];
    return t ^= t >>> this._u, t ^= t << this._s & this._b, t ^= t << this._t & this._c, t ^= t >>> this._l, t >>> 0;
  }
  /**
   * Return a random floating point number between [0, 1)
   */
  next() {
    return this.nextInt() * (1 / 4294967296);
  }
  /**
   * Return a random floating point in range [min, max) min is included, max is not included
   */
  floating(t, e) {
    return (e - t) * this.next() + t;
  }
  /**
   * Return a random integer in range [min, max] min is included, max is included.
   * Implemented with rejection sampling, see https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.i13tdiu5a
   */
  integer(t, e) {
    return Math.floor((e - t + 1) * this.next() + t);
  }
  /**
   * Returns true or false randomly with 50/50 odds by default.
   * By default the likelihood of returning a true is .5 (50%).
   * @param likelihood takes values between [0, 1]
   */
  bool(t = 0.5) {
    return this.next() <= t;
  }
  /**
   * Returns one element from an array at random
   */
  pickOne(t) {
    return t[this.integer(0, t.length - 1)];
  }
  /**
   * Returns a new array random picking elements from the original
   * @param array Original array to pick from
   * @param numPicks can be any positive number
   * @param allowDuplicates indicates whether the returned set is allowed duplicates (it does not mean there will always be duplicates
   * just that it is possible)
   */
  pickSet(t, e, i = !1) {
    return i ? this._pickSetWithDuplicates(t, e) : this._pickSetWithoutDuplicates(t, e);
  }
  /**
   * Returns a new array randomly picking elements in the original (not reused)
   * @param array Array to pick elements out of
   * @param numPicks must be less than or equal to the number of elements in the array.
   */
  _pickSetWithoutDuplicates(t, e) {
    if (e > t.length || e < 0)
      throw new Error("Invalid number of elements to pick, must pick a value 0 < n <= length");
    if (e === t.length)
      return t;
    const i = new Array(e);
    let s = 0;
    const n = t.slice(0);
    for (; s < e; ) {
      const o = this.integer(0, n.length - 1);
      i[s++] = n[o], n.splice(o, 1);
    }
    return i;
  }
  /**
   * Returns a new array random picking elements from the original allowing duplicates
   * @param array Array to pick elements out of
   * @param numPicks can be any positive number
   */
  _pickSetWithDuplicates(t, e) {
    if (e < 0)
      throw new Error("Invalid number of elements to pick, must pick a value 0 <= n < MAX_INT");
    const i = new Array(e);
    for (let s = 0; s < e; s++)
      i[s] = this.pickOne(t);
    return i;
  }
  /**
   * Returns a new array that has its elements shuffled. Using the Fisher/Yates method
   * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
   */
  shuffle(t) {
    const e = t.slice(0);
    let i;
    for (let s = 0; s < e.length - 2; s++) {
      const n = this.integer(s, e.length - 1);
      i = e[s], e[s] = e[n], e[n] = i;
    }
    return e;
  }
  /**
   * Generate a list of random integer numbers
   * @param length the length of the final array
   * @param min the minimum integer number to generate inclusive
   * @param max the maximum integer number to generate inclusive
   */
  range(t, e, i) {
    const s = new Array(t);
    for (let n = 0; n < t; n++)
      s[n] = this.integer(e, i);
    return s;
  }
  /**
   * Returns the result of a d4 dice roll
   */
  d4() {
    return this.integer(1, 4);
  }
  /**
   * Returns the result of a d6 dice roll
   */
  d6() {
    return this.integer(1, 6);
  }
  /**
   * Returns the result of a d8 dice roll
   */
  d8() {
    return this.integer(1, 8);
  }
  /**
   * Returns the result of a d10 dice roll
   */
  d10() {
    return this.integer(1, 10);
  }
  /**
   * Returns the result of a d12 dice roll
   */
  d12() {
    return this.integer(1, 12);
  }
  /**
   * Returns the result of a d20 dice roll
   */
  d20() {
    return this.integer(1, 20);
  }
  get seed() {
    return this._seed;
  }
}
const vt = Math.PI * 2;
function Zh(r) {
  return r >= 0 ? r - Math.floor(r) : r - Math.ceil(r);
}
function q(r) {
  return r === 0 ? 0 : r < 0 ? -1 : 1;
}
function D(r, t, e) {
  return Math.min(Math.max(t, r), e);
}
function so(r, t, e) {
  return Math.abs(r - t) < e;
}
function Ht(r) {
  const t = 2 * Math.PI;
  return (r % t + t) % t;
}
function no(r, t) {
  const e = 2 * Math.PI, i = Math.abs(r - t);
  return Math.min(i, e - i);
}
function ro(r) {
  return 180 / Math.PI * r;
}
function jh(r) {
  return r / 180 * Math.PI;
}
const Qh = (r, t) => Array.from(new Array(t - r + 1), (e, i) => i + r);
function $t(r, t, e = new ge()) {
  return e ? e.floating(r, t) : r + Math.random() * (t - r);
}
function Jh(r, t, e = new ge()) {
  return e ? e.integer(r, t) : Math.round($t(r, t));
}
const ln = class V {
  /**
   * @param x  X component of the Vector
   * @param y  Y component of the Vector
   */
  constructor(t, e) {
    this._x = 0, this._y = 0, this._x = t, this._y = e;
  }
  /**
   * A (0, 0) vector
   */
  static get Zero() {
    return new V(0, 0);
  }
  /**
   * A (1, 1) vector
   */
  static get One() {
    return new V(1, 1);
  }
  /**
   * A (0.5, 0.5) vector
   */
  static get Half() {
    return new V(0.5, 0.5);
  }
  /**
   * A unit vector pointing up (0, -1)
   */
  static get Up() {
    return new V(0, -1);
  }
  /**
   * A unit vector pointing down (0, 1)
   */
  static get Down() {
    return new V(0, 1);
  }
  /**
   * A unit vector pointing left (-1, 0)
   */
  static get Left() {
    return new V(-1, 0);
  }
  /**
   * A unit vector pointing right (1, 0)
   */
  static get Right() {
    return new V(1, 0);
  }
  /**
   * Returns a vector of unit length in the direction of the specified angle in Radians.
   * @param angle The angle to generate the vector
   */
  static fromAngle(t) {
    return new V(Math.cos(t), Math.sin(t));
  }
  /**
   * Checks if vector is not null, undefined, or if any of its components are NaN or Infinity.
   */
  static isValid(t) {
    return !(t == null || isNaN(t.x) || isNaN(t.y) || t.x === 1 / 0 || t.y === 1 / 0 || t.x === -1 / 0 || t.y === -1 / 0);
  }
  /**
   * Calculates distance between two Vectors
   * @param vec1
   * @param vec2
   */
  static distance(t, e) {
    return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
  }
  static min(t, e) {
    return new V(Math.min(t.x, e.x), Math.min(t.y, e.y));
  }
  static max(t, e) {
    return new V(Math.max(t.x, e.x), Math.max(t.y, e.y));
  }
  /**
   * Get the x component of the vector
   */
  get x() {
    return this._x;
  }
  /**
   * Set the x component, THIS MUTATES the current vector. It is usually better to create a new vector.
   * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**
   */
  set x(t) {
    this._x = t;
  }
  /**
   * Get the y component of the vector
   */
  get y() {
    return this._y;
  }
  /**
   * Set the y component, THIS MUTATES the current vector. It is usually better to create a new vector.
   * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**
   */
  set y(t) {
    this._y = t;
  }
  /**
   * Sets the x and y components at once, THIS MUTATES the current vector. It is usually better to create a new vector.
   * @warning **Be very careful using this, mutating vectors can cause hard to find bugs**
   */
  setTo(t, e) {
    this.x = t, this.y = e;
  }
  /**
   * Compares this point against another and tests for equality
   * @param vector The other point to compare to
   * @param tolerance Amount of euclidean distance off we are willing to tolerate
   */
  equals(t, e = V.EQUALS_EPSILON) {
    return Math.abs(this.x - t.x) <= e && Math.abs(this.y - t.y) <= e;
  }
  /**
   * The distance to another vector. If no other Vector is specified, this will return the {@apilink magnitude}.
   * @param v  The other vector. Leave blank to use origin vector.
   */
  distance(t) {
    if (!t)
      return Math.sqrt(this.x * this.x + this.y * this.y);
    const e = this.x - t.x, i = this.y - t.y;
    return Math.sqrt(e * e + i * i);
  }
  squareDistance(t) {
    t || (t = V.Zero);
    const e = this.x - t.x, i = this.y - t.y;
    return e * e + i * i;
  }
  /**
   * Clamps the current vector's magnitude mutating it
   * @param magnitude
   */
  clampMagnitude(t) {
    const e = this.magnitude, i = D(e, 0, t);
    return this.magnitude = i, this;
  }
  /**
   * The size (magnitude) of the Vector
   * @deprecated Will be removed in v1, use Vector.magnitude
   */
  get size() {
    return this.distance();
  }
  /**
   * Setting the size mutates the current vector
   * @warning Can be used to set the size of the vector, **be very careful using this, mutating vectors can cause hard to find bugs**
   * @deprecated Will be removed in v1, use Vector.magnitude
   */
  set size(t) {
    const e = this.normalize().scale(t);
    this.setTo(e.x, e.y);
  }
  /**
   * The magnitude (length) of the Vector
   */
  get magnitude() {
    return this.distance();
  }
  /**
   * Setting the size mutates the current vector
   * @warning Can be used to set the size of the vector, **be very careful using this, mutating vectors can cause hard to find bugs**
   */
  set magnitude(t) {
    this.normalize().scale(t, this);
  }
  /**
   * Normalizes a non-zero vector to have a magnitude of 1. Zero vectors return a new zero vector.
   */
  normalize() {
    const t = this.distance();
    return t === 0 ? V.Zero : new V(this.x / t, this.y / t);
  }
  /**
   * Returns the average (midpoint) between the current point and the specified
   */
  average(t) {
    return this.add(t).scale(0.5);
  }
  scale(t, e) {
    const i = e || new V(0, 0);
    return t instanceof V ? (i.x = this.x * t.x, i.y = this.y * t.y) : (i.x = this.x * t, i.y = this.y * t), i;
  }
  /**
   * Adds one vector to another
   * @param v The vector to add
   * @param dest Optionally copy the result into a provided vector
   */
  add(t, e) {
    return e ? (e.x = this.x + t.x, e.y = this.y + t.y, e) : new V(this.x + t.x, this.y + t.y);
  }
  /**
   * Subtracts a vector from another, if you subtract vector `B.sub(A)` the resulting vector points from A -> B
   * @param v The vector to subtract
   */
  sub(t, e) {
    const i = e || new V(0, 0), s = this.x - t.x, n = this.y - t.y;
    return i.x = s, i.y = n, i;
  }
  /**
   * Adds one vector to this one modifying the original
   * @param v The vector to add
   * @warning Be very careful using this, mutating vectors can cause hard to find bugs
   */
  addEqual(t) {
    return this.setTo(this.x + t.x, this.y + t.y), this;
  }
  /**
   * Subtracts a vector from this one modifying the original
   * @param v The vector to subtract
   * @warning Be very careful using this, mutating vectors can cause hard to find bugs
   */
  subEqual(t) {
    return this.setTo(this.x - t.x, this.y - t.y), this;
  }
  /**
   * Scales this vector by a factor of size and modifies the original
   * @warning Be very careful using this, mutating vectors can cause hard to find bugs
   */
  scaleEqual(t) {
    return this.setTo(this.x * t, this.y * t), this;
  }
  /**
   * Performs a dot product with another vector
   * @param v  The vector to dot
   */
  dot(t) {
    return this.x * t.x + this.y * t.y;
  }
  cross(t) {
    if (t instanceof V)
      return this.x * t.y - this.y * t.x;
    if (typeof t == "number")
      return new V(t * this.y, -t * this.x);
  }
  static cross(t, e) {
    return new V(-t * e.y, t * e.x);
  }
  /**
   * Returns the perpendicular vector to this one
   */
  perpendicular() {
    return new V(this.y, -this.x);
  }
  /**
   * Returns the normal vector to this one, same as the perpendicular of length 1
   */
  normal() {
    return this.perpendicular().normalize();
  }
  /**
   * Negate the current vector
   */
  negate() {
    return this.scale(-1);
  }
  /**
   * Returns the angle of this vector, in range [0, 2*PI)
   */
  toAngle() {
    return Ht(Math.atan2(this.y, this.x));
  }
  /**
   * Returns the difference in radians between the angle of this vector and given angle,
   * using the given rotation type.
   * @param angle in radians to which the vector has to be rotated, using {@apilink rotate}
   * @param rotationType what {@apilink RotationType} to use for the rotation
   * @returns the angle by which the vector needs to be rotated to match the given angle
   */
  angleBetween(t, e) {
    const i = this.toAngle(), s = Ht(t);
    let n = 0, o = 0;
    switch (s > i ? n = s - i : n = (vt - i + s) % vt, o = (n - vt) % vt, e) {
      case J.ShortestPath:
        return Math.abs(n) < Math.abs(o) ? n : o;
      case J.LongestPath:
        return Math.abs(n) > Math.abs(o) ? n : o;
      case J.Clockwise:
        return n;
      case J.CounterClockwise:
        return o;
    }
  }
  /**
   * Rotates the current vector around a point by a certain angle in radians.
   * Positive angle means rotation clockwise.
   */
  rotate(t, e, i) {
    const s = i || new V(0, 0);
    e || (e = new V(0, 0));
    const n = Math.sin(t), o = Math.cos(t), a = o * (this.x - e.x) - n * (this.y - e.y) + e.x, h = n * (this.x - e.x) + o * (this.y - e.y) + e.y;
    return s.x = a, s.y = h, s;
  }
  /**
   * Creates new vector that has the same values as the previous.
   */
  clone(t) {
    const e = t != null ? t : new V(0, 0);
    return e.x = this.x, e.y = this.y, e;
  }
  /**
   * Returns a string representation of the vector.
   */
  toString(t) {
    return t ? `(${this.x.toFixed(t)}, ${this.y.toFixed(t)})` : `(${this.x}, ${this.y})`;
  }
  /**
   * Linearly interpolates between the current vector and the target vector.
   * At `t = 0`, the result is the current vector, and at `t = 1`, the result is the target vector.
   * Values of `t` outside the range [0, 1] will be clamped to that range.
   *
   * @param target The target vector to interpolate towards.
   * @param t The interpolation factor, clamped between 0 and 1.
   * @returns A new vector that is the result of the linear interpolation.
   */
  lerp(t, e) {
    e = D(e, 0, 1);
    const i = new V(0, 0);
    return i.x = this.x + (t.x - this.x) * e, i.y = this.y + (t.y - this.y) * e, i;
  }
};
ln.EQUALS_EPSILON = 1e-3;
let v = ln;
function w(r, t) {
  return new v(r, t);
}
class Us extends v {
  constructor(t) {
    super(0, 0), this._getX = t.getX, this._getY = t.getY, this._setX = t.setX, this._setY = t.setY;
  }
  get x() {
    return this._x = this._getX();
  }
  set x(t) {
    this._setX(t), this._x = t;
  }
  get y() {
    return this._y = this._getY();
  }
  set y(t) {
    this._setY(t), this._y = t;
  }
}
var oo = /* @__PURE__ */ ((r) => (r[r.X = 12] = "X", r[r.Y = 13] = "Y", r))(oo || {});
class Tt {
  constructor() {
    this.data = new Float32Array(16), this._scaleX = 1, this._scaleSignX = 1, this._scaleY = 1, this._scaleSignY = 1;
  }
  /**
   * Creates an orthographic (flat non-perspective) projection
   * https://en.wikipedia.org/wiki/Orthographic_projection
   * @param left
   * @param right
   * @param bottom
   * @param top
   * @param near
   * @param far
   */
  static ortho(t, e, i, s, n, o) {
    const a = new Tt();
    return a.data[0] = 2 / (e - t), a.data[1] = 0, a.data[2] = 0, a.data[3] = 0, a.data[4] = 0, a.data[5] = 2 / (s - i), a.data[6] = 0, a.data[7] = 0, a.data[8] = 0, a.data[9] = 0, a.data[10] = -2 / (o - n), a.data[11] = 0, a.data[12] = -(e + t) / (e - t), a.data[13] = -(s + i) / (s - i), a.data[14] = -(o + n) / (o - n), a.data[15] = 1, a;
  }
  /**
   * Creates a new Matrix with the same data as the current 4x4
   */
  clone(t) {
    const e = t || new Tt();
    return e.data[0] = this.data[0], e.data[1] = this.data[1], e.data[2] = this.data[2], e.data[3] = this.data[3], e.data[4] = this.data[4], e.data[5] = this.data[5], e.data[6] = this.data[6], e.data[7] = this.data[7], e.data[8] = this.data[8], e.data[9] = this.data[9], e.data[10] = this.data[10], e.data[11] = this.data[11], e.data[12] = this.data[12], e.data[13] = this.data[13], e.data[14] = this.data[14], e.data[15] = this.data[15], e;
  }
  /**
   * Converts the current matrix into a DOMMatrix
   *
   * This is useful when working with the browser Canvas context
   * @returns {DOMMatrix} DOMMatrix
   */
  toDOMMatrix() {
    return new DOMMatrix([...this.data]);
  }
  static fromFloat32Array(t) {
    const e = new Tt();
    return e.data = t, e;
  }
  /**
   * Creates a new identity matrix (a matrix that when applied does nothing)
   */
  static identity() {
    const t = new Tt();
    return t.data[0] = 1, t.data[1] = 0, t.data[2] = 0, t.data[3] = 0, t.data[4] = 0, t.data[5] = 1, t.data[6] = 0, t.data[7] = 0, t.data[8] = 0, t.data[9] = 0, t.data[10] = 1, t.data[11] = 0, t.data[12] = 0, t.data[13] = 0, t.data[14] = 0, t.data[15] = 1, t;
  }
  /**
   * Resets the current matrix to the identity matrix, mutating it
   * @returns {Matrix} Current matrix as identity
   */
  reset() {
    const t = this;
    return t.data[0] = 1, t.data[1] = 0, t.data[2] = 0, t.data[3] = 0, t.data[4] = 0, t.data[5] = 1, t.data[6] = 0, t.data[7] = 0, t.data[8] = 0, t.data[9] = 0, t.data[10] = 1, t.data[11] = 0, t.data[12] = 0, t.data[13] = 0, t.data[14] = 0, t.data[15] = 1, t;
  }
  /**
   * Creates a brand new translation matrix at the specified 3d point
   * @param x
   * @param y
   */
  static translation(t, e) {
    const i = Tt.identity();
    return i.data[12] = t, i.data[13] = e, i;
  }
  /**
   * Creates a brand new scaling matrix with the specified scaling factor
   * @param sx
   * @param sy
   */
  static scale(t, e) {
    const i = Tt.identity();
    return i.data[0] = t, i.data[5] = e, i.data[10] = 1, i.data[15] = 1, i;
  }
  /**
   * Creates a brand new rotation matrix with the specified angle in radians
   * @param angle
   */
  static rotation(t) {
    const e = Tt.identity();
    return e.data[0] = Math.cos(t), e.data[4] = -Math.sin(t), e.data[1] = Math.sin(t), e.data[5] = Math.cos(t), e;
  }
  multiply(t, e) {
    if (t instanceof v) {
      const i = e || new v(0, 0), s = t, n = s.x * this.data[0] + s.y * this.data[4] + this.data[12], o = s.x * this.data[1] + s.y * this.data[5] + this.data[13];
      return i.x = n, i.y = o, i;
    } else {
      const i = e || new Tt(), s = t, n = this.data[0], o = this.data[1], a = this.data[2], h = this.data[3], l = this.data[4], c = this.data[5], d = this.data[6], u = this.data[7], _ = this.data[8], p = this.data[9], g = this.data[10], x = this.data[11], m = this.data[12], f = this.data[13], b = this.data[14], C = this.data[15], S = s.data[0], I = s.data[1], y = s.data[2], k = s.data[3], L = s.data[4], O = s.data[5], Q = s.data[6], st = s.data[7], $ = s.data[8], H = s.data[9], rt = s.data[10], lt = s.data[11], A = s.data[12], oe = s.data[13], ae = s.data[14], he = s.data[15];
      i.data[0] = n * S + l * I + _ * y + m * k, i.data[1] = o * S + c * I + p * y + f * k, i.data[2] = a * S + d * I + g * y + b * k, i.data[3] = h * S + u * I + x * y + C * k, i.data[4] = n * L + l * O + _ * Q + m * st, i.data[5] = o * L + c * O + p * Q + f * st, i.data[6] = a * L + d * O + g * Q + b * st, i.data[7] = h * L + u * O + x * Q + C * st, i.data[8] = n * $ + l * H + _ * rt + m * lt, i.data[9] = o * $ + c * H + p * rt + f * lt, i.data[10] = a * $ + d * H + g * rt + b * lt, i.data[11] = h * $ + u * H + x * rt + C * lt, i.data[12] = n * A + l * oe + _ * ae + m * he, i.data[13] = o * A + c * oe + p * ae + f * he, i.data[14] = a * A + d * oe + g * ae + b * he, i.data[15] = h * A + u * oe + x * ae + C * he;
      const Ue = this.getScale();
      return i._scaleSignX = q(Ue.x) * q(i._scaleSignX), i._scaleSignY = q(Ue.y) * q(i._scaleSignY), i;
    }
  }
  /**
   * Applies translation to the current matrix mutating it
   * @param x
   * @param y
   */
  translate(t, e) {
    const i = this.data[0], s = this.data[1], n = this.data[2], o = this.data[3], a = this.data[4], h = this.data[5], l = this.data[6], c = this.data[7], d = this.data[8], u = this.data[9], _ = this.data[10], p = this.data[11], g = this.data[12], x = this.data[13], m = this.data[14], f = this.data[15], b = 0, C = 1;
    return this.data[12] = i * t + a * e + d * b + g * C, this.data[13] = s * t + h * e + u * b + x * C, this.data[14] = n * t + l * e + _ * b + m * C, this.data[15] = o * t + c * e + p * b + f * C, this;
  }
  setPosition(t, e) {
    this.data[12] = t, this.data[13] = e;
  }
  getPosition() {
    return w(this.data[12], this.data[13]);
  }
  /**
   * Applies rotation to the current matrix mutating it
   * @param angle in Radians
   */
  rotate(t) {
    const e = this.data[0], i = this.data[1], s = this.data[2], n = this.data[3], o = this.data[4], a = this.data[5], h = this.data[6], l = this.data[7], c = Math.sin(t), d = Math.cos(t);
    return this.data[0] = d * e + c * o, this.data[1] = d * i + c * a, this.data[2] = d * s + c * h, this.data[3] = d * n + c * l, this.data[4] = d * o - c * e, this.data[5] = d * a - c * i, this.data[6] = d * h - c * s, this.data[7] = d * l - c * n, this;
  }
  /**
   * Applies scaling to the current matrix mutating it
   * @param x
   * @param y
   */
  scale(t, e) {
    const i = this.data[0], s = this.data[1], n = this.data[2], o = this.data[3], a = this.data[4], h = this.data[5], l = this.data[6], c = this.data[7];
    return this.data[0] = i * t, this.data[1] = s * t, this.data[2] = n * t, this.data[3] = o * t, this.data[4] = a * e, this.data[5] = h * e, this.data[6] = l * e, this.data[7] = c * e, this;
  }
  setRotation(t) {
    const e = this.getScale(), i = Math.sin(t), s = Math.cos(t);
    this.data[0] = s * e.x, this.data[1] = i * e.y, this.data[4] = -i * e.x, this.data[5] = s * e.y;
  }
  getRotation() {
    const t = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());
    return Ht(t);
  }
  getScaleX() {
    const t = w(this.data[0], this.data[4]).magnitude;
    return this._scaleSignX * t;
  }
  getScaleY() {
    const t = w(this.data[1], this.data[5]).magnitude;
    return this._scaleSignY * t;
  }
  /**
   * Get the scale of the matrix
   */
  getScale() {
    return w(this.getScaleX(), this.getScaleY());
  }
  setScaleX(t) {
    if (this._scaleX === t)
      return;
    this._scaleSignX = q(t);
    const e = w(this.data[0] * this._scaleSignX, this.data[4] * this._scaleSignX).normalize();
    this.data[0] = e.x * t, this.data[4] = e.y * t, this._scaleX = t;
  }
  setScaleY(t) {
    if (this._scaleY === t)
      return;
    this._scaleSignY = q(t);
    const e = w(this.data[1] * this._scaleSignY, this.data[5] * this._scaleSignY).normalize();
    this.data[1] = e.x * t, this.data[5] = e.y * t, this._scaleY = t;
  }
  setScale(t) {
    this.setScaleX(t.x), this.setScaleY(t.y);
  }
  /**
   * Determinant of the upper left 2x2 matrix
   */
  getBasisDeterminant() {
    return this.data[0] * this.data[5] - this.data[1] * this.data[4];
  }
  /**
   * Return the affine inverse, optionally store it in a target matrix.
   *
   * It's recommended you call .reset() the target unless you know what you're doing
   * @param target
   */
  getAffineInverse(t) {
    const i = 1 / this.getBasisDeterminant(), s = this.data[0], n = this.data[4], o = this.data[1], a = this.data[5], h = t || Tt.identity();
    h.data[0] = a * i, h.data[1] = -o * i, h.data[4] = -n * i, h.data[5] = s * i;
    const l = this.data[12], c = this.data[13];
    return h.data[12] = -(l * h.data[0] + c * h.data[4]), h.data[13] = -(l * h.data[1] + c * h.data[5]), h;
  }
  isIdentity() {
    return this.data[0] === 1 && this.data[1] === 0 && this.data[2] === 0 && this.data[3] === 0 && this.data[4] === 0 && this.data[5] === 1 && this.data[6] === 0 && this.data[7] === 0 && this.data[8] === 0 && this.data[9] === 0 && this.data[10] === 1 && this.data[11] === 0 && this.data[12] === 0 && this.data[13] === 0 && this.data[14] === 0 && this.data[15] === 1;
  }
  toString() {
    return `
[${this.data[0]} ${this.data[4]} ${this.data[8]} ${this.data[12]}]
[${this.data[1]} ${this.data[5]} ${this.data[9]} ${this.data[13]}]
[${this.data[2]} ${this.data[6]} ${this.data[10]} ${this.data[14]}]
[${this.data[3]} ${this.data[7]} ${this.data[11]} ${this.data[15]}]
`;
  }
}
class j {
  constructor() {
    this.data = new Float64Array(6), this._scale = new Float64Array([1, 1]), this._scaleSignX = 1, this._scaleSignY = 1;
  }
  /**
   * Converts the current matrix into a DOMMatrix
   *
   * This is useful when working with the browser Canvas context
   * @returns {DOMMatrix} DOMMatrix
   */
  toDOMMatrix() {
    return new DOMMatrix([...this.data]);
  }
  static identity() {
    const t = new j();
    return t.data[0] = 1, t.data[1] = 0, t.data[2] = 0, t.data[3] = 1, t.data[4] = 0, t.data[5] = 0, t;
  }
  /**
   * Creates a brand new translation matrix at the specified 3d point
   * @param x
   * @param y
   */
  static translation(t, e) {
    const i = j.identity();
    return i.data[4] = t, i.data[5] = e, i;
  }
  /**
   * Creates a brand new scaling matrix with the specified scaling factor
   * @param sx
   * @param sy
   */
  static scale(t, e) {
    const i = j.identity();
    return i.data[0] = t, i.data[3] = e, i._scale[0] = t, i._scale[1] = e, i;
  }
  /**
   * Creates a brand new rotation matrix with the specified angle in radians
   * @param angle
   */
  static rotation(t) {
    const e = j.identity();
    return e.data[0] = Math.cos(t), e.data[1] = Math.sin(t), e.data[2] = -Math.sin(t), e.data[3] = Math.cos(t), e;
  }
  setPosition(t, e) {
    this.data[4] = t, this.data[5] = e;
  }
  getPosition() {
    return w(this.data[4], this.data[5]);
  }
  /**
   * Applies rotation to the current matrix mutating it
   * @param angle in Radians
   */
  rotate(t) {
    const e = this.data[0], i = this.data[1], s = this.data[2], n = this.data[3], o = Math.sin(t), a = Math.cos(t);
    return this.data[0] = a * e + o * s, this.data[1] = a * i + o * n, this.data[2] = a * s - o * e, this.data[3] = a * n - o * i, this;
  }
  /**
   * Applies translation to the current matrix mutating it
   * @param x
   * @param y
   */
  translate(t, e) {
    const i = this.data[0], s = this.data[1], n = this.data[2], o = this.data[3], a = this.data[4], h = this.data[5];
    return this.data[4] = i * t + n * e + a, this.data[5] = s * t + o * e + h, this;
  }
  /**
   * Applies scaling to the current matrix mutating it
   * @param x
   * @param y
   */
  scale(t, e) {
    const i = this.data[0], s = this.data[1], n = this.data[2], o = this.data[3];
    return this.data[0] = i * t, this.data[1] = s * t, this.data[2] = n * e, this.data[3] = o * e, this._scale[0] = t, this._scale[1] = e, this._scaleSignX = q(t), this._scaleSignY = q(e), this;
  }
  determinant() {
    return this.data[0] * this.data[3] - this.data[1] * this.data[2];
  }
  /**
   * Return the affine inverse, optionally store it in a target matrix.
   *
   * It's recommended you call .reset() the target unless you know what you're doing
   * @param target
   */
  inverse(t) {
    const e = this.determinant();
    let i = e;
    e !== 0 && (i = 1 / e);
    const s = this.data[0], n = this.data[2], o = this.data[1], a = this.data[3], h = t || j.identity();
    h.data[0] = a * i, h.data[1] = -o * i, h.data[2] = -n * i, h.data[3] = s * i;
    const l = this.data[4], c = this.data[5];
    return h.data[4] = -(l * h.data[0] + c * h.data[2]), h.data[5] = -(l * h.data[1] + c * h.data[3]), h;
  }
  multiply(t, e) {
    if (t instanceof v) {
      const i = e || new v(0, 0), s = t, n = s.x * this.data[0] + s.y * this.data[2] + this.data[4], o = s.x * this.data[1] + s.y * this.data[3] + this.data[5];
      return i.x = n, i.y = o, i;
    } else {
      const i = e || new j(), s = t, n = this.data[0], o = this.data[1], a = this.data[2], h = this.data[3], l = this.data[4], c = this.data[5], d = s.data[0], u = s.data[1], _ = s.data[2], p = s.data[3], g = s.data[4], x = s.data[5];
      i.data[0] = n * d + a * u, i.data[1] = o * d + h * u, i.data[2] = n * _ + a * p, i.data[3] = o * _ + h * p, i.data[4] = n * g + a * x + l, i.data[5] = o * g + h * x + c;
      const m = this._scaleSignX, f = this._scaleSignY;
      return i._scaleSignX = m * q(i._scaleSignX), i._scaleSignY = f * q(i._scaleSignY), i;
    }
  }
  /**
   * Packed array of length 8, that contains 4 vertices, with 2 components each
   * So: [x0, y0, x1, y1, x2, y2, x3, y3]
   * @param quad
   */
  multiplyQuadInPlace(t) {
    const e = t[0] * this.data[0] + t[1] * this.data[2] + this.data[4], i = t[0] * this.data[1] + t[1] * this.data[3] + this.data[5];
    t[0] = e, t[1] = i;
    const s = t[2] * this.data[0] + t[3] * this.data[2] + this.data[4], n = t[2] * this.data[1] + t[3] * this.data[3] + this.data[5];
    t[2] = s, t[3] = n;
    const o = t[4] * this.data[0] + t[5] * this.data[2] + this.data[4], a = t[4] * this.data[1] + t[5] * this.data[3] + this.data[5];
    t[4] = o, t[5] = a;
    const h = t[6] * this.data[0] + t[7] * this.data[2] + this.data[4], l = t[6] * this.data[1] + t[7] * this.data[3] + this.data[5];
    t[6] = h, t[7] = l;
  }
  to4x4() {
    const t = new Tt();
    return t.data[0] = this.data[0], t.data[1] = this.data[1], t.data[2] = 0, t.data[3] = 0, t.data[4] = this.data[2], t.data[5] = this.data[3], t.data[6] = 0, t.data[7] = 0, t.data[8] = 0, t.data[9] = 0, t.data[10] = 1, t.data[11] = 0, t.data[12] = this.data[4], t.data[13] = this.data[5], t.data[14] = 0, t.data[15] = 1, t;
  }
  setRotation(t) {
    const e = this.getScale(), i = Math.sin(t), s = Math.cos(t);
    this.data[0] = s * e.x, this.data[1] = i * e.y, this.data[2] = -i * e.x, this.data[3] = s * e.y;
  }
  getRotation() {
    const t = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());
    return Ht(t);
  }
  getScaleX() {
    const t = this.data[0] * this.data[0] + this.data[2] * this.data[2];
    return t === 1 ? this._scaleSignX : this._scaleSignX * Math.sqrt(t);
  }
  getScaleY() {
    const t = this.data[1] * this.data[1] + this.data[3] * this.data[3];
    return t === 1 ? this._scaleSignY : this._scaleSignY * Math.sqrt(t);
  }
  /**
   * Get the scale of the matrix
   */
  getScale() {
    return w(this.getScaleX(), this.getScaleY());
  }
  setScaleX(t) {
    if (t === this._scale[0])
      return;
    this._scaleSignX = q(t);
    const e = w(this.data[0] * this._scaleSignX, this.data[2] * this._scaleSignX).normalize();
    this.data[0] = e.x * t, this.data[2] = e.y * t, this._scale[0] = t;
  }
  setScaleY(t) {
    if (t === this._scale[1])
      return;
    this._scaleSignY = q(t);
    const e = w(this.data[1] * this._scaleSignY, this.data[3] * this._scaleSignY).normalize();
    this.data[1] = e.x * t, this.data[3] = e.y * t, this._scale[1] = t;
  }
  setScale(t) {
    this.setScaleX(t.x), this.setScaleY(t.y);
  }
  isIdentity() {
    return this.data[0] === 1 && this.data[1] === 0 && this.data[2] === 0 && this.data[3] === 1 && this.data[4] === 0 && this.data[5] === 0;
  }
  /**
   * Resets the current matrix to the identity matrix, mutating it
   * @returns {AffineMatrix} Current matrix as identity
   */
  reset() {
    const t = this;
    return t.data[0] = 1, t.data[1] = 0, t.data[2] = 0, t.data[3] = 1, t.data[4] = 0, t.data[5] = 0, t;
  }
  /**
   * Creates a new Matrix with the same data as the current {@apilink AffineMatrix}
   */
  clone(t) {
    const e = t || new j();
    return e.data[0] = this.data[0], e.data[1] = this.data[1], e.data[2] = this.data[2], e.data[3] = this.data[3], e.data[4] = this.data[4], e.data[5] = this.data[5], e._scaleSignX = this._scaleSignX, e._scaleSignY = this._scaleSignY, e;
  }
  toString() {
    return `
[${this.data[0]} ${this.data[2]} ${this.data[4]}]
[${this.data[1]} ${this.data[3]} ${this.data[5]}]
[0 0 1]
`;
  }
}
class se extends v {
  constructor(t, e) {
    super(t.x, t.y), this.original = t, this.change = e;
  }
  get x() {
    return this._x = this.original.x;
  }
  set x(t) {
    t !== this._x && (this.change(t, this._y), this._x = this.original.x = t);
  }
  get y() {
    return this._y = this.original.y;
  }
  set y(t) {
    t !== this._y && (this.change(this._x, t), this._y = this.original.y = t);
  }
  setTo(t, e) {
    this.x = t, this.y = e;
  }
}
class re {
  constructor() {
    this._parent = null, this._children = [], this._pos = new se(w(0, 0), () => {
      this.flagDirty();
    }), this._globalPos = new Us({
      getX: () => this.matrix.data[4],
      getY: () => this.matrix.data[5],
      setX: (t) => {
        if (this.parent) {
          const { x: e } = this.parent.inverse.multiply(w(t, this.pos.y));
          this.pos.x = e;
        } else
          this.pos.x = t;
        t !== this.matrix.data[4] && this.flagDirty();
      },
      setY: (t) => {
        if (this.parent) {
          const { y: e } = this.parent.inverse.multiply(w(this.pos.x, t));
          this.pos.y = e;
        } else
          this.pos.y = t;
        t !== this.matrix.data[5] && this.flagDirty();
      }
    }), this._rotation = 0, this._scale = new se(w(1, 1), () => {
      this.flagDirty();
    }), this._globalScale = new Us({
      getX: () => this.parent ? this.matrix.getScaleX() : this.scale.x,
      getY: () => this.parent ? this.matrix.getScaleY() : this.scale.y,
      setX: (t) => {
        if (this.parent) {
          const e = this.parent.globalScale.x;
          this.scale.x = t / e;
        } else
          this.scale.x = t;
      },
      setY: (t) => {
        if (this.parent) {
          const e = this.parent.globalScale.y;
          this.scale.y = t / e;
        } else
          this.scale.y = t;
      }
    }), this._z = 0, this._isDirty = !1, this._isInverseDirty = !1, this._matrix = j.identity(), this._inverse = j.identity(), this._scratch = j.identity();
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    if (this._parent) {
      const e = this._parent._children.indexOf(this);
      e > -1 && this._parent._children.splice(e, 1);
    }
    this._parent = t, this._parent && this._parent._children.push(this), this.flagDirty();
  }
  get children() {
    return this._children;
  }
  set pos(t) {
    this._pos.x = t.x, this._pos.y = t.y;
  }
  get pos() {
    return this._pos;
  }
  set globalPos(t) {
    let e = t.clone();
    this.parent && (e = this.parent.inverse.multiply(t)), e.equals(this._pos) || (this._pos = e, this.flagDirty());
  }
  get globalPos() {
    return this._globalPos;
  }
  set rotation(t) {
    const e = Ht(t);
    e !== this._rotation && this.flagDirty(), this._rotation = e;
  }
  get rotation() {
    return this._rotation;
  }
  set globalRotation(t) {
    let e = 0;
    this.parent && (e = this.parent.globalRotation);
    const i = Ht(t + e);
    i !== this._rotation && this.flagDirty(), this._rotation = i;
  }
  get globalRotation() {
    return this.parent ? this.matrix.getRotation() : this.rotation;
  }
  set scale(t) {
    this._scale.x = t.x, this._scale.y = t.y;
  }
  get scale() {
    return this._scale;
  }
  set globalScale(t) {
    let e = w(1, 1);
    this.parent && (e = this.parent.globalScale), this.scale = t.scale(w(1 / e.x, 1 / e.y));
  }
  get globalScale() {
    return this._globalScale;
  }
  set z(t) {
    this._z = t, this.flagDirty();
  }
  get z() {
    return this._z;
  }
  set globalZ(t) {
    this.parent ? this.z = t - this.parent.globalZ : this.z = t;
  }
  get globalZ() {
    return this.parent ? this.z + this.parent.globalZ : this.z;
  }
  /**
   * Calculates and returns the matrix representation of this transform
   *
   * Avoid mutating the matrix to update the transform, it is not the source of truth.
   * Update the transform pos, rotation, scale.
   */
  get matrix() {
    return this._isDirty && (this.parent === null ? this._calculateMatrix().clone(this._matrix) : this.parent.matrix.multiply(this._calculateMatrix()).clone(this._matrix), this._isDirty = !1), this._matrix;
  }
  /**
   * Calculates and returns the inverse matrix representation of this transform
   */
  get inverse() {
    return this._isInverseDirty && (this.matrix.inverse(this._inverse), this._isInverseDirty = !1), this._inverse;
  }
  _calculateMatrix() {
    return this._scratch.data[0] = Math.cos(this._rotation), this._scratch.data[1] = Math.sin(this._rotation), this._scratch.data[2] = -Math.sin(this._rotation), this._scratch.data[3] = Math.cos(this.rotation), this._scratch.data[4] = this._pos.x, this._scratch.data[5] = this._pos.y, this._scratch.scale(this._scale.x, this._scale.y), this._scratch;
  }
  flagDirty() {
    this._isDirty = !0, this._isInverseDirty = !0;
    for (let t = 0; t < this._children.length; t++)
      this._children[t].flagDirty();
  }
  apply(t) {
    return this.matrix.multiply(t);
  }
  applyInverse(t) {
    return this.inverse.multiply(t);
  }
  setTransform(t, e, i) {
    this._pos.x = t.x, this._pos.y = t.y, this._rotation = Ht(e), this._scale.x = i.x, this._scale.y = i.y, this.flagDirty();
  }
  /**
   * Returns true if the transform has a negative x scale or y scale, but not both
   */
  isMirrored() {
    const t = q(this.scale.x) >>> 31, e = q(this.scale.y) >>> 31;
    return !!(t ^ e);
  }
  /**
   * Clones the current transform
   * **Warning does not clone the parent**
   * @param dest
   */
  clone(t) {
    const e = t != null ? t : new re();
    return this._pos.clone(e._pos), e._z = this._z, e._rotation = this._rotation, this._scale.clone(e._scale), e.flagDirty(), e;
  }
  /**
   * Clones but keeps the same parent reference
   */
  cloneWithParent(t) {
    const e = t != null ? t : new re();
    return this._pos.clone(e._pos), e._z = this._z, e._rotation = this._rotation, this._scale.clone(e._scale), e.parent = this.parent, e.flagDirty(), e;
  }
  toString() {
    return this.matrix.toString();
  }
}
var at = /* @__PURE__ */ ((r) => (r.World = "world", r.Screen = "screen", r))(at || {});
class Ye {
  constructor(t, e, i) {
    this.worldPos = t, this.pagePos = e, this.screenPos = i;
  }
  static fromPagePosition(t, e, i) {
    let s, n, o, a;
    arguments.length === 3 ? (s = t, n = e, o = new v(s, n), a = i) : (o = t, s = o.x, n = o.y, a = e);
    const h = a.screen.pageToScreenCoordinates(o), l = a.screen.screenToWorldCoordinates(h);
    return new Ye(l, o, h);
  }
}
class K {
  /**
   * @param begin  The starting point of the line segment
   * @param end  The ending point of the line segment
   */
  constructor(t, e) {
    this.begin = t, this.end = e;
  }
  clone(t) {
    const e = t || new K(this.begin.clone(), this.end.clone());
    return e.begin = this.begin.clone(e.begin), e.end = this.end.clone(e.end), e;
  }
  transform(t, e) {
    const i = e || new K(v.Zero, v.Zero);
    return i.begin = t.multiply(this.begin, i.begin), i.end = t.multiply(this.end, i.end), i;
  }
  /**
   * Gets the raw slope (m) of the line. Will return (+/-)Infinity for vertical lines.
   */
  get slope() {
    return (this.end.y - this.begin.y) / (this.end.x - this.begin.x);
  }
  /**
   * Gets the Y-intercept (b) of the line. Will return (+/-)Infinity if there is no intercept.
   */
  get intercept() {
    return this.begin.y - this.slope * this.begin.x;
  }
  /**
   * Gets the normal of the line
   */
  normal() {
    return this._normal ? this._normal : this._normal = this.end.sub(this.begin).normal();
  }
  dir() {
    return this._dir ? this._dir : this._dir = this.end.sub(this.begin);
  }
  getPoints() {
    return [this.begin, this.end];
  }
  /**
   * Returns the slope of the line in the form of a vector of length 1
   */
  getSlope() {
    if (this._slope)
      return this._slope;
    const t = this.begin, e = this.end, i = t.distance(e);
    return this._slope = e.sub(t).scale(1 / i);
  }
  /**
   * Returns the edge of the line as vector, the length of the vector is the length of the edge
   */
  getEdge() {
    const t = this.begin;
    return this.end.sub(t);
  }
  /**
   * Returns the length of the line segment in pixels
   */
  getLength() {
    const t = this.begin, e = this.end;
    return t.distance(e);
  }
  /**
   * Returns the midpoint of the edge
   */
  get midpoint() {
    return this.begin.add(this.end).scale(0.5);
  }
  /**
   * Flips the direction of the line segment
   */
  flip() {
    return new K(this.end, this.begin);
  }
  /**
   * Tests if a given point is below the line, points in the normal direction above the line are considered above.
   * @param point
   */
  below(t) {
    return (this.end.x - this.begin.x) * (t.y - this.begin.y) - (this.end.y - this.begin.y) * (t.x - this.begin.x) >= 0;
  }
  /**
   * Returns the clip point
   * @param sideVector Vector that traces the line
   * @param length Length to clip along side
   */
  clip(t, e, i = !0) {
    let s = t;
    i && (s = s.normalize());
    const n = s.dot(this.begin) - e, o = s.dot(this.end) - e, a = [];
    if (n <= 0 && a.push(this.begin), o <= 0 && a.push(this.end), n * o < 0) {
      const h = n / (n - o);
      a.push(this.begin.add(this.end.sub(this.begin).scale(h)));
    }
    return a.length !== 2 ? null : new K(a[0], a[1]);
  }
  /**
   * Find the perpendicular distance from the line to a point
   * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
   * @param point
   */
  distanceToPoint(t, e = !1) {
    const i = t.x, s = t.y, n = this.getLength(), o = this.end.y - this.begin.y, a = this.end.x - this.begin.x, h = (o * i - a * s + this.end.x * this.begin.y - this.end.y * this.begin.x) / n;
    return e ? h : Math.abs(h);
  }
  /**
   * Find the perpendicular line from the line to a point
   * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
   * (a - p) - ((a - p) * n)n
   * a is a point on the line
   * p is the arbitrary point above the line
   * n is a unit vector in direction of the line
   * @param point
   */
  findVectorToPoint(t) {
    const e = this.begin.sub(t), i = this.getSlope();
    return e.sub(i.scale(e.dot(i)));
  }
  /**
   * Finds a point on the line given only an X or a Y value. Given an X value, the function returns
   * a new point with the calculated Y value and vice-versa.
   * @param x The known X value of the target point
   * @param y The known Y value of the target point
   * @returns A new point with the other calculated axis value
   */
  findPoint(t = null, e = null) {
    const i = this.slope, s = this.intercept;
    if (t !== null)
      return new v(t, i * t + s);
    if (e !== null)
      return new v((e - s) / i, e);
    throw new Error("You must provide an X or a Y value");
  }
  /**
   * @see http://stackoverflow.com/a/11908158/109458
   */
  hasPoint() {
    let t, e = 0;
    if (typeof arguments[0] == "number" && typeof arguments[1] == "number")
      t = new v(arguments[0], arguments[1]), e = arguments[2] || 0;
    else if (arguments[0] instanceof v)
      t = arguments[0], e = arguments[1] || 0;
    else
      throw "Could not determine the arguments for Vector.hasPoint";
    const i = t.x - this.begin.x, s = t.y - this.begin.y, n = this.end.x - this.begin.x, o = this.end.y - this.begin.y, a = i * o - s * n;
    return Math.abs(a) > e ? !1 : Math.abs(n) >= Math.abs(o) ? n > 0 ? this.begin.x <= t.x && t.x <= this.end.x : this.end.x <= t.x && t.x <= this.begin.x : o > 0 ? this.begin.y <= t.y && t.y <= this.end.y : this.end.y <= t.y && t.y <= this.begin.y;
  }
}
class Si {
  constructor(t, e) {
    this.min = t, this.max = e;
  }
  overlaps(t) {
    return this.max > t.min && t.max > this.min;
  }
  getOverlap(t) {
    return this.overlaps(t) ? this.max > t.max ? t.max - this.min : this.max - t.min : 0;
  }
}
class Ce {
  /**
   * @param pos The starting position for the ray
   * @param dir The vector indicating the direction of the ray
   */
  constructor(t, e) {
    this.pos = t, this.dir = e.normalize();
  }
  /**
   * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.
   * This number indicates the mathematical intersection time.
   * @param line  The line to test
   */
  intersect(t) {
    const e = t.begin.sub(this.pos);
    if (this.dir.cross(t.getSlope()) === 0 && e.cross(this.dir) !== 0)
      return -1;
    const i = this.dir.cross(t.getSlope());
    if (i === 0)
      return -1;
    const s = e.cross(t.getSlope()) / i;
    if (s >= 0) {
      const n = e.cross(this.dir) / i / t.getLength();
      if (n >= 0 && n <= 1)
        return s;
    }
    return -1;
  }
  intersectPoint(t) {
    const e = this.intersect(t);
    return e < 0 ? null : this.getPoint(e);
  }
  /**
   * Returns the point of intersection given the intersection time
   */
  getPoint(t) {
    return this.pos.add(this.dir.scale(t));
  }
}
function ot(r, t, e) {
  return (1 - e) * r + t * e;
}
function cn(r, t, e, i) {
  const s = (r - t + vt) % vt >= Math.PI, n = Math.abs(t - r), o = vt - n;
  let a = 0, h = 0;
  n > o ? (a = o, h = n) : (a = n, h = o);
  let l = 0, c = 1;
  switch (e) {
    case J.ShortestPath:
      l = a, c = s ? 1 : -1;
      break;
    case J.LongestPath:
      l = h, c = s ? -1 : 1;
      break;
    case J.Clockwise:
      c = 1, l = s ? a : h;
      break;
    case J.CounterClockwise:
      c = -1, l = s ? h : a;
      break;
  }
  return r + c * (l * i);
}
function Ai(r, t, e) {
  return r.scale(1 - e).add(t.scale(e));
}
function ao(r, t, e) {
  return (e - r) / (t - r);
}
function ho(r, t, e) {
  const i = e.sub(r), s = t.sub(r), n = i.x / s.x, o = i.y / s.y;
  return Math.min(n, o);
}
function Jt(r, t, e, i, s) {
  const n = ao(r, t, s);
  return ot(e, i, n);
}
function Kh(r, t, e, i, s) {
  const n = ho(r, t, s);
  return Ai(e, i, n);
}
class Pi {
  constructor(t) {
    this._distLookup = [], this.quality = 4;
    var e;
    if (t.controlPoints.length !== 4)
      throw new Error("Only cubic bezier curves are supported");
    this._controlPoints = [...t.controlPoints], this.quality = (e = t.quality) != null ? e : this.quality, this._calculateLookup();
  }
  get arcLength() {
    return this._arcLength;
  }
  get controlPoints() {
    return this._controlPoints;
  }
  set controlPoints(t) {
    this._controlPoints = [...t], this._calculateLookup();
  }
  setControlPoint(t, e) {
    this._controlPoints[t] = e, this._calculateLookup();
  }
  _calculateLookup() {
    let t = 0;
    this._distLookup.length = 0;
    let e = this.controlPoints[0];
    const i = this.controlPoints.length * this.quality;
    for (let s = 0; s < i; s++) {
      const n = s / (i - 1), o = this.getPoint(n), a = e.distance(o);
      t += a, this._distLookup.push(t), e = o;
    }
    this._arcLength = t;
  }
  _getTimeGivenDistance(t) {
    const e = this._distLookup.length, i = this.arcLength;
    if (t >= 0 && t < i) {
      for (let s = 0; s < e - 1; s++)
        if (this._distLookup[s] <= t && t < this._distLookup[s + 1])
          return Jt(this._distLookup[s], this._distLookup[s + 1], s / (e - 1), (s + 1) / (e - 1), t);
    }
    return t / i;
  }
  /**
   * Get the point on the Bezier curve at a certain time
   * @param time Between 0-1
   */
  getPoint(t) {
    const e = [...this.controlPoints];
    for (let i = 1; i < e.length; i++)
      for (let s = 0; s < e.length - i; s++)
        e[s] = Ai(e[s], e[s + 1], t);
    return e[0];
  }
  /**
   * Get the tangent of the Bezier curve at a certain time
   * @param time Between 0-1
   */
  getTangent(t) {
    const e = t * t, i = this.controlPoints[0], s = this.controlPoints[1], n = this.controlPoints[2], o = this.controlPoints[3];
    return i.scale(-3 * e + 6 * t - 3).add(s.scale(9 * e - 12 * t + 3).add(n.scale(-9 * e + 6 * t).add(o.scale(3 * e)))).normalize();
  }
  /**
   * Get the tangent of the Bezier curve where the distance is uniformly distributed over time
   * @param time
   */
  getUniformTangent(t) {
    const e = t * this.arcLength, i = this._getTimeGivenDistance(e);
    return this.getTangent(i);
  }
  /**
   * Get the normal of the Bezier curve at a certain time
   * @param time Between 0-1
   */
  getNormal(t) {
    return this.getTangent(t).normal();
  }
  /**
   * Get the normal of the Bezier curve where the distance is uniformly distributed over time
   * @param time
   */
  getUniformNormal(t) {
    return this.getUniformTangent(t).normal();
  }
  /**
   * Points are spaced uniformly across the length of the curve over time
   * @param time
   */
  getUniformPoint(t) {
    const e = t * this.arcLength, i = this._getTimeGivenDistance(e);
    return this.getPoint(i);
  }
  clone() {
    return new Pi({
      controlPoints: [...this.controlPoints],
      quality: this.quality
    });
  }
}
class dn {
  /**
   * Constructs a new graph data structure.
   *
   * This constructor initializes an empty graph with no nodes or edges.
   */
  constructor() {
    this.id = cs.generateUUID(), this._nodes = /* @__PURE__ */ new Map(), this._edges = /* @__PURE__ */ new Set(), this.adjacencyList = /* @__PURE__ */ new Map();
  }
  /**
   * Adds a new node to the graph with the given data.
   * @returns The newly created node.
   */
  addNode(t, e) {
    let i;
    return e ? i = new lo(t, e) : i = new Xi(t), this._nodes.set(i.id, i), this.adjacencyList.set(i.id, /* @__PURE__ */ new Set()), i;
  }
  /**
   * Adds multiple new nodes to the graph with the given data.
   * @returns A map of all nodes in the graph, including the newly created ones.
   */
  addNodes(t) {
    for (const e of t) {
      const i = new Xi(e);
      this._nodes.set(i.id, i), this.adjacencyList.set(i.id, /* @__PURE__ */ new Set());
    }
    return this._nodes;
  }
  /**
   * Deletes a node from the graph along with all its associated edges.
   * This method removes the specified node and any edges connected to it
   * from the graph. It updates the internal structures to reflect these
   * changes.
   * @param node - The node to be deleted from the graph.
   * @returns A map of all remaining nodes in the graph.
   */
  deleteNode(t) {
    const e = t.edges;
    for (const i of e)
      this.deleteEdge(i);
    return this.adjacencyList.forEach((i, s) => {
      i.delete(t.id);
    }), this._nodes.delete(t.id), this.adjacencyList.delete(t.id), this._nodes;
  }
  /**
   * Adds a new edge between two nodes in the graph. If the edge already exists, it does not add a duplicate.
   * The function allows specifying edge options such as weight and directionality. For undirected edges,
   * it creates a duplicate edge in the reverse direction and links both edges as partners.
   * @param from - The source node of the edge.
   * @param to - The target node of the edge.
   * @param options - Optional settings for the edge, including weight and directionality.
   * @returns An array containing the created edge(s). If the edge is directed, the array contains one edge;
   *          if undirected, it contains both the original and the duplicate edge.
   */
  addEdge(t, e, i) {
    var s, n;
    if (Array.from(this._edges).find((l) => l.source.id === t.id && l.target.id === e.id))
      return [];
    let a;
    i ? a = "directed" in i ? i.directed : !1 : a = !1;
    const h = new zs(t, e, i);
    if (this._edges.add(h), t.registerNewEdge(h), e.registerNewEdge(h), (s = this.adjacencyList.get(t.id)) == null || s.add(e.id), !a) {
      const l = new zs(e, t, i);
      return (n = this.adjacencyList.get(e.id)) == null || n.add(t.id), this._edges.add(l), e.registerNewEdge(l), t.registerNewEdge(l), h.linkWithPartner(l), l.linkWithPartner(h), [h, l];
    }
    return [h];
  }
  /**
   * Deletes an edge from the graph.
   *
   * This method removes the specified edge and its partner edge (if any) from the graph.
   * It updates the internal edge set and edge list accordingly. The source and target
   * nodes of the edge are also updated to reflect the removal of the edge.
   * @param edge - The edge to be deleted from the graph.
   */
  deleteEdge(t) {
    t.source.breakEdge(t), t.target.breakEdge(t), this._edges.delete(t);
    const e = t.partnerEdge;
    e && (e.source.breakEdge(e), e.target.breakEdge(e), this._edges.delete(e));
  }
  /**
   * The set of nodes in the graph, keyed by their UUID.
   *
   * The map returned by this property is a shallow copy of the internal map.
   * The nodes in this map are not frozen, and may be modified by the caller.
   * @returns A shallow copy of the graph's internal node map.
   */
  get nodes() {
    return this._nodes;
  }
  /**
   * Gets a node by its UUID.
   * @param id - The UUID of the node to be retrieved.
   * @returns The node with the specified UUID, or undefined if no such node exists.
   */
  getNode(t) {
    return this._nodes.get(t);
  }
  /**
   * Retrieves the set of edges in the graph.
   *
   * The returned set is a shallow copy of the internal edge set.
   * Modifications to this set do not affect the graph's internal state.
   * @returns A set containing all edges in the graph.
   */
  get edges() {
    return this._edges;
  }
  /**
   * Gets the neighbors of the given node.
   *
   * The returned array contains all of the nodes that are directly connected to the given node.
   * @param node - The node whose neighbors should be retrieved.
   * @returns An array of nodes that are directly connected to the given node.
   */
  getNeighbors(t) {
    var e;
    return Array.from((e = this.adjacencyList.get(t.id)) != null ? e : []).map((i) => this.nodes.get(i));
  }
  /**
   * Checks if two nodes are connected by an edge.
   * @param node1 - The first node to check.
   * @param node2 - The second node to check.
   * @returns true if the nodes are connected, false if not.
   */
  areNodesConnected(t, e) {
    var i, s;
    return (s = (i = this.adjacencyList.get(t.id)) == null ? void 0 : i.has(e.id)) != null ? s : !1;
  }
  /**
   * Performs a breadth-first search (BFS) on the graph starting from the given node.
   *
   * This method explores the graph layer by layer, starting from the specified node.
   * It visits all nodes that are directly connected to the start node before moving
   * on to the nodes at the next level of the graph.
   * @param startNode - The node to start the BFS from.
   * @returns An array of UUIDs representing the nodes that were visited during the search.
   *          The order of the nodes in the array corresponds to the order in which they
   *          were visited.
   */
  bfs(t) {
    if (!this._nodes.has(t.id))
      return [];
    const e = [t.id], i = /* @__PURE__ */ new Set([t.id]);
    for (; e.length > 0; ) {
      const s = e.shift(), n = this.adjacencyList.get(s) || /* @__PURE__ */ new Set();
      for (const o of n)
        i.has(o) || (i.add(o), e.push(o));
    }
    return Array.from(i);
  }
  /**
   * Performs a depth-first search (DFS) on the graph starting from the given node.
   *
   * This method explores the graph by traversing as far as possible along each
   * branch before backtracking. It visits all nodes that are reachable from the
   * start node.
   * @param startNode - The node to start the DFS from.
   * @param [visited] - A set of node IDs that have already been visited during
   *                    the search. This parameter is optional, and defaults to an
   *                    empty set.
   * @returns An array of UUIDs representing the nodes that were visited during the
   *          search. The order of the nodes in the array corresponds to the order
   *          in which they were visited.
   */
  dfs(t, e = /* @__PURE__ */ new Set()) {
    var i;
    const s = t.id;
    if (!this._nodes.has(s))
      return [];
    e.add(s);
    let n = [s];
    for (const o of (i = this.adjacencyList.get(s)) != null ? i : [])
      e.has(o) || (n = n.concat(this.dfs(this._nodes.get(o), e)));
    return n;
  }
  /**
   * Creates a new graph from an array of nodes, and adds them all to the graph.
   * @param nodes - The array of nodes to add to the graph.
   * @returns The newly created graph.
   */
  static createGraphFromNodes(t) {
    const e = new dn();
    return e.addNodes(t), e;
  }
  /**
   * Finds the shortest path between two nodes in the graph using Dijkstra's algorithm.
   *
   * This method calculates the shortest path from the specified start node to the
   * specified end node in the graph. It returns an object containing the path and
   * the total distance of the path.
   * @param startNode - The node from which the search for the shortest path begins.
   * @param endNode - The node where the search for the shortest path ends.
   * @returns An object containing:
   *   - `path`: An array of nodes representing the shortest path from startNode to endNode.
   *     If no path is found, this will be `null`.
   *   - `distance`: The total distance of the shortest path. If no path is found, this will
   *     be `Infinity`.
   */
  dijkstra(t) {
    const e = [], i = [], s = [];
    this.nodes.forEach((l) => i.push(l)), this.nodes.forEach((l) => s.push({ node: l, distance: 1 / 0, previous: null }));
    const n = s.findIndex((l) => l.node === t);
    if (n === -1)
      return [];
    s[n].distance = 0, e.push(t), i.splice(i.indexOf(t), 1);
    let o = t;
    const a = o.edges, h = Array.from(a).filter((l) => l.target !== o);
    for (const l of h) {
      const c = s.findIndex((d) => d.node === l.target);
      if (c === -1)
        return [];
      s[c].distance = l.weight, s[c].previous = o;
    }
    for (; i.length > 0; ) {
      let l = [], c = [];
      c = s.filter((p) => i.includes(p.node)), l = c.map((p) => p.node);
      let d = 1 / 0, u = -1;
      if (l.length > 0)
        for (let p = 0; p < l.length; p++) {
          const g = l[p], x = s.findIndex((m) => m.node === g);
          s[x].distance < d && (d = s[x].distance, u = x);
        }
      else {
        d = 1 / 0, u = -1;
        for (let p = 0; p < i.length; p++) {
          const g = i[p], x = s.findIndex((m) => m.node === g);
          s[x].distance < d && (d = s[x].distance, u = x);
        }
      }
      if (u === -1)
        return [];
      o = s[u].node;
      let _ = Array.from(o.edges);
      _ = _.filter((p) => !e.includes(p.source) && !e.includes(p.target) && p.target !== o), e.push(o), i.splice(i.indexOf(o), 1);
      for (let p = 0; p < _.length; p++) {
        const g = _[p], x = s.findIndex((C) => C.node === g.target), m = s.findIndex((C) => C.node === g.source), b = s[m].distance + g.weight;
        b < s[x].distance && (s[x].distance = b, s[x].previous = o);
      }
    }
    return s;
  }
  /**
   * Finds the shortest path between two nodes in the graph using the Dijkstra method
   *
   * This method calculates the shortest path from the specified start node to the
   * specified end node in the graph. It returns an object containing the path and
   * the total distance of the path.
   * @param startingNode - The node from which the search for the shortest path begins.
   * @param endNode - The node where the search for the shortest path ends.
   * @returns An object containing:
   *   - `path`: An array of nodes representing the shortest path from startNode to endNode.
   *     If no path is found, this will be `null`.
   *   - `distance`: The total distance of the shortest path. If no path is found, this will
   *     be `Infinity`.
   */
  shortestPathDijkstra(t, e) {
    var i, s;
    const n = this.dijkstra(t);
    if (n.length === 0)
      return { path: [], distance: 1 / 0 };
    const o = [];
    let a = e;
    const h = (i = n.find((l) => l.node === e)) == null ? void 0 : i.distance;
    for (; a != null && (o.push(a), a = (s = n.find((l) => l.node === a)) == null ? void 0 : s.previous, a != null); )
      ;
    return o.reverse(), { path: o, distance: h };
  }
  /**
   * Finds the shortest path between two nodes in the graph using the A* algorithm.
   *
   * This method calculates the shortest path from the specified start node to the
   * specified end node in the graph. It returns an object containing the path and
   * the total distance of the path.
   * @param startNode - The node from which the search for the shortest path begins.
   * @param endNode - The node where the search for the shortest path ends.
   * @returns An object containing:
   *   - `path`: An array of nodes representing the shortest path from startNode to endNode.
   *     If no path is found, this will be `null`.
   *   - `distance`: The total distance of the shortest path. If no path is found, this will
   *     be `Infinity`.
   *   - `skippedNodes`: A set of all nodes that were skipped during the search (because they
   *     were not `PositionNode`s).
   */
  aStar(t, e) {
    if (!("pos" in t) || !("pos" in e))
      throw new Error("A* algorithm requires PositionNode with position vectors");
    const i = /* @__PURE__ */ new Set([t.id]), s = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map();
    for (const [d, u] of this._nodes)
      "pos" in u ? c.set(d, u) : n.add(d);
    for (const [d] of c)
      o.set(d, this._euclideanDistance(c.get(d), t)), a.set(d, this._euclideanDistance(c.get(d), e)), h.set(d, o.get(d) + a.get(d)), l.set(d, null);
    for (; i.size > 0; ) {
      let d = null, u = 1 / 0;
      for (const g of i) {
        const x = h.get(g) || 1 / 0;
        x < u && (u = x, d = g);
      }
      if (d === null)
        break;
      if (d === e.id) {
        const g = [];
        let x = e.id;
        for (; x !== null; ) {
          const m = this._nodes.get(x);
          g.unshift(m), x = l.get(x);
        }
        return {
          path: g,
          pathSteps: g.length - 1,
          distance: o.get(e.id) || 1 / 0,
          skippedNodes: n
        };
      }
      i.delete(d), s.add(d);
      const _ = this._nodes.get(d), p = this.getNeighbors(_);
      for (const g of p) {
        const x = g.id;
        s.has(x) || !("pos" in g) || !Array.from(_.edges).find((b) => b.source.id === d && b.target.id === x) || (l.set(x, d), i.has(x) || i.add(x));
      }
    }
    return { path: [], pathSteps: 0, distance: 1 / 0, skippedNodes: n };
  }
  _euclideanDistance(t, e) {
    const i = t.pos, s = e.pos;
    return Math.sqrt((s.x - i.x) ** 2 + (s.y - i.y) ** 2);
  }
}
class zs {
  // Reference to the opposite direction edge
  constructor(t, e, i) {
    this._id = cs.generateUUID(), this._weight = 0, this._partnerEdge = null, this._source = t, this._target = e, i && i.weight ? this._weight = i.weight : i && i.useEuclidean ? this._weight = t.pos.distance(e.pos) : this._weight = 0;
  }
  linkWithPartner(t) {
    this._partnerEdge = t;
  }
  get id() {
    return this._id;
  }
  get source() {
    return this._source;
  }
  get target() {
    return this._target;
  }
  get weight() {
    return this._weight;
  }
  get partnerEdge() {
    return this._partnerEdge;
  }
}
class Xi {
  constructor(t) {
    this._id = cs.generateUUID(), this._data = t, this._edges = /* @__PURE__ */ new Set();
  }
  get id() {
    return this._id;
  }
  get data() {
    return this._data;
  }
  get edges() {
    return this._edges;
  }
  registerNewEdge(t) {
    this._edges.add(t);
  }
  breakEdge(t) {
    this._edges.delete(t);
  }
  getConnectedNodes() {
    return Array.from(this._edges).map((t) => t.target);
  }
}
class lo extends Xi {
  constructor(t, e) {
    super(t), this.pos = e;
  }
}
const un = class _n {
  static generateUUID() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(i) {
      const s = _n.rng.next() * 16 | 0;
      return (i === "x" ? s : s & 3 | 8).toString(16);
    });
  }
};
un.rng = new ge();
let cs = un;
function ds(r) {
  return r;
}
function tl(r, t, e) {
  return r = D((r - t) / (e - t), 0, 1), r * r * (3 - 2 * r);
}
function el(r, t, e) {
  return r = D((r - t) / (e - t), 0, 1), r * r * r * (r * (6 * r - 15) + 10);
}
function il(r) {
  return -1 * Math.cos(r * (Math.PI / 2)) + 1;
}
function sl(r) {
  return Math.sin(r * (Math.PI / 2));
}
function nl(r) {
  return -0.5 * (Math.cos(Math.PI * r) - 1);
}
function rl(r) {
  return r * r;
}
function ol(r) {
  return r * (2 - r);
}
function al(r) {
  return r < 0.5 ? 2 * r * r : -1 + (4 - 2 * r) * r;
}
function hl(r) {
  return r * r * r;
}
function ll(r) {
  const t = r - 1;
  return t * t * t + 1;
}
function Hs(r) {
  return r < 0.5 ? 4 * r * r * r : (r - 1) * (2 * r - 2) * (2 * r - 2) + 1;
}
function cl(r) {
  return r * r * r * r;
}
function dl(r) {
  const t = r - 1;
  return 1 - t * t * t * t;
}
function ul(r) {
  const t = r - 1;
  return r < 0.5 ? 8 * r * r * r * r : 1 - 8 * t * t * t * t;
}
function _l(r) {
  return r * r * r * r * r;
}
function fl(r) {
  const t = r - 1;
  return 1 + t * t * t * t * t;
}
function gl(r) {
  const t = r - 1;
  return r < 0.5 ? 16 * r * r * r * r * r : 1 + 16 * t * t * t * t * t;
}
function pl(r) {
  return r === 0 ? 0 : Math.pow(2, 10 * (r - 1));
}
function ml(r) {
  return r === 1 ? 1 : -Math.pow(2, -10 * r) + 1;
}
function xl(r) {
  if (r === 0 || r === 1)
    return r;
  const t = r * 2, e = t - 1;
  return t < 1 ? 0.5 * Math.pow(2, 10 * e) : 0.5 * (-Math.pow(2, -10 * e) + 2);
}
function vl(r) {
  const t = r / 1;
  return -1 * (Math.sqrt(1 - t * r) - 1);
}
function wl(r) {
  const t = r - 1;
  return Math.sqrt(1 - t * t);
}
function bl(r) {
  const t = r * 2, e = t - 2;
  return t < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - e * e) + 1);
}
function yl(r, t = 1.70158) {
  return r * r * ((t + 1) * r - t);
}
function Cl(r, t = 1.70158) {
  const e = r / 1 - 1;
  return e * e * ((t + 1) * e + t) + 1;
}
function Tl(r, t = 1.70158) {
  const e = r * 2, i = e - 2, s = t * 1.525;
  return e < 1 ? 0.5 * e * e * ((s + 1) * e - s) : 0.5 * (i * i * ((s + 1) * i + s) + 2);
}
function Sl(r, t = 0.7) {
  if (r === 0 || r === 1)
    return r;
  const i = r / 1 - 1, s = 1 - t, n = s / (2 * Math.PI) * Math.asin(1);
  return -(Math.pow(2, 10 * i) * Math.sin((i - n) * (2 * Math.PI) / s));
}
function Al(r, t = 0.7) {
  if (r === 0 || r === 1)
    return r;
  const e = 1 - t, i = r * 2, s = e / (2 * Math.PI) * Math.asin(1);
  return Math.pow(2, -10 * i) * Math.sin((i - s) * (2 * Math.PI) / e) + 1;
}
function Pl(r, t = 0.65) {
  if (r === 0 || r === 1)
    return r;
  const e = 1 - t, i = r * 2, s = i - 1, n = e / (2 * Math.PI) * Math.asin(1);
  return i < 1 ? -0.5 * (Math.pow(2, 10 * s) * Math.sin((s - n) * (2 * Math.PI) / e)) : Math.pow(2, -10 * s) * Math.sin((s - n) * (2 * Math.PI) / e) * 0.5 + 1;
}
function fn(r) {
  const t = r / 1;
  if (t < 1 / 2.75)
    return 7.5625 * t * t;
  if (t < 2 / 2.75) {
    const e = t - 0.5454545454545454;
    return 7.5625 * e * e + 0.75;
  } else if (t < 2.5 / 2.75) {
    const e = t - 0.8181818181818182;
    return 7.5625 * e * e + 0.9375;
  } else {
    const e = t - 0.9545454545454546;
    return 7.5625 * e * e + 0.984375;
  }
}
function co(r) {
  return 1 - fn(1 - r);
}
function El(r) {
  return r < 0.5 ? co(r * 2) * 0.5 : fn(r * 2 - 1) * 0.5 + 0.5;
}
class T {
  /**
   * Creates a new instance of Color from an r, g, b, a
   * @param r  The red component of color (0-255)
   * @param g  The green component of color (0-255)
   * @param b  The blue component of color (0-255)
   * @param a  The alpha component of color (0-1.0)
   */
  constructor(t, e, i, s) {
    this.r = t, this.g = e, this.b = i, this.a = s != null ? s : 1;
  }
  /**
   * Creates a new instance of Color from an r, g, b, a
   * @param r  The red component of color (0-255)
   * @param g  The green component of color (0-255)
   * @param b  The blue component of color (0-255)
   * @param a  The alpha component of color (0-1.0)
   */
  static fromRGB(t, e, i, s) {
    return new T(t, e, i, s);
  }
  /**
   * Creates a new instance of Color from a rgb string
   * @param string  CSS color string of the form rgba(255, 255, 255, 1) or rgb(255, 255, 255)
   */
  static fromRGBString(t) {
    const e = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)/i;
    let i = null;
    if (i = t.match(e)) {
      const s = parseInt(i[1], 10), n = parseInt(i[2], 10), o = parseInt(i[3], 10);
      let a = 1;
      return i[4] && (a = parseFloat(i[4])), new T(s, n, o, a);
    } else
      throw new Error("Invalid rgb/a string: " + t);
  }
  /**
   * Creates a new instance of Color from a hex string
   * @param hex  CSS color string of the form #ffffff, the alpha component is optional
   */
  static fromHex(t) {
    const e = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
    let i = null;
    if (i = t.match(e)) {
      const s = parseInt(i[1], 16), n = parseInt(i[2], 16), o = parseInt(i[3], 16);
      let a = 1;
      return i[4] && (a = parseInt(i[4], 16) / 255), new T(s, n, o, a);
    } else
      throw new Error("Invalid hex string: " + t);
  }
  /**
   * Creates a new instance of Color from hsla values
   * @param h  Hue is represented [0-1]
   * @param s  Saturation is represented [0-1]
   * @param l  Luminance is represented [0-1]
   * @param a  Alpha is represented [0-1]
   */
  static fromHSL(t, e, i, s = 1) {
    return new pt(t, e, i, s).toRGBA();
  }
  /**
   * Lightens the current color by a specified amount
   * @param factor  The amount to lighten by [0-1]
   */
  lighten(t = 0.1) {
    const e = pt.fromRGBA(this.r, this.g, this.b, this.a);
    return e.l += (1 - e.l) * t, e.toRGBA();
  }
  /**
   * Darkens the current color by a specified amount
   * @param factor  The amount to darken by [0-1]
   */
  darken(t = 0.1) {
    const e = pt.fromRGBA(this.r, this.g, this.b, this.a);
    return e.l -= e.l * t, e.toRGBA();
  }
  /**
   * Saturates the current color by a specified amount
   * @param factor  The amount to saturate by [0-1]
   */
  saturate(t = 0.1) {
    const e = pt.fromRGBA(this.r, this.g, this.b, this.a);
    return e.s += e.s * t, e.toRGBA();
  }
  /**
   * Desaturates the current color by a specified amount
   * @param factor  The amount to desaturate by [0-1]
   */
  desaturate(t = 0.1) {
    const e = pt.fromRGBA(this.r, this.g, this.b, this.a);
    return e.s -= e.s * t, e.toRGBA();
  }
  /**
   * Multiplies a color by another, results in a darker color
   * @param color  The other color
   */
  multiply(t) {
    const e = t.r / 255 * this.r / 255 * 255, i = t.g / 255 * this.g / 255 * 255, s = t.b / 255 * this.b / 255 * 255, n = t.a * this.a;
    return new T(e, i, s, n);
  }
  /**
   * Screens a color by another, results in a lighter color
   * @param color  The other color
   */
  screen(t) {
    const e = t.invert(), i = t.invert();
    return e.multiply(i).invert();
  }
  /**
   * Inverts the current color
   */
  invert() {
    return new T(255 - this.r, 255 - this.g, 255 - this.b, 1 - this.a);
  }
  /**
   * Averages the current color with another
   * @param color  The other color
   */
  average(t) {
    const e = (t.r + this.r) / 2, i = (t.g + this.g) / 2, s = (t.b + this.b) / 2, n = (t.a + this.a) / 2;
    return new T(e, i, s, n);
  }
  equal(t) {
    return this.toString() === t.toString();
  }
  /**
   * Returns a CSS string representation of a color.
   * @param format Color representation, accepts: rgb, hsl, or hex
   */
  toString(t = "rgb") {
    switch (t) {
      case "rgb":
        return this.toRGBA();
      case "hsl":
        return this.toHSLA();
      case "hex":
        return this.toHex();
      default:
        throw new Error("Invalid Color format");
    }
  }
  /**
   * Returns Hex Value of a color component
   * @param c color component
   * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
   */
  _componentToHex(t) {
    const e = Math.max(Math.round(t), 0).toString(16);
    return e.length === 1 ? "0" + e : e;
  }
  /**
   * Return Hex representation of a color.
   */
  toHex() {
    let t = "#" + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);
    return this.a !== 1 && (t += this._componentToHex(this.a * 255)), t;
  }
  /**
   * Return RGBA representation of a color.
   */
  toRGBA() {
    const t = String(this.r.toFixed(0)) + ", " + String(this.g.toFixed(0)) + ", " + String(this.b.toFixed(0));
    return this.a !== void 0 || this.a !== null ? "rgba(" + t + ", " + String(this.a) + ")" : "rgb(" + t + ")";
  }
  /**
   * Return HSLA representation of a color.
   */
  toHSLA() {
    return pt.fromRGBA(this.r, this.g, this.b, this.a).toString();
  }
  /**
   * Returns a CSS string representation of a color.
   */
  fillStyle() {
    return this.toString();
  }
  /**
   * Returns a clone of the current color.
   */
  clone(t) {
    const e = t || new T(this.r, this.g, this.b, this.a);
    return e.r = this.r, e.g = this.g, e.b = this.b, e.a = this.a, e;
  }
  /**
   * Lerp between two colors
   */
  static lerp(t, e, i) {
    const s = pt.fromRGBA(t.r, t.g, t.b, t.a), n = pt.fromRGBA(e.r, e.g, e.b, e.a);
    return pt.lerp(s, n, i).toRGBA();
  }
  static random(t) {
    const e = t != null ? t : new ge();
    return new T(e.integer(0, 255), e.integer(0, 255), e.integer(0, 255));
  }
  /**
   * Black (#000000)
   */
  static get Black() {
    return T.fromHex("#000000");
  }
  /**
   * White (#FFFFFF)
   */
  static get White() {
    return T.fromHex("#FFFFFF");
  }
  /**
   * Gray (#808080)
   */
  static get Gray() {
    return T.fromHex("#808080");
  }
  /**
   * Light gray (#D3D3D3)
   */
  static get LightGray() {
    return T.fromHex("#D3D3D3");
  }
  /**
   * Dark gray (#A9A9A9)
   */
  static get DarkGray() {
    return T.fromHex("#A9A9A9");
  }
  /**
   * Yellow (#FFFF00)
   */
  static get Yellow() {
    return T.fromHex("#FFFF00");
  }
  /**
   * Orange (#FFA500)
   */
  static get Orange() {
    return T.fromHex("#FFA500");
  }
  /**
   * Red (#FF0000)
   */
  static get Red() {
    return T.fromHex("#FF0000");
  }
  /**
   * Vermilion (#FF5B31)
   */
  static get Vermilion() {
    return T.fromHex("#FF5B31");
  }
  /**
   * Rose (#FF007F)
   */
  static get Rose() {
    return T.fromHex("#FF007F");
  }
  /**
   * Pink (#FFC0CB)
   */
  static get Pink() {
    return T.fromHex("#FFC0CB");
  }
  /**
   * Magenta (#FF00FF)
   */
  static get Magenta() {
    return T.fromHex("#FF00FF");
  }
  /**
   * Violet (#7F00FF)
   */
  static get Violet() {
    return T.fromHex("#7F00FF");
  }
  /**
   * Purple (#800080)
   */
  static get Purple() {
    return T.fromHex("#800080");
  }
  /**
   * Blue (#0000FF)
   */
  static get Blue() {
    return T.fromHex("#0000FF");
  }
  /**
   * Azure (#007FFF)
   */
  static get Azure() {
    return T.fromHex("#007FFF");
  }
  /**
   * Cyan (#00FFFF)
   */
  static get Cyan() {
    return T.fromHex("#00FFFF");
  }
  /**
   * Viridian (#59978F)
   */
  static get Viridian() {
    return T.fromHex("#59978F");
  }
  /**
   * Teal (#008080)
   */
  static get Teal() {
    return T.fromHex("#008080");
  }
  /**
   * Green (#00FF00)
   */
  static get Green() {
    return T.fromHex("#00FF00");
  }
  /**
   * Chartreuse (#7FFF00)
   */
  static get Chartreuse() {
    return T.fromHex("#7FFF00");
  }
  /**
   * Transparent (#FFFFFF00)
   */
  static get Transparent() {
    return T.fromHex("#FFFFFF00");
  }
  /**
   * ExcaliburBlue (#176BAA)
   */
  static get ExcaliburBlue() {
    return T.fromHex("#176BAA");
  }
  /**
   * Brown (#964B00)
   */
  static get Brown() {
    return T.fromHex("#964B00");
  }
}
class pt {
  constructor(t, e, i, s) {
    this.h = t, this.s = e, this.l = i, this.a = s;
  }
  static hue2rgb(t, e, i) {
    return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + (e - t) * 6 * i : i < 1 / 2 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t;
  }
  static fromRGBA(t, e, i, s) {
    t /= 255, e /= 255, i /= 255;
    const n = Math.max(t, e, i), o = Math.min(t, e, i);
    let a, h;
    const l = (n + o) / 2;
    if (n === o)
      a = h = 0;
    else {
      const c = n - o;
      switch (h = l > 0.5 ? c / (2 - n - o) : c / (n + o), n) {
        case t:
          a = (e - i) / c + (e < i ? 6 : 0);
          break;
        case e:
          a = (i - t) / c + 2;
          break;
        case i:
          a = (t - e) / c + 4;
          break;
      }
      a /= 6;
    }
    return new pt(a, h, l, s);
  }
  toRGBA() {
    let t, e, i;
    if (this.s === 0)
      t = e = i = this.l;
    else {
      const s = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s, n = 2 * this.l - s;
      t = pt.hue2rgb(n, s, this.h + 1 / 3), e = pt.hue2rgb(n, s, this.h), i = pt.hue2rgb(n, s, this.h - 1 / 3);
    }
    return new T(t * 255, e * 255, i * 255, this.a);
  }
  toString() {
    const t = this.h.toFixed(0), e = this.s.toFixed(0), i = this.l.toFixed(0), s = this.a.toFixed(0);
    return `hsla(${t}, ${e}, ${i}, ${s})`;
  }
  static lerp(t, e, i) {
    i = Math.max(0, Math.min(1, i));
    let s = e.h - t.h;
    s > 0.5 ? s -= 1 : s < -0.5 && (s += 1);
    const n = (t.h + s * i + 1) % 1, o = t.s + (e.s - t.s) * i, a = t.l + (e.l - t.l) * i, h = t.a + (e.a - t.a) * i;
    return new pt(n, o, a, h);
  }
}
var je = /* @__PURE__ */ ((r) => (r[r.Debug = 0] = "Debug", r[r.Info = 1] = "Info", r[r.Warn = 2] = "Warn", r[r.Error = 3] = "Error", r[r.Fatal = 4] = "Fatal", r))(je || {});
const gn = class Gt {
  constructor() {
    if (this._appenders = [], this.defaultLevel = 1, this._logOnceSet = /* @__PURE__ */ new Set(), Gt._INSTANCE)
      throw new Error("Logger is a singleton");
    return Gt._INSTANCE = this, Gt._INSTANCE.addAppender(new pn()), Gt._INSTANCE;
  }
  /**
   * Gets the current static instance of Logger
   */
  static getInstance() {
    return Gt._INSTANCE == null && (Gt._INSTANCE = new Gt()), Gt._INSTANCE;
  }
  /**
   * Adds a new {@apilink Appender} to the list of appenders to write to
   */
  addAppender(t) {
    this._appenders.push(t);
  }
  /**
   * Clears all appenders from the logger
   */
  clearAppenders() {
    this._appenders.length = 0;
  }
  /**
   * Logs a message at a given LogLevel
   * @param level  The LogLevel`to log the message at
   * @param args   An array of arguments to write to an appender
   */
  _log(t, e) {
    t == null && (t = this.defaultLevel);
    const i = this._appenders.length;
    for (let s = 0; s < i; s++)
      t >= this.defaultLevel && this._appenders[s].log(t, e);
  }
  _logOnce(t, e) {
    const i = t + e.join("+");
    this._logOnceSet.has(i) || (this._logOnceSet.add(i), this._log(t, e));
  }
  /**
   * Writes a log message at the {@apilink LogLevel.Debug} level
   * @param args  Accepts any number of arguments
   */
  debug(...t) {
    this._log(0, t);
  }
  /**
   * Writes a log message once at the {@apilink LogLevel.Fatal} level, if it sees the same args again it wont log
   * @param args  Accepts any number of arguments
   */
  debugOnce(...t) {
    this._logOnce(0, t);
  }
  /**
   * Writes a log message at the {@apilink LogLevel.Info} level
   * @param args  Accepts any number of arguments
   */
  info(...t) {
    this._log(1, t);
  }
  /**
   * Writes a log message once at the {@apilink LogLevel.Info} level, if it sees the same args again it wont log
   * @param args  Accepts any number of arguments
   */
  infoOnce(...t) {
    this._logOnce(1, t);
  }
  /**
   * Writes a log message at the {@apilink LogLevel.Warn} level
   * @param args  Accepts any number of arguments
   */
  warn(...t) {
    this._log(2, t);
  }
  /**
   * Writes a log message once at the {@apilink LogLevel.Warn} level, if it sees the same args again it won't log
   * @param args  Accepts any number of arguments
   */
  warnOnce(...t) {
    this._logOnce(2, t);
  }
  /**
   * Writes a log message at the {@apilink LogLevel.Error} level
   * @param args  Accepts any number of arguments
   */
  error(...t) {
    this._log(3, t);
  }
  /**
   * Writes a log message once at the {@apilink LogLevel.Error} level, if it sees the same args again it won't log
   * @param args  Accepts any number of arguments
   */
  errorOnce(...t) {
    this._logOnce(3, t);
  }
  /**
   * Writes a log message at the {@apilink LogLevel.Fatal} level
   * @param args  Accepts any number of arguments
   */
  fatal(...t) {
    this._log(4, t);
  }
  /**
   * Writes a log message once at the {@apilink LogLevel.Fatal} level, if it sees the same args again it won't log
   * @param args  Accepts any number of arguments
   */
  fatalOnce(...t) {
    this._logOnce(4, t);
  }
};
gn._INSTANCE = null;
let R = gn;
class pn {
  /**
   * Logs a message at the given {@apilink LogLevel}
   * @param level  Level to log at
   * @param args   Arguments to log
   */
  log(t, e) {
    if (!console && !console.log && console.warn && console.error)
      return;
    const i = [];
    i.unshift.apply(i, e), i.unshift("[" + je[t] + "] : "), t < 2 ? console.log.apply ? console.log.apply(console, i) : console.log(i.join(" ")) : t < 3 ? console.warn.apply ? console.warn.apply(console, i) : console.warn(i.join(" ")) : console.error.apply ? console.error.apply(console, i) : console.error(i.join(" "));
  }
}
class uo {
  constructor(t) {
    this._messages = [], this._pos = 10, this._color = T.Black;
    var e, i;
    this._options = t, this.canvas = document.createElement("canvas"), this._ctx = this.canvas.getContext("2d"), this.canvas.style.position = "absolute", this.canvas.style.zIndex = (i = (e = t.zIndex) == null ? void 0 : e.toString()) != null ? i : "99", this.canvas.style.pointerEvents = "none", this.canvas.style.userSelect = "none", document.body.appendChild(this.canvas), this._positionScreenAppenderCanvas(), t.engine.screen.events.on("resize", () => {
      this._positionScreenAppenderCanvas();
    });
  }
  _positionScreenAppenderCanvas() {
    var t, e, i, s;
    const n = this._options;
    this.canvas.width = (t = n.width) != null ? t : n.engine.screen.resolution.width, this.canvas.height = (e = n.height) != null ? e : n.engine.screen.resolution.height, this.canvas.style.position = "absolute";
    const o = n.engine.screen.screenToPageCoordinates(w(0, 0));
    this.canvas.style.left = o.x + "px", this.canvas.style.top = o.y + "px", this._pos = (i = n.xPos) != null ? i : this._pos, this._color = (s = n.color) != null ? s : this._color;
  }
  /**
   * Logs a message at the given {@apilink LogLevel}
   * @param level  Level to log at
   * @param args   Arguments to log
   */
  log(t, e) {
    const i = e.join(",");
    this._ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), this._messages.unshift("[" + je[t] + "] : " + i);
    let s = 10;
    this._messages = this._messages.slice(0, 1e3);
    for (let n = 0; n < this._messages.length; n++)
      this._ctx.fillStyle = this._color.toRGBA(), this._ctx.fillText(this._messages[n], this._pos, s), s += 10;
  }
}
var E = /* @__PURE__ */ ((r) => (r.PreventCollision = "PreventCollision", r.Passive = "Passive", r.Active = "Active", r.Fixed = "Fixed", r))(E || {});
function _o(r) {
  return !!r && !!r.prototype && !!r.prototype.constructor;
}
function fo(r) {
  return !!(r != null && r.clone);
}
class kt {
  constructor() {
    this.owner = void 0;
  }
  /**
   * Clones any properties on this component, if that property value has a `clone()` method it will be called
   */
  clone() {
    const t = new this.constructor();
    for (const e in this)
      if (this.hasOwnProperty(e)) {
        const i = this[e];
        fo(i) && e !== "owner" && e !== "clone" ? t[e] = i.clone() : t[e] = i;
      }
    return t;
  }
}
class mt {
  constructor() {
    this.observers = [], this.subscriptions = [];
  }
  /**
   * Register an observer to listen to this observable
   * @param observer
   */
  register(t) {
    this.observers.push(t);
  }
  /**
   * Register a callback to listen to this observable
   * @param func
   */
  subscribe(t) {
    this.subscriptions.push(t);
  }
  /**
   * Remove an observer from the observable
   * @param observer
   */
  unregister(t) {
    const e = this.observers.indexOf(t);
    e !== -1 && this.observers.splice(e, 1);
  }
  /**
   * Remove a callback that is listening to this observable
   * @param func
   */
  unsubscribe(t) {
    const e = this.subscriptions.indexOf(t);
    e !== -1 && this.subscriptions.splice(e, 1);
  }
  /**
   * Broadcasts a message to all observers and callbacks
   * @param message
   */
  notifyAll(t) {
    const e = this.observers.length;
    for (let s = 0; s < e; s++)
      this.observers[s].notify(t);
    const i = this.subscriptions.length;
    for (let s = 0; s < i; s++)
      this.subscriptions[s](t);
  }
  /**
   * Removes all observers and callbacks
   */
  clear() {
    this.observers.length = 0, this.subscriptions.length = 0;
  }
}
class P extends kt {
  constructor() {
    super(...arguments), this._logger = R.getInstance(), this._parentComponent = null, this._transform = new re(), this._addChildTransform = (t) => {
      const e = t.get(P);
      e && (e._transform.parent = this._transform, e._parentComponent = this);
    }, this.zIndexChanged$ = new mt(), this._coordPlane = at.World;
  }
  get() {
    return this._transform;
  }
  onAdd(t) {
    for (const e of t.children)
      this._addChildTransform(e);
    t.childrenAdded$.subscribe((e) => this._addChildTransform(e)), t.childrenRemoved$.subscribe((e) => {
      const i = e.get(P);
      i && (i._transform.parent = null, i._parentComponent = null);
    });
  }
  onRemove(t) {
    this._transform.parent = null, this._parentComponent = null;
  }
  /**
   * The z-index ordering of the entity, a higher values are drawn on top of lower values.
   * For example z=99 would be drawn on top of z=0.
   */
  get z() {
    return this._transform.z;
  }
  set z(t) {
    const e = this._transform.z;
    this._transform.z = t, e !== t && this.zIndexChanged$.notifyAll(t);
  }
  get globalZ() {
    return this._transform.globalZ;
  }
  set globalZ(t) {
    this._transform.globalZ = t;
  }
  /**
   * The {@apilink CoordPlane | `coordinate plane`} for this transform for the entity.
   */
  get coordPlane() {
    return this._parentComponent ? this._parentComponent.coordPlane : this._coordPlane;
  }
  set coordPlane(t) {
    var e;
    this._parentComponent ? this._logger.warn(
      `Cannot set coordinate plane on child entity ${(e = this.owner) == null ? void 0 : e.name}, children inherit their coordinate plane from their parents.`
    ) : this._coordPlane = t;
  }
  get pos() {
    return this._transform.pos;
  }
  set pos(t) {
    this._transform.pos = t;
  }
  get globalPos() {
    return this._transform.globalPos;
  }
  set globalPos(t) {
    this._transform.globalPos = t;
  }
  get rotation() {
    return this._transform.rotation;
  }
  set rotation(t) {
    this._transform.rotation = t;
  }
  get globalRotation() {
    return this._transform.globalRotation;
  }
  set globalRotation(t) {
    this._transform.globalRotation = t;
  }
  get scale() {
    return this._transform.scale;
  }
  set scale(t) {
    this._transform.scale = t;
  }
  get globalScale() {
    return this._transform.globalScale;
  }
  set globalScale(t) {
    this._transform.globalScale = t;
  }
  applyInverse(t) {
    return this._transform.applyInverse(t);
  }
  apply(t) {
    return this._transform.apply(t);
  }
  clone() {
    const t = new P();
    return t._transform = this._transform.clone(), t;
  }
}
class N extends kt {
  constructor() {
    super(...arguments), this.vel = v.Zero, this.maxVel = v.One.scaleEqual(1 / 0), this.acc = v.Zero, this.scaleFactor = v.Zero, this.angularVelocity = 0, this.torque = 0, this.inertia = 1, this.integration = {
      onScreenOnly: !1
    };
  }
}
const ue = class {
  /**
   * Create a new named collision group up to a max of 32.
   * @param name Name for the collision group
   * @param mask Optionally provide your own 32-bit mask, if none is provide the manager will generate one
   */
  static create(t, e) {
    if (this._CURRENT_GROUP > this._MAX_GROUPS)
      throw new Error(`Cannot have more than ${this._MAX_GROUPS} collision groups`);
    if (this._GROUPS.get(t)) {
      const s = this._GROUPS.get(t);
      if (s.mask === e)
        return s;
      throw new Error(`Collision group ${t} already exists with a different mask!`);
    }
    const i = new Ee(t, this._CURRENT_BIT, e !== void 0 ? e : ~this._CURRENT_BIT);
    return this._CURRENT_BIT = this._CURRENT_BIT << 1 | 0, this._CURRENT_GROUP++, this._GROUPS.set(t, i), i;
  }
  /**
   * Get all collision groups currently tracked by excalibur
   */
  static get groups() {
    return Array.from(this._GROUPS.values());
  }
  /**
   * Get a collision group by it's name
   * @param name
   */
  static groupByName(t) {
    return this._GROUPS.get(t);
  }
  /**
   * Resets the managers internal group management state
   */
  static reset() {
    this._GROUPS = /* @__PURE__ */ new Map(), this._CURRENT_BIT = this._STARTING_BIT, this._CURRENT_GROUP = 1;
  }
};
ue._STARTING_BIT = 1;
ue._MAX_GROUPS = 32;
ue._CURRENT_GROUP = 1;
ue._CURRENT_BIT = ue._STARTING_BIT;
ue._GROUPS = /* @__PURE__ */ new Map();
let Hi = ue;
const $i = class {
  /**
   * STOP!!** It is preferred that {@apilink CollisionGroupManager.create} is used to create collision groups
   *  unless you know how to construct the proper bitmasks. See https://github.com/excaliburjs/Excalibur/issues/1091 for more info.
   * @param name Name of the collision group
   * @param category 32 bit category for the group, should be a unique power of 2. For example `0b001` or `0b010`
   * @param mask 32 bit mask of category, or `~category` generally. For a category of `0b001`, the mask would be `0b110`
   */
  constructor(t, e, i) {
    this._name = t, this._category = e, this._mask = i;
  }
  /**
   * Get the name of the collision group
   */
  get name() {
    return this._name;
  }
  /**
   * Get the category of the collision group, a 32 bit number which should be a unique power of 2
   */
  get category() {
    return this._category;
  }
  /**
   * Get the mask for this collision group
   */
  get mask() {
    return this._mask;
  }
  /**
   * Evaluates whether 2 collision groups can collide
   *
   * This means the mask has the same bit set the other category and vice versa
   * @param other  CollisionGroup
   */
  canCollide(t) {
    const e = this.category & t.mask, i = this.mask & t.category;
    return e !== 0 && i !== 0;
  }
  /**
   * Inverts the collision group. For example, if before the group specified "players",
   * inverting would specify all groups except players
   * @returns CollisionGroup
   */
  invert() {
    const t = Hi.create("~(" + this.name + ")", ~this.mask | 0);
    return t._category = ~this.category, t;
  }
  /**
   * Combine collision groups with each other. The new group includes all of the previous groups.
   * @param collisionGroups
   */
  static combine(t) {
    const e = t.map((n) => n.name).join("+"), s = ~t.reduce((n, o) => o.category | n, 0);
    return Hi.create(e, s);
  }
  /**
   * Creates a collision group that collides with the listed groups
   * @param collisionGroups
   */
  static collidesWith(t) {
    const e = `collidesWith(${t.map((s) => s.name).join("+")})`, i = t.reduce((s, n) => n.category | s, 0);
    return Hi.create(e, i);
  }
  toString() {
    return `
category: ${this.category.toString(2).padStart(32, "0")}
mask:     ${(this.mask >>> 0).toString(2).padStart(32, "0")}
    `;
  }
};
$i.All = new $i("Collide with all groups", -1, -1);
let Ee = $i;
var mn = /* @__PURE__ */ ((r) => (r.Kill = "kill", r.PreKill = "prekill", r.PostKill = "postkill", r.PreDraw = "predraw", r.PostDraw = "postdraw", r.PreDebugDraw = "predebugdraw", r.PostDebugDraw = "postdebugdraw", r.PreUpdate = "preupdate", r.PostUpdate = "postupdate", r.PreFrame = "preframe", r.PostFrame = "postframe", r.PreCollision = "precollision", r.CollisionStart = "collisionstart", r.CollisionEnd = "collisionend", r.PostCollision = "postcollision", r.Initialize = "initialize", r.Activate = "activate", r.Deactivate = "deactivate", r.ExitViewport = "exitviewport", r.EnterViewport = "enterviewport", r.ExitTrigger = "exit", r.EnterTrigger = "enter", r.Connect = "connect", r.Disconnect = "disconnect", r.Button = "button", r.Axis = "axis", r.Visible = "visible", r.Hidden = "hidden", r.Start = "start", r.Stop = "stop", r.PointerUp = "pointerup", r.PointerDown = "pointerdown", r.PointerMove = "pointermove", r.PointerEnter = "pointerenter", r.PointerLeave = "pointerleave", r.PointerCancel = "pointercancel", r.PointerWheel = "pointerwheel", r.Up = "up", r.Down = "down", r.Move = "move", r.Enter = "enter", r.Leave = "leave", r.Cancel = "cancel", r.Wheel = "wheel", r.Press = "press", r.Release = "release", r.Hold = "hold", r.PointerDragStart = "pointerdragstart", r.PointerDragEnd = "pointerdragend", r.PointerDragEnter = "pointerdragenter", r.PointerDragLeave = "pointerdragleave", r.PointerDragMove = "pointerdragmove", r.ActionStart = "actionstart", r.ActionComplete = "actioncomplete", r.Add = "add", r.Remove = "remove", r))(mn || {});
class B {
  constructor() {
    this.other = null, this._bubbles = !0;
  }
  /**
   * If set to false, prevents event from propagating to other actors. If true it will be propagated
   * to all actors that apply.
   */
  get bubbles() {
    return this._bubbles;
  }
  set bubbles(t) {
    this._bubbles = t;
  }
  /**
   * Prevents event from bubbling
   */
  stopPropagation() {
    this.bubbles = !1;
  }
}
class xn extends B {
  constructor(t) {
    super(), this.self = t, this.target = t;
  }
}
class vn extends B {
  constructor(t) {
    super(), this.self = t, this.target = t;
  }
}
class wn extends B {
  constructor(t) {
    super(), this.self = t, this.target = t;
  }
}
class bn extends B {
  constructor(t) {
    super(), this.self = t, this.target = t;
  }
}
class yn extends B {
  constructor(t) {
    super(), this.self = t, this.target = t;
  }
}
class Qe extends B {
  constructor(t, e, i) {
    super(), this.ctx = t, this.elapsed = e, this.self = i, this.target = i;
  }
}
class Je extends B {
  constructor(t, e, i) {
    super(), this.ctx = t, this.elapsed = e, this.self = i, this.target = i;
  }
}
class Cn extends B {
  constructor(t, e, i) {
    super(), this.ctx = t, this.elapsed = e, this.self = i, this.target = i;
  }
}
class Tn extends B {
  constructor(t, e, i) {
    super(), this.ctx = t, this.elapsed = e, this.self = i, this.target = i;
  }
}
class Sn extends B {
  constructor(t, e) {
    super(), this.ctx = t, this.self = e, this.target = e;
  }
}
class An extends B {
  constructor(t, e) {
    super(), this.ctx = t, this.self = e, this.target = e;
  }
}
class pe extends B {
  constructor(t, e, i) {
    super(), this.engine = t, this.elapsed = e, this.self = i, this.target = i;
  }
}
class me extends B {
  constructor(t, e, i) {
    super(), this.engine = t, this.elapsed = e, this.self = i, this.target = i;
  }
}
class Pn extends B {
  constructor(t, e) {
    super(), this.engine = t, this.prevStats = e, this.target = t;
  }
}
class En extends B {
  constructor(t, e) {
    super(), this.engine = t, this.stats = e, this.target = t;
  }
}
class In extends B {
  constructor(t, e) {
    super(), this.index = t, this.gamepad = e, this.target = e;
  }
}
class Rn extends B {
  constructor(t, e) {
    super(), this.index = t, this.gamepad = e, this.target = e;
  }
}
class Mn extends B {
  /**
   * @param button  The Gamepad {@apilink Buttons} if not known by excalibur {@apilink Buttons.Unknown} is returned, use index to disambiguate.
   * @param index   The canonical index of the gamepad button from the system
   * @param value   A numeric value between 0 and 1
   * @param self    Reference to the gamepad
   */
  constructor(t, e, i, s) {
    super(), this.button = t, this.index = e, this.value = i, this.self = s, this.target = s;
  }
}
class Fn extends B {
  /**
   * @param axis  The Gamepad axis
   * @param value A numeric value between -1 and 1
   * @param self Reference to the gamepad
   */
  constructor(t, e, i) {
    super(), this.axis = t, this.value = e, this.self = i, this.target = i;
  }
}
class Dn extends B {
  constructor(t) {
    super(), this.self = t, this.target = t;
  }
}
class Bn extends B {
  constructor(t) {
    super(), this.self = t, this.target = t;
  }
}
class Ie extends B {
  /**
   * @param self          The actor the event was thrown on
   * @param other         The actor that will collided with the current actor
   * @param side          The side that will be collided with the current actor
   * @param intersection  Intersection vector
   */
  constructor(t, e, i, s, n) {
    super(), this.self = t, this.other = e, this.side = i, this.intersection = s, this.contact = n, this.target = t;
  }
}
class Re extends B {
  /**
   * @param self          The actor the event was thrown on
   * @param other         The actor that did collide with the current actor
   * @param side          The side that did collide with the current actor
   * @param intersection  Intersection vector
   */
  constructor(t, e, i, s, n) {
    super(), this.self = t, this.other = e, this.side = i, this.intersection = s, this.contact = n, this.target = t;
  }
}
class Yi {
  constructor(t, e, i, s) {
    this.self = t, this.other = e, this.side = i, this.contact = s;
  }
}
class Zi {
  constructor(t, e, i, s) {
    this.self = t, this.other = e, this.side = i, this.lastContact = s;
  }
}
class ji {
  constructor(t, e, i, s, n) {
    this.self = t, this.other = e, this.side = i, this.intersection = s, this.contact = n;
  }
}
class Qi {
  constructor(t, e, i, s, n) {
    this.self = t, this.other = e, this.side = i, this.intersection = s, this.contact = n;
  }
}
class pi extends B {
  /**
   *
   * @param self
   * @param other
   * @param side
   * @param contact
   */
  constructor(t, e, i, s) {
    super(), this.self = t, this.other = e, this.side = i, this.contact = s, this.target = t;
  }
}
class mi extends B {
  /**
   *
   */
  constructor(t, e, i, s) {
    super(), this.self = t, this.other = e, this.side = i, this.lastContact = s, this.target = t;
  }
}
class Ke extends B {
  /**
   * @param engine  The reference to the current engine
   */
  constructor(t, e) {
    super(), this.engine = t, this.self = e, this.target = e;
  }
}
class kn extends B {
  /**
   * @param context  The context for the scene activation
   */
  constructor(t, e) {
    super(), this.context = t, this.self = e, this.target = e;
  }
}
class Ln extends B {
  /**
   * @param context  The context for the scene deactivation
   */
  constructor(t, e) {
    super(), this.context = t, this.self = e, this.target = e;
  }
}
class Un extends B {
  constructor(t) {
    super(), this.self = t, this.target = t;
  }
}
class zn extends B {
  constructor(t) {
    super(), this.self = t, this.target = t;
  }
}
class Hn extends B {
  constructor(t, e) {
    super(), this.self = t, this.entity = e, this.target = t;
  }
}
class On extends B {
  constructor(t, e) {
    super(), this.self = t, this.entity = e, this.target = t;
  }
}
class Nn extends B {
  constructor(t, e) {
    super(), this.action = t, this.self = e, this.target = e;
  }
}
class Wn extends B {
  constructor(t, e) {
    super(), this.action = t, this.self = e, this.target = e;
  }
}
class Vn extends B {
  constructor(t, e) {
    super(), this.engine = t, this.self = e, this.target = e;
  }
}
class Gn extends B {
  constructor(t, e) {
    super(), this.engine = t, this.self = e, this.target = e;
  }
}
const Ml = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ActionCompleteEvent: Wn,
  ActionStartEvent: Nn,
  ActivateEvent: kn,
  AddEvent: Vn,
  CollisionEndEvent: mi,
  CollisionPostSolveEvent: Qi,
  CollisionPreSolveEvent: ji,
  CollisionStartEvent: pi,
  ContactEndEvent: Zi,
  ContactStartEvent: Yi,
  DeactivateEvent: Ln,
  EnterTriggerEvent: Hn,
  EnterViewPortEvent: zn,
  EventTypes: mn,
  ExitTriggerEvent: On,
  ExitViewPortEvent: Un,
  GameEvent: B,
  GameStartEvent: bn,
  GameStopEvent: yn,
  GamepadAxisEvent: Fn,
  GamepadButtonEvent: Mn,
  GamepadConnectEvent: In,
  GamepadDisconnectEvent: Rn,
  HiddenEvent: Bn,
  InitializeEvent: Ke,
  KillEvent: xn,
  PostCollisionEvent: Re,
  PostDebugDrawEvent: An,
  PostDrawEvent: Je,
  PostFrameEvent: En,
  PostKillEvent: wn,
  PostTransformDrawEvent: Tn,
  PostUpdateEvent: me,
  PreCollisionEvent: Ie,
  PreDebugDrawEvent: Sn,
  PreDrawEvent: Qe,
  PreFrameEvent: Pn,
  PreKillEvent: vn,
  PreTransformDrawEvent: Cn,
  PreUpdateEvent: pe,
  RemoveEvent: Gn,
  VisibleEvent: Dn
}, Symbol.toStringTag, { value: "Module" }));
function qn(r) {
  if (r.length === 0)
    throw new Error("Cannot find minIndex of array.length == 0");
  let t = r[0], e = 0;
  for (let i = 1; i < r.length; i++)
    r[i] < t && (t = r[i], e = i);
  return e;
}
function ze(r) {
  if (r && r.getBoundingClientRect) {
    const t = r.getBoundingClientRect();
    return w(t.x + window.scrollX, t.y + window.scrollY);
  }
  return v.Zero;
}
function go(r, t) {
  return t.indexOf(r) === -1 ? (t.push(r), !0) : !1;
}
function ke(r, t) {
  let e = -1;
  return (e = t.indexOf(r)) > -1 ? (t.splice(e, 1), !0) : !1;
}
function Xn(r, t) {
  for (let e = 0; e < r.length; e++)
    if (r[e] === t)
      return !0;
  return !1;
}
function $n(r) {
  throw new Error(r);
}
function xi(r, t) {
  var e;
  const i = new yt();
  return ((e = t == null ? void 0 : t.schedule.bind(t)) != null ? e : setTimeout)(() => {
    i.resolve();
  }, r), i.promise;
}
function Yn(r, t) {
  const e = {};
  for (const i in r)
    t.includes(i) || (e[i] = r[i]);
  return e;
}
function ci(r) {
  return r && typeof r == "object" && !Array.isArray(r);
}
function vi(r, ...t) {
  if (!t.length)
    return r;
  const e = t.shift();
  if (ci(r) && ci(e))
    for (const i in e)
      ci(e[i]) ? (r[i] || Object.assign(r, { [i]: {} }), vi(r[i], e[i])) : Object.assign(r, { [i]: e[i] });
  return vi(r, ...t);
}
class Fl {
  constructor(t) {
    this.data = t, this.type = "Component Added";
  }
}
function Dl(r) {
  return !!r && r.type === "Component Added";
}
class Bl {
  constructor(t) {
    this.data = t, this.type = "Component Removed";
  }
}
function kl(r) {
  return !!r && r.type === "Component Removed";
}
const Ll = {
  Add: "add",
  Remove: "remove",
  Initialize: "initialize",
  PreUpdate: "preupdate",
  PostUpdate: "postupdate",
  Kill: "kill"
}, Zn = class Ji {
  constructor(t, e) {
    this.id = Ji._ID++, this.name = `Entity#${this.id}`, this.events = new X(), this._tags = /* @__PURE__ */ new Set(), this.componentAdded$ = new mt(), this.componentRemoved$ = new mt(), this.tagAdded$ = new mt(), this.tagRemoved$ = new mt(), this.components = /* @__PURE__ */ new Map(), this.componentValues = [], this._componentsToRemove = [], this.scene = null, this.isActive = !0, this._parent = null, this.childrenAdded$ = new mt(), this.childrenRemoved$ = new mt(), this._children = [], this._isInitialized = !1, this._isAdded = !1;
    let i, s;
    if (Array.isArray(t))
      i = t, s = e;
    else if (t && typeof t == "object") {
      const { components: n, name: o } = t;
      i = n != null ? n : [], s = o;
    }
    if (s && (this.name = s), i)
      for (const n of i)
        this.addComponent(n);
  }
  /**
   * Whether this entity is active, if set to false it will be reclaimed
   * @deprecated use isActive
   */
  get active() {
    return this.isActive;
  }
  /**
   * Whether this entity is active, if set to false it will be reclaimed
   * @deprecated use isActive
   */
  set active(t) {
    this.isActive = t;
  }
  /**
   * Kill the entity, means it will no longer be updated. Kills are deferred to the end of the update.
   * If parented it will be removed from the parent when killed.
   */
  kill() {
    this.isActive && (this.isActive = !1, this.unparent()), this.emit("kill", new xn(this));
  }
  isKilled() {
    return !this.isActive;
  }
  /**
   * Specifically get the tags on the entity from {@apilink TagsComponent}
   */
  get tags() {
    return this._tags;
  }
  /**
   * Check if a tag exists on the entity
   * @param tag name to check for
   */
  hasTag(t) {
    return this._tags.has(t);
  }
  /**
   * Adds a tag to an entity
   * @param tag
   */
  addTag(t) {
    return this._tags.add(t), this.tagAdded$.notifyAll(t), this;
  }
  /**
   * Removes a tag on the entity
   *
   * Removals are deferred until the end of update
   * @param tag
   */
  removeTag(t) {
    return this._tags.delete(t), this.tagRemoved$.notifyAll(t), this;
  }
  /**
   * The types of the components on the Entity
   */
  get types() {
    return Array.from(this.components.keys());
  }
  /**
   * Returns all component instances on entity
   */
  getComponents() {
    return Array.from(this.components.values());
  }
  /**
   * Verifies that an entity has all the required types
   * @param requiredTypes
   */
  hasAll(t) {
    for (let e = 0; e < t.length; e++)
      if (!this.components.has(t[e]))
        return !1;
    return !0;
  }
  /**
   * Verifies that an entity has all the required tags
   * @param requiredTags
   */
  hasAllTags(t) {
    for (let e = 0; e < t.length; e++)
      if (!this.tags.has(t[e]))
        return !1;
    return !0;
  }
  get(t) {
    return this.components.get(t);
  }
  get parent() {
    return this._parent;
  }
  /**
   * Get the direct children of this entity
   */
  get children() {
    return this._children;
  }
  /**
   * Unparents this entity, if there is a parent. Otherwise it does nothing.
   */
  unparent() {
    this._parent && (this._parent.removeChild(this), this._parent = null);
  }
  /**
   * Check if a child entity exists on the parent entity
   * @param child entity to check for
   * @param recursive whether to check recursively
   */
  hasChild(t, e = !1) {
    if (!e)
      return t.parent === this;
    for (const i of this.children)
      if (i === t || e && i.hasChild(t, !0))
        return !0;
    return !1;
  }
  /**
   * Adds an entity to be a child of this entity
   * @param entity
   */
  addChild(t) {
    if (t.parent === null) {
      if (this.getAncestors().includes(t))
        throw new Error("Cycle detected, cannot add entity");
      this._children.push(t), t._parent = this, this.childrenAdded$.notifyAll(t);
    } else
      throw new Error("Entity already has a parent, cannot add without unparenting");
    return this;
  }
  /**
   * Remove an entity from children if it exists
   * @param entity
   */
  removeChild(t) {
    return t.parent === this && (ke(t, this._children), t._parent = null, this.childrenRemoved$.notifyAll(t)), this;
  }
  /**
   * Removes all children from this entity
   */
  removeAllChildren() {
    for (let t = this.children.length - 1; t >= 0; t--)
      this.removeChild(this.children[t]);
    return this;
  }
  /**
   * Returns a list of parent entities starting with the topmost parent. Includes the current entity.
   */
  getAncestors() {
    const t = [this];
    let e = this.parent;
    for (; e; )
      t.push(e), e = e.parent;
    return t.reverse();
  }
  /**
   * Returns a list of all the entities that descend from this entity. Includes the current entity.
   */
  getDescendants() {
    let t = [this], e = [this];
    for (; e.length > 0; ) {
      const i = e.pop();
      i && (e = e.concat(i.children), t = t.concat(i.children));
    }
    return t;
  }
  /**
   * Creates a deep copy of the entity and a copy of all its components
   */
  clone() {
    const t = new Ji();
    for (const e of this.types) {
      const i = this.get(e);
      i && t.addComponent(i.clone());
    }
    for (const e of this.children)
      t.addChild(e.clone());
    return t;
  }
  /**
   * Adds a copy of all the components from another template entity as a "prefab"
   * @param templateEntity Entity to use as a template
   * @param force Force component replacement if it already exists on the target entity
   */
  addTemplate(t, e = !1) {
    for (const i of t.getComponents())
      this.addComponent(i.clone(), e);
    for (const i of t.children)
      this.addChild(i.clone().addTemplate(i));
    return this;
  }
  _getClassHierarchyRoot(t) {
    var e, i;
    let s = t, n = (e = Object.getPrototypeOf(s.prototype)) == null ? void 0 : e.constructor;
    for (; n && n !== Object && n !== kt; )
      s = n, n = (i = Object.getPrototypeOf(s.prototype)) == null ? void 0 : i.constructor;
    return s;
  }
  /**
   * Adds a component to the entity
   * @param component Component or Entity to add copy of components from
   * @param force Optionally overwrite any existing components of the same type
   */
  addComponent(t, e = !1) {
    if (this.has(t.constructor))
      if (e)
        this.removeComponent(t.constructor, !0);
      else
        return this;
    if (t.dependencies && t.dependencies.length)
      for (const s of t.dependencies)
        this.addComponent(new s());
    t.owner = this;
    const i = this._getClassHierarchyRoot(t.constructor);
    return this.components.set(i, t), this.components.set(t.constructor, t), this.componentValues.push(t), t.onAdd && t.onAdd(this), this.componentAdded$.notifyAll(t), this;
  }
  /**
   * Removes a component from the entity, by default removals are deferred to the end of entity update to avoid consistency issues
   *
   * Components can be force removed with the `force` flag, the removal is not deferred and happens immediately
   * @param typeOrInstance
   * @param force
   */
  removeComponent(t, e = !1) {
    let i;
    if (_o(t) ? i = t : i = t.constructor, e) {
      const s = this.components.get(i);
      if (s) {
        this.componentRemoved$.notifyAll(s), s.owner = void 0, s.onRemove && s.onRemove(this);
        const o = this.componentValues.indexOf(s);
        o > -1 && this.componentValues.splice(o, 1);
      }
      const n = this._getClassHierarchyRoot(i);
      this.components.delete(n), this.components.delete(i);
    } else
      this._componentsToRemove.push(i);
    return this;
  }
  clearComponents() {
    const t = this.types;
    for (const e of t)
      this.removeComponent(e);
  }
  /**
   * @hidden
   * @internal
   */
  processComponentRemoval() {
    for (const t of this._componentsToRemove)
      this.removeComponent(t, !0);
    this._componentsToRemove.length = 0;
  }
  /**
   * Check if a component type exists
   * @param type
   */
  has(t) {
    return this.components.has(t);
  }
  /**
   * Gets whether the actor is Initialized
   */
  get isInitialized() {
    return this._isInitialized;
  }
  get isAdded() {
    return this._isAdded;
  }
  /**
   * Initializes this entity, meant to be called by the Scene before first update not by users of Excalibur.
   *
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   * @internal
   */
  _initialize(t) {
    this.isInitialized || (this.onInitialize(t), this.events.emit("initialize", new Ke(t, this)), this._isInitialized = !0);
  }
  /**
   * Adds this Actor, meant to be called by the Scene when Actor is added.
   *
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   * @internal
   */
  _add(t) {
    !this.isAdded && this.isActive && (this.onAdd(t), this.events.emit("add", new Vn(t, this)), this._isAdded = !0);
  }
  /**
   * Removes Actor, meant to be called by the Scene when Actor is removed.
   *
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   * @internal
   */
  _remove(t) {
    this.isAdded && !this.isActive && (this.onRemove(t), this.events.emit("remove", new Gn(t, this)), this._isAdded = !1);
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _preupdate handler for {@apilink onPreUpdate} lifecycle event
   * @internal
   */
  _preupdate(t, e) {
    this.events.emit("preupdate", new pe(t, e, this)), this.onPreUpdate(t, e);
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _preupdate handler for {@apilink onPostUpdate} lifecycle event
   * @internal
   */
  _postupdate(t, e) {
    this.events.emit("postupdate", new me(t, e, this)), this.onPostUpdate(t, e);
  }
  /**
   * `onInitialize` is called before the first update of the entity. This method is meant to be
   * overridden.
   *
   * Synonymous with the event handler `.on('initialize', (evt) => {...})`
   */
  onInitialize(t) {
  }
  /**
   * `onAdd` is called when Actor is added to scene. This method is meant to be
   * overridden.
   *
   * Synonymous with the event handler `.on('add', (evt) => {...})`
   */
  onAdd(t) {
  }
  /**
   * `onRemove` is called when Actor is removed from a scene. This method is meant to be
   * overridden.
   *
   * Synonymous with the event handler `.on('remove', (evt) => {...})`
   */
  onRemove(t) {
  }
  /**
   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
   *
   * `onPreUpdate` is called directly before an entity is updated.
   */
  onPreUpdate(t, e) {
  }
  /**
   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`
   *
   * `onPostUpdate` is called directly after an entity is updated.
   */
  onPostUpdate(t, e) {
  }
  /**
   *
   * Entity update lifecycle, called internally
   * @internal
   * @param engine
   * @param elapsed
   */
  update(t, e) {
    this._initialize(t), this._add(t), this._preupdate(t, e);
    for (const i of this.children)
      i.update(t, e);
    this._postupdate(t, e), this._remove(t);
  }
  emit(t, e) {
    this.events.emit(t, e);
  }
  on(t, e) {
    return this.events.on(t, e);
  }
  once(t, e) {
    return this.events.once(t, e);
  }
  off(t, e) {
    e ? this.events.off(t, e) : this.events.off(t);
  }
};
Zn._ID = 0;
let Rt = Zn;
class po {
  constructor(t) {
    this._world = t, this.entities = [], this._entityIndex = {}, this._childAddedHandlerMap = /* @__PURE__ */ new Map(), this._childRemovedHandlerMap = /* @__PURE__ */ new Map(), this._createChildAddedHandler = () => (e) => {
      this.addEntity(e);
    }, this._createChildRemovedHandler = () => (e) => {
      this.removeEntity(e, !1);
    }, this._entitiesToRemove = [];
  }
  /**
   * Runs the entity lifecycle
   * @param scene
   * @param elapsed
   */
  updateEntities(t, e) {
    for (let i = 0; i < this.entities.length; i++) {
      const s = this.entities[i];
      s.update(t.engine, e), s.isActive || this.removeEntity(s);
    }
  }
  findEntitiesForRemoval() {
    for (let t = 0; t < this.entities.length; t++) {
      const e = this.entities[t];
      e.isActive || this.removeEntity(e);
    }
  }
  /**
   * Adds an entity to be tracked by the EntityManager
   * @param entity
   */
  addEntity(t) {
    if (t.isActive = !0, t.scene = this._world.scene, t && !this._entityIndex[t.id]) {
      this._entityIndex[t.id] = t, this.entities.push(t), this._world.queryManager.addEntity(t), t.children.forEach((s) => {
        s.scene = t.scene, this.addEntity(s);
      });
      const e = this._createChildAddedHandler();
      this._childAddedHandlerMap.set(t, e);
      const i = this._createChildRemovedHandler();
      this._childRemovedHandlerMap.set(t, i), t.childrenAdded$.subscribe(e), t.childrenRemoved$.subscribe(i);
    }
  }
  removeEntity(t, e = !0) {
    var i, s, n, o;
    let a = 0;
    t instanceof Rt ? a = t.id : a = t;
    const h = this._entityIndex[a];
    if (h && h.isActive && (h.isActive = !1), h && e) {
      this._entitiesToRemove.push(h);
      return;
    }
    if (delete this._entityIndex[a], h) {
      h.scene = null, ke(h, this.entities), this._world.queryManager.removeEntity(h), h.children.forEach((d) => {
        d.scene = null, this.removeEntity(d, e);
      });
      const l = this._childAddedHandlerMap.get(h);
      l && (h.childrenAdded$.unsubscribe(l), this._childAddedHandlerMap.delete(h));
      const c = this._childRemovedHandlerMap.get(h);
      c && (h.childrenRemoved$.unsubscribe(c), this._childRemovedHandlerMap.delete(h)), h._remove((s = (i = this._world) == null ? void 0 : i.scene) == null ? void 0 : s.engine), (o = (n = this._world) == null ? void 0 : n.scene) != null && o.engine && this._world.scene.engine.stats.currFrame.actors.killed++;
    }
  }
  processEntityRemovals() {
    for (let t = 0; t < this._entitiesToRemove.length; t++) {
      const e = this._entitiesToRemove[t];
      e.isActive || this.removeEntity(e, !1);
    }
    this._entitiesToRemove.length = 0;
  }
  processComponentRemovals() {
    for (let t = 0; t < this.entities.length; t++)
      this.entities[t].processComponentRemoval();
  }
  getById(t) {
    return this._entityIndex[t];
  }
  getByName(t) {
    return this.entities.filter((e) => e.name === t);
  }
  clear() {
    for (let t = this.entities.length - 1; t >= 0; t--)
      this.removeEntity(this.entities[t]);
  }
}
class zt {
  constructor(t) {
    this._entities = [], this.entitiesSet = /* @__PURE__ */ new Set(), this.entityAdded$ = new mt(), this.entityRemoved$ = new mt(), this.filter = {
      components: {
        all: /* @__PURE__ */ new Set(),
        any: /* @__PURE__ */ new Set(),
        not: /* @__PURE__ */ new Set()
      },
      tags: {
        all: /* @__PURE__ */ new Set(),
        any: /* @__PURE__ */ new Set(),
        not: /* @__PURE__ */ new Set()
      }
    }, this._dirty = !1;
    var e, i, s, n, o, a, h, l, c, d, u, _;
    Array.isArray(t) && (t = { components: { all: t } }), this.filter.components.all = new Set((i = (e = t.components) == null ? void 0 : e.all) != null ? i : []), this.filter.components.any = new Set((n = (s = t.components) == null ? void 0 : s.any) != null ? n : []), this.filter.components.not = new Set((a = (o = t.components) == null ? void 0 : o.not) != null ? a : []), this.filter.tags.all = new Set((l = (h = t.tags) == null ? void 0 : h.all) != null ? l : []), this.filter.tags.any = new Set((d = (c = t.tags) == null ? void 0 : c.any) != null ? d : []), this.filter.tags.not = new Set((_ = (u = t.tags) == null ? void 0 : u.not) != null ? _ : []), this.id = zt.createId(t);
  }
  get entities() {
    return this._dirty && (this._entities = Array.from(this.entitiesSet), this._dirty = !1), this._entities;
  }
  static createId(t) {
    var e, i, s, n, o, a, h, l, c, d, u, _;
    Array.isArray(t) && (t = { components: { all: t } });
    const p = (e = t.components) != null && e.any ? `any_${zt.hashComponents(new Set((i = t.components) == null ? void 0 : i.any))}` : "", g = (s = t.components) != null && s.all ? `all_${zt.hashComponents(new Set((n = t.components) == null ? void 0 : n.all))}` : "", x = (o = t.components) != null && o.not ? `not_${zt.hashComponents(new Set((a = t.components) == null ? void 0 : a.not))}` : "", m = (h = t.tags) != null && h.any ? `any_${zt.hashTags(new Set((l = t.tags) == null ? void 0 : l.any))}` : "", f = (c = t.tags) != null && c.all ? `all_${zt.hashTags(new Set((d = t.tags) == null ? void 0 : d.all))}` : "", b = (u = t.tags) != null && u.not ? `not_${zt.hashTags(new Set((_ = t.tags) == null ? void 0 : _.not))}` : "";
    return [p, g, x, m, f, b].filter(Boolean).join("-");
  }
  static hashTags(t) {
    return Array.from(t).map((e) => `t_${e}`).sort().join("-");
  }
  static hashComponents(t) {
    return Array.from(t).map((e) => `c_${e.name}`).sort().join("-");
  }
  matchesNotFilter(t, e) {
    for (const i of this.filter.components.not)
      if (e !== i && t.has(i))
        return !0;
    for (const i of this.filter.tags.not)
      if (t.hasTag(i))
        return !0;
    return !1;
  }
  matches(t, e) {
    for (const i of this.filter.components.not)
      if (e !== i && t.has(i))
        return !1;
    for (const i of this.filter.tags.not)
      if (t.hasTag(i))
        return !1;
    for (const i of this.filter.components.all)
      if (i === e || !t.has(i))
        return !1;
    for (const i of this.filter.tags.all)
      if (!t.hasTag(i))
        return !1;
    if (this.filter.components.any.size > 0) {
      let i = !1;
      for (const s of this.filter.components.any)
        if (t.has(s)) {
          i = !0;
          break;
        }
      if (!i)
        return !1;
    }
    if (this.filter.tags.any.size > 0) {
      let i = !1;
      for (const s of this.filter.tags.any)
        if (t.hasTag(s)) {
          i = !0;
          break;
        }
      if (!i)
        return !1;
    }
    return !0;
  }
  /**
   * Potentially adds or removes an entity from a query index, returns true if added, false if not added or was removed.
   * @param entity
   * @param [optional] removedComponent that should be treated as removed from the entity
   */
  checkAndModify(t, e) {
    const i = this.entitiesSet.has(t);
    if (i && this.matchesNotFilter(t, e))
      return this.removeEntity(t), !1;
    const s = this.matches(t, e);
    return i && !s ? (this.removeEntity(t), !1) : !i && s ? (this._dirty = !0, this.entitiesSet.add(t), this.entityAdded$.notifyAll(t), !0) : !1;
  }
  removeEntity(t) {
    this.entitiesSet.delete(t) && (this._dirty = !0, this.entityRemoved$.notifyAll(t));
  }
  /**
   * Returns a list of entities that match the query
   * @param sort Optional sorting function to sort entities returned from the query
   */
  getEntities(t) {
    return t && this.entities.sort(t), this.entities;
  }
}
class jn {
  constructor(t) {
    if (this.requiredTags = t, this.tags = /* @__PURE__ */ new Set(), this.entities = [], this.entityAdded$ = new mt(), this.entityRemoved$ = new mt(), t.length === 0)
      throw new Error("Cannot create tag query without tags");
    for (const e of t)
      this.tags.add(e);
    this.id = jn.createId(t);
  }
  static createId(t) {
    return t.slice().sort().join("-");
  }
  checkAndAdd(t) {
    return !this.entities.includes(t) && t.hasAllTags(Array.from(this.tags)) ? (this.entities.push(t), this.entityAdded$.notifyAll(t), !0) : !1;
  }
  removeEntity(t) {
    const e = this.entities.indexOf(t);
    e > -1 && (this.entities.splice(e, 1), this.entityRemoved$.notifyAll(t));
  }
  /**
   * Returns a list of entities that match the query
   * @param sort Optional sorting function to sort entities returned from the query
   */
  getEntities(t) {
    return t && this.entities.sort(t), this.entities;
  }
}
class mo {
  constructor(t) {
    this._world = t, this._queries = /* @__PURE__ */ new Map(), this._addComponentHandlers = /* @__PURE__ */ new Map(), this._removeComponentHandlers = /* @__PURE__ */ new Map(), this._componentToQueriesIndex = /* @__PURE__ */ new Map(), this._tagToQueriesIndex = /* @__PURE__ */ new Map(), this._addTagHandlers = /* @__PURE__ */ new Map(), this._removeTagHandlers = /* @__PURE__ */ new Map(), this._createAddComponentHandler = (e) => (i) => {
      this.addComponent(e, i);
    }, this._createRemoveComponentHandler = (e) => (i) => {
      this.removeComponent(e, i);
    }, this._createAddTagHandler = (e) => (i) => {
      this.addTag(e, i);
    }, this._createRemoveTagHandler = (e) => (i) => {
      this.removeTag(e, i);
    };
  }
  createQuery(t) {
    const e = zt.createId(t);
    if (this._queries.has(e))
      return this._queries.get(e);
    const i = new zt(t);
    this._queries.set(i.id, i);
    for (const s of [...i.filter.components.all, ...i.filter.components.any, ...i.filter.components.not]) {
      const n = this._componentToQueriesIndex.get(s);
      n ? n.push(i) : this._componentToQueriesIndex.set(s, [i]);
    }
    for (const s of [...i.filter.tags.all, ...i.filter.tags.any, ...i.filter.tags.not]) {
      const n = this._tagToQueriesIndex.get(s);
      n ? n.push(i) : this._tagToQueriesIndex.set(s, [i]);
    }
    for (const s of this._world.entities)
      this.addEntity(s);
    return i;
  }
  /**
   * Scans queries and locates any that need this entity added
   * @param entity
   */
  addEntity(t) {
    const e = this._addComponentHandlers.get(t), i = this._removeComponentHandlers.get(t), s = e != null ? e : this._createAddComponentHandler(t), n = i != null ? i : this._createRemoveComponentHandler(t);
    this._addComponentHandlers.set(t, s), this._removeComponentHandlers.set(t, n);
    const o = this._addTagHandlers.get(t), a = this._removeTagHandlers.get(t), h = o != null ? o : this._createAddTagHandler(t), l = a != null ? a : this._createRemoveTagHandler(t);
    this._addTagHandlers.set(t, h), this._removeTagHandlers.set(t, l);
    for (const c of this._queries.values())
      c.checkAndModify(t);
    t.componentAdded$.subscribe(s), t.componentRemoved$.subscribe(n), t.tagAdded$.subscribe(h), t.tagRemoved$.subscribe(l);
  }
  /**
   * Scans queries and locates any that need this entity removed
   * @param entity
   */
  removeEntity(t) {
    const e = this._addComponentHandlers.get(t), i = this._removeComponentHandlers.get(t);
    for (const o of this._queries.values())
      o.removeEntity(t);
    e && (t.componentAdded$.unsubscribe(e), this._addComponentHandlers.delete(t)), i && (t.componentRemoved$.unsubscribe(i), this._removeComponentHandlers.delete(t));
    const s = this._addTagHandlers.get(t), n = this._removeTagHandlers.get(t);
    s && (t.tagAdded$.unsubscribe(s), this._addTagHandlers.delete(t)), n && (t.tagRemoved$.unsubscribe(n), this._removeTagHandlers.delete(t));
  }
  /**
   * Updates any queries when a component is added to an entity
   * @param entity
   * @param component
   */
  addComponent(t, e) {
    var i;
    const s = (i = this._componentToQueriesIndex.get(e.constructor)) != null ? i : [];
    for (const n of s)
      n.checkAndModify(t);
  }
  /**
   * Updates any queries when a component is removed from an entity
   * @param entity
   * @param component
   */
  removeComponent(t, e) {
    var i;
    const s = (i = this._componentToQueriesIndex.get(e.constructor)) != null ? i : [];
    for (const n of s)
      n.checkAndModify(t, e.constructor);
  }
  /**
   * Updates any queries when a tag is added to an entity
   * @param entity
   * @param tag
   */
  addTag(t, e) {
    var i;
    const s = (i = this._tagToQueriesIndex.get(e)) != null ? i : [];
    for (const n of s)
      n.checkAndModify(t);
  }
  /**
   * Updates any queries when a component is removed from an entity
   * @param entity
   * @param tag
   */
  removeTag(t, e) {
    var i;
    const s = (i = this._tagToQueriesIndex.get(e)) != null ? i : [];
    for (const n of s)
      n.removeEntity(t), n.checkAndModify(t);
  }
}
const Kt = {
  Highest: -1 / 0,
  Higher: -5,
  Average: 0,
  Lower: 5,
  Lowest: 1 / 0
};
var Mt = /* @__PURE__ */ ((r) => (r.Update = "update", r.Draw = "draw", r))(Mt || {});
class Ft {
}
Ft.priority = Kt.Average;
function xo(r) {
  var t, e;
  return !!(r != null && r.prototype) && !!((e = (t = r == null ? void 0 : r.prototype) == null ? void 0 : t.constructor) != null && e.name);
}
class vo {
  constructor(t) {
    this._world = t, this.systems = [], this.initialized = !1;
  }
  /**
   * Get a system registered in the manager by type
   * @param systemType
   */
  get(t) {
    return this.systems.find((e) => e instanceof t);
  }
  /**
   * Adds a system to the manager, it will now be updated every frame
   * @param systemOrCtor
   */
  addSystem(t) {
    let e;
    t instanceof Ft ? e = t : e = new t(this._world), this.systems.push(e), this.systems.sort((i, s) => i.constructor.priority - s.constructor.priority), this.initialized && e.initialize && e.initialize(this._world, this._world.scene);
  }
  /**
   * Removes a system from the manager, it will no longer be updated
   * @param system
   */
  removeSystem(t) {
    ke(t, this.systems);
  }
  /**
   * Initialize all systems in the manager
   *
   * Systems added after initialize() will be initialized on add
   */
  initialize() {
    if (!this.initialized) {
      this.initialized = !0;
      for (const t of this.systems)
        t.initialize && t.initialize(this._world, this._world.scene);
    }
  }
  /**
   * Updates all systems
   * @param type whether this is an update or draw system
   * @param scene context reference
   * @param elapsed time in milliseconds
   */
  updateSystems(t, e, i) {
    var s, n, o;
    const a = this.systems.filter((u) => u.systemType === t), h = (o = (n = (s = e == null ? void 0 : e.engine) == null ? void 0 : s.stats) == null ? void 0 : n.currFrame) != null ? o : { systemDuration: {} };
    let l, c;
    const d = a.length;
    for (let u = 0; u < d; u++)
      a[u].preupdate && (l = performance.now(), a[u].preupdate(e, i), c = performance.now(), h.systemDuration[`${t}:${a[u].constructor.name}.preupdate`] = c - l);
    for (let u = 0; u < d; u++)
      l = performance.now(), a[u].update(i), c = performance.now(), h.systemDuration[`${t}:${a[u].constructor.name}.update`] = c - l;
    for (let u = 0; u < d; u++)
      a[u].postupdate && (l = performance.now(), a[u].postupdate(e, i), c = performance.now(), h.systemDuration[`${t}:${a[u].constructor.name}.postupdate`] = c - l);
  }
  clear() {
    for (let t = this.systems.length - 1; t >= 0; t--)
      this.removeSystem(this.systems[t]);
  }
}
class wo {
  /**
   * The context type is passed to the system updates
   * @param scene
   */
  constructor(t) {
    this.scene = t, this._logger = R.getInstance(), this.queryManager = new mo(this), this.entityManager = new po(this), this.systemManager = new vo(this);
  }
  /**
   * Query the ECS world for entities that match your components
   */
  query(t) {
    return this.queryManager.createQuery(t);
  }
  /**
   * @deprecated
   */
  queryTags(t) {
    return this.queryManager.createQuery({ tags: { all: t } });
  }
  /**
   * Update systems by type and time elapsed in milliseconds
   */
  update(t, e) {
    t === Mt.Update && this.entityManager.updateEntities(this.scene, e), this.systemManager.updateSystems(t, this.scene, e), this.entityManager.findEntitiesForRemoval(), this.entityManager.processComponentRemovals(), this.entityManager.processEntityRemovals();
  }
  add(t) {
    if (t instanceof Rt) {
      this.entityManager.addEntity(t);
      return;
    }
    if (t instanceof Ft || xo(t)) {
      this.systemManager.addSystem(t);
      return;
    }
    this._logger.warn(
      `Could not add entity/system ${t.constructor.name} to Excalibur!

If this looks like an Excalibur type, this can be caused by 2 versions of excalibur being included on the page.

Check your bundler settings to make sure this is not the case! Excalibur has ESM & UMD bundles be sure one 1 is loaded.`
    );
  }
  /**
   * Get a system out of the ECS world
   */
  get(t) {
    return this.systemManager.get(t);
  }
  remove(t, e = !0) {
    if (t instanceof Rt) {
      this.entityManager.removeEntity(t, e);
      return;
    }
    if (t instanceof Ft) {
      this.systemManager.removeSystem(t);
      return;
    }
    this._logger.warn(
      `Could not remove entity/system ${t.constructor.name} to Excalibur!

If this looks like an Excalibur type, this can be caused by 2 versions of excalibur being included on the page.

Check your bundler settings to make sure this is not the case! Excalibur has ESM & UMD bundles be sure one 1 is loaded.`
    );
  }
  get entities() {
    return this.entityManager.entities;
  }
  clearEntities() {
    this.entityManager.clear();
  }
  clearSystems() {
    this.systemManager.clear();
  }
}
var G = /* @__PURE__ */ ((r) => (r.None = "None", r.Top = "Top", r.Bottom = "Bottom", r.Left = "Left", r.Right = "Right", r))(G || {});
((r) => {
  function t(i) {
    return i === "Top" ? "Bottom" : i === "Bottom" ? "Top" : i === "Left" ? "Right" : i === "Right" ? "Left" : "None";
  }
  r.getOpposite = t;
  function e(i) {
    return Math.abs(i.x) >= Math.abs(i.y) ? i.x <= 0 ? "Left" : "Right" : i.y <= 0 ? "Top" : "Bottom";
  }
  r.fromDirection = e;
})(G || (G = {}));
const Qn = class dt {
  /**
   * Constructor allows passing of either an object with all coordinate components,
   * or the coordinate components passed separately.
   * @param leftOrOptions    Either x coordinate of the left edge or an options object
   * containing the four coordinate components.
   * @param top     y coordinate of the top edge
   * @param right   x coordinate of the right edge
   * @param bottom  y coordinate of the bottom edge
   */
  constructor(t = 0, e = 0, i = 0, s = 0) {
    this._points = [], typeof t == "object" ? (this.left = t.left, this.top = t.top, this.right = t.right, this.bottom = t.bottom) : typeof t == "number" && (this.left = t, this.top = e, this.right = i, this.bottom = s);
  }
  /**
   * Returns a new instance of {@apilink BoundingBox} that is a copy of the current instance
   */
  clone(t) {
    const e = t || new dt(0, 0, 0, 0);
    return e.left = this.left, e.right = this.right, e.top = this.top, e.bottom = this.bottom, e;
  }
  /**
   * Resets the bounds to a zero width/height box
   */
  reset() {
    this.left = 0, this.top = 0, this.bottom = 0, this.right = 0;
  }
  /**
   * Given bounding box A & B, returns the side relative to A when intersection is performed.
   * @param intersection Intersection vector between 2 bounding boxes
   */
  static getSideFromIntersection(t) {
    return t && t ? Math.abs(t.x) > Math.abs(t.y) ? t.x < 0 ? G.Right : G.Left : t.y < 0 ? G.Bottom : G.Top : G.None;
  }
  static fromPoints(t) {
    let e = 1 / 0, i = 1 / 0, s = -1 / 0, n = -1 / 0;
    for (let o = 0; o < t.length; o++)
      t[o].x < e && (e = t[o].x), t[o].x > s && (s = t[o].x), t[o].y < i && (i = t[o].y), t[o].y > n && (n = t[o].y);
    return new dt(e, i, s, n);
  }
  /**
   * Creates a bounding box from a width and height
   * @param width
   * @param height
   * @param anchor Default Vector.Half
   * @param pos Default Vector.Zero
   */
  static fromDimension(t, e, i = v.Half, s = v.Zero) {
    return new dt(
      -t * i.x + s.x,
      -e * i.y + s.y,
      t - t * i.x + s.x,
      e - e * i.y + s.y
    );
  }
  /**
   * Returns the calculated width of the bounding box
   */
  get width() {
    return this.right - this.left;
  }
  /**
   * Returns the calculated height of the bounding box
   */
  get height() {
    return this.bottom - this.top;
  }
  /**
   * Return whether the bounding box has zero dimensions in height,width or both
   */
  hasZeroDimensions() {
    return this.width === 0 || this.height === 0;
  }
  /**
   * Returns the center of the bounding box
   */
  get center() {
    return new v((this.left + this.right) / 2, (this.top + this.bottom) / 2);
  }
  get topLeft() {
    return new v(this.left, this.top);
  }
  get bottomRight() {
    return new v(this.right, this.bottom);
  }
  get topRight() {
    return new v(this.right, this.top);
  }
  get bottomLeft() {
    return new v(this.left, this.bottom);
  }
  translate(t) {
    return new dt(this.left + t.x, this.top + t.y, this.right + t.x, this.bottom + t.y);
  }
  /**
   * Rotates a bounding box by and angle and around a point, if no point is specified (0, 0) is used by default. The resulting bounding
   * box is also axis-align. This is useful when a new axis-aligned bounding box is needed for rotated geometry.
   */
  rotate(t, e = v.Zero) {
    const i = this.getPoints().map((s) => s.rotate(t, e));
    return dt.fromPoints(i);
  }
  /**
   * Scale a bounding box by a scale factor, optionally provide a point
   * @param scale
   * @param point
   */
  scale(t, e = v.Zero) {
    const i = this.translate(e);
    return new dt(i.left * t.x, i.top * t.y, i.right * t.x, i.bottom * t.y);
  }
  /**
   * Transform the axis aligned bounding box by a {@apilink Matrix}, producing a new axis aligned bounding box
   * @param matrix
   */
  transform(t) {
    const e = t.data[0] * this.left, i = t.data[1] * this.left, s = t.data[0] * this.right, n = t.data[1] * this.right, o = t.data[2] * this.top, a = t.data[3] * this.top, h = t.data[2] * this.bottom, l = t.data[3] * this.bottom, c = t.getPosition(), d = Math.min(e, s) + Math.min(o, h) + c.x, u = Math.min(i, n) + Math.min(a, l) + c.y, _ = Math.max(e, s) + Math.max(o, h) + c.x, p = Math.max(i, n) + Math.max(a, l) + c.y;
    return new dt({
      left: d,
      //: topLeft.x,
      top: u,
      //: topLeft.y,
      right: _,
      //: bottomRight.x,
      bottom: p
      //: bottomRight.y
    });
  }
  /**
   * Returns the perimeter of the bounding box
   */
  getPerimeter() {
    const t = this.width, e = this.height;
    return 2 * (t + e);
  }
  /**
   * Returns the world space points that make up the corners of the bounding box as a polygon
   */
  getPoints() {
    return (this._left !== this.left || this._right !== this.right || this._top !== this.top || this._bottom !== this.bottom) && (this._points.length = 0, this._points.push(new v(this.left, this.top)), this._points.push(new v(this.right, this.top)), this._points.push(new v(this.right, this.bottom)), this._points.push(new v(this.left, this.bottom)), this._left = this.left, this._right = this.right, this._top = this.top, this._bottom = this.bottom), this._points;
  }
  /**
   * Determines whether a ray intersects with a bounding box
   */
  rayCast(t, e = 1 / 0) {
    let i, s;
    const n = t.dir.x === 0 ? Number.MAX_VALUE : 1 / t.dir.x, o = t.dir.y === 0 ? Number.MAX_VALUE : 1 / t.dir.y, a = (this.left - t.pos.x) * n, h = (this.right - t.pos.x) * n;
    s = Math.min(a, h), i = Math.max(a, h);
    const l = (this.top - t.pos.y) * o, c = (this.bottom - t.pos.y) * o;
    return s = Math.max(s, Math.min(l, c)), i = Math.min(i, Math.max(l, c)), i >= 0 && i >= s && s < e;
  }
  /**
   * Returns the time along the ray where a raycast hits
   */
  rayCastTime(t, e = 1 / 0) {
    let i, s;
    const n = t.dir.x === 0 ? Number.MAX_VALUE : 1 / t.dir.x, o = t.dir.y === 0 ? Number.MAX_VALUE : 1 / t.dir.y, a = (this.left - t.pos.x) * n, h = (this.right - t.pos.x) * n;
    s = Math.min(a, h), i = Math.max(a, h);
    const l = (this.top - t.pos.y) * o, c = (this.bottom - t.pos.y) * o;
    return s = Math.max(s, Math.min(l, c)), i = Math.min(i, Math.max(l, c)), i >= 0 && i >= s && s < e ? s : -1;
  }
  contains(t) {
    return t instanceof v ? this.left <= t.x && this.top <= t.y && t.y <= this.bottom && t.x <= this.right : t instanceof dt ? this.left <= t.left && this.top <= t.top && t.bottom <= this.bottom && t.right <= this.right : !1;
  }
  /**
   * Combines this bounding box and another together returning a new bounding box
   * @param other  The bounding box to combine
   */
  combine(t, e) {
    const i = e || new dt(0, 0, 0, 0), s = Math.min(this.left, t.left), n = Math.min(this.top, t.top), o = Math.max(this.right, t.right), a = Math.max(this.bottom, t.bottom);
    return i.left = s, i.top = n, i.right = o, i.bottom = a, i;
  }
  get dimensions() {
    return new v(this.width, this.height);
  }
  /**
   * Returns true if the bounding boxes overlap.
   * @param other
   * @param epsilon Optionally specify a small epsilon (default 0) as amount of overlap to ignore as overlap.
   * This epsilon is useful in stable collision simulations.
   */
  overlaps(t, e) {
    const i = e || 0;
    if (t.hasZeroDimensions())
      return this.contains(t);
    if (this.hasZeroDimensions())
      return t.contains(this);
    const s = this.combine(t);
    return s.width + i < t.width + this.width && s.height + i < t.height + this.height;
  }
  /**
   * Test wether this bounding box intersects with another returning
   * the intersection vector that can be used to resolve the collision. If there
   * is no intersection null is returned.
   * @param other  Other {@apilink BoundingBox} to test intersection with
   * @returns A Vector in the direction of the current BoundingBox, this <- other
   */
  intersect(t) {
    if (this.bottom <= t.top || t.bottom <= this.top || this.right <= t.left || t.right <= this.left)
      return null;
    const e = this.bottom - t.top;
    dt._SCRATCH_INTERSECT[0] = e;
    const i = t.bottom - this.top;
    dt._SCRATCH_INTERSECT[1] = i;
    const s = this.right - t.left;
    dt._SCRATCH_INTERSECT[2] = s;
    const n = t.right - this.left;
    dt._SCRATCH_INTERSECT[3] = n;
    const o = qn(dt._SCRATCH_INTERSECT);
    switch (o) {
      case 0:
        return new v(0, -e);
      case 1:
        return new v(0, i);
      case 2:
        return new v(-s, 0);
      case 3:
        return new v(n, 0);
      default:
        const a = o;
        throw new Error(`Unreachable index: [${a}] on bounding box intersection!`);
    }
  }
  /**
   * Test whether the bounding box has intersected with another bounding box, returns the side of the current bb that intersected.
   * @param bb The other actor to test
   */
  intersectWithSide(t) {
    const e = this.intersect(t);
    return dt.getSideFromIntersection(e);
  }
  /**
   * Draw a debug bounding box
   * @param ex
   * @param color
   * @deprecated
   */
  draw(t, e = { color: T.Yellow }) {
    t.debug.drawRect(this.left, this.top, this.width, this.height, e);
  }
  /**
   * Draw a debug bounding box
   * @param ex
   * @param color
   */
  debug(t, e = { color: T.Yellow }) {
    t.debug.drawRect(this.left, this.top, this.width, this.height, e);
  }
};
Qn._SCRATCH_INTERSECT = [0, 0, 0, 0];
let F = Qn;
class xt {
  constructor(t, e) {
    this.colliderA = t, this.colliderB = e, this.id = null, this.id = xt.calculatePairHash(t.id, e.id);
  }
  /**
   * Returns whether a it is allowed for 2 colliders in a Pair to collide
   * @param colliderA
   * @param colliderB
   */
  static canCollide(t, e) {
    var i, s;
    if (t.id === e.id || t.owner && e.owner && t.owner.id === e.owner.id || t.localBounds.hasZeroDimensions() || e.localBounds.hasZeroDimensions())
      return !1;
    const n = (i = t == null ? void 0 : t.owner) == null ? void 0 : i.get(U), o = (s = e == null ? void 0 : e.owner) == null ? void 0 : s.get(U);
    return !(!n || !o || !n.group.canCollide(o.group) || n.collisionType === E.Fixed && o.collisionType === E.Fixed || o.collisionType === E.PreventCollision || n.collisionType === E.PreventCollision || !n.isActive || !o.isActive);
  }
  /**
   * Returns whether or not it is possible for the pairs to collide
   */
  get canCollide() {
    const t = this.colliderA, e = this.colliderB;
    return xt.canCollide(t, e);
  }
  /**
   * Runs the collision intersection logic on the members of this pair
   */
  collide() {
    return this.colliderA.collide(this.colliderB);
  }
  /**
   * Check if the collider is part of the pair
   * @param collider
   */
  hasCollider(t) {
    return t === this.colliderA || t === this.colliderB;
  }
  /**
   * Calculates the unique pair hash id for this collision pair (owning id)
   */
  static calculatePairHash(t, e) {
    return t.value < e.value ? `#${t.value}+${e.value}` : `#${e.value}+${t.value}`;
  }
}
class Os {
  constructor(t) {
    this.parent = t, this.parent = t || null, this.data = null, this.bounds = new F(), this.left = null, this.right = null, this.height = 0;
  }
  isLeaf() {
    return !this.left && !this.right;
  }
}
class Jn {
  constructor(t, e = new F(-Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)) {
    this._config = t, this.worldBounds = e, this.root = null, this.nodes = {};
  }
  /**
   * Inserts a node into the dynamic tree
   */
  _insert(t) {
    if (this.root === null) {
      this.root = t, this.root.parent = null;
      return;
    }
    const e = t.bounds;
    let i = this.root;
    for (; !i.isLeaf(); ) {
      const a = i.left, h = i.right, l = i.bounds.getPerimeter(), d = i.bounds.combine(e).getPerimeter(), u = 2 * d, _ = 2 * (d - l);
      let p = 0;
      const g = e.combine(a.bounds);
      let x, m;
      a.isLeaf() ? p = g.getPerimeter() + _ : (m = a.bounds.getPerimeter(), x = g.getPerimeter(), p = x - m + _);
      let f = 0;
      const b = e.combine(h.bounds);
      if (h.isLeaf() ? f = b.getPerimeter() + _ : (m = h.bounds.getPerimeter(), x = b.getPerimeter(), f = x - m + _), u < p && u < f)
        break;
      p < f ? i = a : i = h;
    }
    const s = i.parent, n = new Os(s);
    n.bounds = e.combine(i.bounds), n.height = i.height + 1, s !== null ? (s.left === i ? s.left = n : s.right = n, n.left = i, n.right = t, i.parent = n, t.parent = n) : (n.left = i, n.right = t, i.parent = n, t.parent = n, this.root = n);
    let o = t.parent;
    for (; o; ) {
      if (o = this._balance(o), !o.left)
        throw new Error("Parent of current leaf cannot have a null left child" + o);
      if (!o.right)
        throw new Error("Parent of current leaf cannot have a null right child" + o);
      o.height = 1 + Math.max(o.left.height, o.right.height), o.bounds = o.left.bounds.combine(o.right.bounds), o = o.parent;
    }
  }
  /**
   * Removes a node from the dynamic tree
   */
  _remove(t) {
    if (t === this.root) {
      this.root = null;
      return;
    }
    const e = t.parent, i = e.parent;
    let s;
    if (e.left === t ? s = e.right : s = e.left, i) {
      i.left === e ? i.left = s : i.right = s, s.parent = i;
      let n = i;
      for (; n; )
        n = this._balance(n), n.bounds = n.left.bounds.combine(n.right.bounds), n.height = 1 + Math.max(n.left.height, n.right.height), n = n.parent;
    } else
      this.root = s, s.parent = null;
  }
  /**
   * Tracks a body in the dynamic tree
   */
  trackCollider(t) {
    const e = new Os();
    e.data = t, e.bounds = t.bounds, e.bounds.left -= 2, e.bounds.top -= 2, e.bounds.right += 2, e.bounds.bottom += 2, this.nodes[t.id.value] = e, this._insert(e);
  }
  /**
   * Updates the dynamic tree given the current bounds of each body being tracked
   */
  updateCollider(t) {
    var e;
    const i = this.nodes[t.id.value];
    if (!i)
      return !1;
    const s = t.bounds;
    if (!this.worldBounds.contains(s))
      return R.getInstance().warn(
        "Collider with id " + t.id.value + " is outside the world bounds and will no longer be tracked for physics"
      ), this.untrackCollider(t), !1;
    if (i.bounds.contains(s))
      return !1;
    if (this._remove(i), s.left -= this._config.boundsPadding, s.top -= this._config.boundsPadding, s.right += this._config.boundsPadding, s.bottom += this._config.boundsPadding, t.owner) {
      const n = (e = t.owner) == null ? void 0 : e.get(U);
      if (n) {
        const o = n.vel.x * 32 / 1e3 * this._config.velocityMultiplier, a = n.vel.y * 32 / 1e3 * this._config.velocityMultiplier;
        o < 0 ? s.left += o : s.right += o, a < 0 ? s.top += a : s.bottom += a;
      }
    }
    return i.bounds = s, this._insert(i), !0;
  }
  /**
   * Untracks a body from the dynamic tree
   */
  untrackCollider(t) {
    const e = this.nodes[t.id.value];
    e && (this._remove(e), this.nodes[t.id.value] = null, delete this.nodes[t.id.value]);
  }
  /**
   * Balances the tree about a node
   */
  _balance(t) {
    if (t === null)
      throw new Error("Cannot balance at null node");
    if (t.isLeaf() || t.height < 2)
      return t;
    const e = t.left, i = t.right, s = t, n = e, o = i, a = e.left, h = e.right, l = i.left, c = i.right, d = o.height - n.height;
    if (d > 1)
      return o.left = s, o.parent = s.parent, s.parent = o, o.parent ? o.parent.left === s ? o.parent.left = o : o.parent.right = o : this.root = o, l.height > c.height ? (o.right = l, s.right = c, c.parent = s, s.bounds = n.bounds.combine(c.bounds), o.bounds = s.bounds.combine(l.bounds), s.height = 1 + Math.max(n.height, c.height), o.height = 1 + Math.max(s.height, l.height)) : (o.right = c, s.right = l, l.parent = s, s.bounds = n.bounds.combine(l.bounds), o.bounds = s.bounds.combine(c.bounds), s.height = 1 + Math.max(n.height, l.height), o.height = 1 + Math.max(s.height, c.height)), o;
    if (d < -1) {
      if (n.left = s, n.parent = s.parent, s.parent = n, n.parent)
        if (n.parent.left === s)
          n.parent.left = n;
        else {
          if (n.parent.right !== s)
            throw "Error rotating Dynamic Tree";
          n.parent.right = n;
        }
      else
        this.root = n;
      return a.height > h.height ? (n.right = a, s.left = h, h.parent = s, s.bounds = o.bounds.combine(h.bounds), n.bounds = s.bounds.combine(a.bounds), s.height = 1 + Math.max(o.height, h.height), n.height = 1 + Math.max(s.height, a.height)) : (n.right = h, s.left = a, a.parent = s, s.bounds = o.bounds.combine(a.bounds), n.bounds = s.bounds.combine(h.bounds), s.height = 1 + Math.max(o.height, a.height), n.height = 1 + Math.max(s.height, h.height)), n;
    }
    return t;
  }
  /**
   * Returns the internal height of the tree, shorter trees are better. Performance drops as the tree grows
   */
  getHeight() {
    return this.root === null ? 0 : this.root.height;
  }
  /**
   * Queries the Dynamic Axis Aligned Tree for bodies that could be colliding with the provided body.
   *
   * In the query callback, it will be passed a potential collider. Returning true from this callback indicates
   * that you are complete with your query and you do not want to continue. Returning false will continue searching
   * the tree until all possible colliders have been returned.
   */
  query(t, e) {
    const i = t.bounds, s = (n) => {
      if (n && n.bounds.overlaps(i))
        if (n.isLeaf() && n.data !== t) {
          if (e.call(t, n.data))
            return !0;
        } else
          return s(n.left) || s(n.right);
      return !1;
    };
    s(this.root);
  }
  /**
   * Queries the Dynamic Axis Aligned Tree for bodies that could be intersecting. By default the raycast query uses an infinitely
   * long ray to test the tree specified by `max`.
   *
   * In the query callback, it will be passed a potential body that intersects with the raycast. Returning true from this
   * callback indicates that your are complete with your query and do not want to continue. Return false will continue searching
   * the tree until all possible bodies that would intersect with the ray have been returned.
   */
  rayCastQuery(t, e = 1 / 0, i) {
    const s = (n) => {
      if (n && n.bounds.rayCast(t, e))
        if (n.isLeaf()) {
          if (i.call(t, n.data))
            return !0;
        } else
          return s(n.left) || s(n.right);
      return !1;
    };
    s(this.root);
  }
  getNodes() {
    const t = (e) => e ? [e].concat(t(e.left), t(e.right)) : [];
    return t(this.root);
  }
  debug(t) {
    const e = (i) => {
      i && (i.isLeaf() ? i.bounds.debug(t, { color: T.Green }) : i.bounds.debug(t, { color: T.White }), i.left && e(i.left), i.right && e(i.right));
    };
    e(this.root);
  }
}
class Ki {
  constructor(t) {
    this._config = t, this._pairs = /* @__PURE__ */ new Set(), this._collisionPairCache = [], this._colliders = [], this._dynamicCollisionTree = new Jn(t.dynamicTree);
  }
  getColliders() {
    return this._colliders;
  }
  query(t) {
    const e = [];
    return t instanceof F ? this._dynamicCollisionTree.query(
      {
        id: Pe("collider", -1),
        owner: null,
        bounds: t
      },
      (i) => (e.push(i), !1)
    ) : this._dynamicCollisionTree.query(
      {
        id: Pe("collider", -1),
        owner: null,
        bounds: new F(t.x, t.y, t.x, t.y)
      },
      (i) => (e.push(i), !1)
    ), e;
  }
  rayCast(t, e) {
    var i, s, n;
    const o = [], a = (i = e == null ? void 0 : e.maxDistance) != null ? i : 1 / 0, h = e == null ? void 0 : e.collisionGroup, l = h ? h.category : (s = e == null ? void 0 : e.collisionMask) != null ? s : Ee.All.category, c = (n = e == null ? void 0 : e.searchAllColliders) != null ? n : !1;
    return this._dynamicCollisionTree.rayCastQuery(t, a, (d) => {
      const _ = d.owner.get(U);
      if (e != null && e.ignoreCollisionGroupAll && _.group === Ee.All)
        return !1;
      const p = (l & _.group.category) !== 0;
      if (_ != null && _.group && !p)
        return !1;
      const g = d.rayCast(t, a);
      if (g) {
        if (e != null && e.filter) {
          if (e.filter(g) && (o.push(g), !c))
            return !0;
        } else if (o.push(g), !c)
          return !0;
      }
      return !1;
    }), o;
  }
  /**
   * Tracks a physics body for collisions
   */
  track(t) {
    if (!t) {
      R.getInstance().warn("Cannot track null collider");
      return;
    }
    if (t instanceof ht) {
      const e = t.getColliders();
      for (const i of e)
        i.owner = t.owner, this._colliders.push(i), this._dynamicCollisionTree.trackCollider(i);
    } else
      this._colliders.push(t), this._dynamicCollisionTree.trackCollider(t);
  }
  /**
   * Untracks a physics body
   */
  untrack(t) {
    if (!t) {
      R.getInstance().warn("Cannot untrack a null collider");
      return;
    }
    if (t instanceof ht) {
      const e = t.getColliders();
      for (const i of e) {
        const s = this._colliders.indexOf(i);
        s !== -1 && this._colliders.splice(s, 1), this._dynamicCollisionTree.untrackCollider(i);
      }
    } else {
      const e = this._colliders.indexOf(t);
      e !== -1 && this._colliders.splice(e, 1), this._dynamicCollisionTree.untrackCollider(t);
    }
  }
  _pairExists(t, e) {
    const i = xt.calculatePairHash(t.id, e.id);
    return this._pairs.has(i);
  }
  /**
   * Detects potential collision pairs in a broadphase approach with the dynamic AABB tree strategy
   */
  broadphase(t, e, i) {
    const s = e / 1e3, n = t.filter((a) => {
      var h, l;
      const c = (h = a.owner) == null ? void 0 : h.get(U);
      return ((l = a.owner) == null ? void 0 : l.isActive) && c.collisionType !== E.PreventCollision;
    });
    this._collisionPairCache = [], this._pairs.clear();
    let o;
    for (let a = 0, h = n.length; a < h; a++)
      o = n[a], this._dynamicCollisionTree.query(o, (l) => {
        if (!this._pairExists(o, l) && xt.canCollide(o, l)) {
          const c = new xt(o, l);
          this._pairs.add(c.id), this._collisionPairCache.push(c);
        }
        return !1;
      });
    if (i && (i.physics.pairs = this._collisionPairCache.length), this._config.continuous.checkForFastBodies)
      for (const a of n) {
        const h = a.owner.get(U);
        if ((h == null ? void 0 : h.collisionType) !== E.Active)
          continue;
        const l = h.vel.magnitude * s + // velocity term
        h.acc.magnitude * 0.5 * s * s, c = Math.min(a.bounds.height, a.bounds.width);
        if (this._config.continuous.disableMinimumSpeedForFastBody || l > c / 2) {
          i && i.physics.fastBodies++;
          const d = h.globalPos.sub(h.oldPos), u = a.center, _ = a.getFurthestPoint(h.vel), p = _.sub(d), g = new Ce(p, h.vel);
          g.pos = g.pos.add(g.dir.scale(-2 * this._config.continuous.surfaceEpsilon));
          let x, m = new v(1 / 0, 1 / 0);
          if (this._dynamicCollisionTree.rayCastQuery(g, l + this._config.continuous.surfaceEpsilon * 2, (f) => {
            if (!this._pairExists(a, f) && xt.canCollide(a, f)) {
              const b = f.rayCast(g, l + this._config.continuous.surfaceEpsilon * 10);
              if (b) {
                const C = b.point.sub(p);
                C.magnitude < m.magnitude && (m = C, x = f);
              }
            }
            return !1;
          }), x && v.isValid(m)) {
            const f = new xt(a, x);
            this._pairs.has(f.id) || (this._pairs.add(f.id), this._collisionPairCache.push(f));
            const b = u.sub(_);
            h.globalPos = p.add(b).add(m).add(g.dir.scale(10 * this._config.continuous.surfaceEpsilon)), a.update(h.transform.get()), i && i.physics.fastBodyCollisions++;
          }
        }
      }
    return this._collisionPairCache;
  }
  /**
   * Applies narrow phase on collision pairs to find actual area intersections
   * Adds actual colliding pairs to stats' Frame data
   */
  narrowphase(t, e) {
    let i = [];
    for (let s = 0; s < t.length; s++) {
      const n = t[s].collide();
      if (i = i.concat(n), e && n.length > 0)
        for (const o of n)
          e.physics.contacts.set(o.id, o);
    }
    return e && (e.physics.collisions += i.length), i;
  }
  /**
   * Update the dynamic tree positions
   */
  update(t) {
    let e = 0;
    const i = t.length;
    for (let s = 0; s < i; s++)
      this._dynamicCollisionTree.updateCollider(t[s]) && e++;
    return e;
  }
  debug(t) {
    this._dynamicCollisionTree.debug(t);
  }
}
const Kn = class tr {
  constructor() {
    this.id = Pe("collider", tr._ID++), this.composite = null, this.events = new X(), this.offset = v.Zero;
  }
  /**
   * Returns a boolean indicating whether this body collided with
   * or was in stationary contact with
   * the body of the other {@apilink Collider}
   */
  touching(t) {
    const e = this.collide(t);
    return !!(e && e.length > 0);
  }
};
Kn._ID = 0;
let Ei = Kn;
var wi = /* @__PURE__ */ ((r) => (r.Arcade = "arcade", r.Realistic = "realistic", r))(wi || {}), _e = /* @__PURE__ */ ((r) => (r.None = "none", r.VerticalFirst = "vertical-first", r.HorizontalFirst = "horizontal-first", r))(_e || {});
const er = {
  vertical: 1,
  horizontal: 2
}, ir = {
  horizontal: 1,
  vertical: 2
}, sr = {
  horizontal: 0,
  vertical: 0
};
var bi = /* @__PURE__ */ ((r) => (r.DynamicTree = "dynamic-tree", r.SparseHashGrid = "sparse-hash-grid", r))(bi || {});
const ne = () => ({
  enabled: !0,
  integration: {
    onScreenOnly: !1
  },
  gravity: w(0, 0).clone(),
  solver: wi.Arcade,
  substep: 1,
  colliders: {
    compositeStrategy: "together"
  },
  continuous: {
    checkForFastBodies: !0,
    disableMinimumSpeedForFastBody: !1,
    surfaceEpsilon: 0.1
  },
  bodies: {
    canSleepByDefault: !0,
    sleepEpsilon: 0.07,
    wakeThreshold: 0.07 * 3,
    sleepBias: 0.5,
    sleepTimeThreshold: 1e3,
    defaultMass: 10
  },
  spatialPartition: bi.SparseHashGrid,
  sparseHashGrid: {
    size: 100
  },
  dynamicTree: {
    boundsPadding: 5,
    velocityMultiplier: 2
  },
  arcade: {
    contactSolveBias: _e.None
  },
  realistic: {
    contactSolveBias: _e.None,
    positionIterations: 3,
    velocityIterations: 8,
    slop: 1,
    steeringFactor: 0.2,
    warmStart: !0
  }
});
class ht extends Ei {
  constructor(t) {
    super(), this._collisionProcessor = new Ki({
      ...ne()
    }), this._dynamicAABBTree = new Jn({
      boundsPadding: 5,
      velocityMultiplier: 2
    }), this._colliders = [];
    for (const e of t)
      this.addCollider(e);
  }
  /**
   * Treat composite collider's member colliders as either separate colliders for the purposes of onCollisionStart/onCollision
   * or as a single collider together.
   *
   * This property can be overridden on individual {@apilink CompositeColliders}.
   *
   * For composites without gaps or small groups of colliders, you probably want 'together'
   *
   * For composites with deliberate gaps, like a platforming level layout, you probably want 'separate'
   *
   * Default is 'together' if unset
   */
  set compositeStrategy(t) {
    this._compositeStrategy = t;
  }
  get compositeStrategy() {
    return this._compositeStrategy;
  }
  clearColliders() {
    this._colliders = [];
  }
  addCollider(t) {
    let e;
    t instanceof ht ? (e = t.getColliders(), e.forEach((i) => i.offset.addEqual(t.offset))) : e = [t];
    for (const i of e)
      i.events.pipe(this.events), i.composite = this, this._colliders.push(i), this._collisionProcessor.track(i), this._dynamicAABBTree.trackCollider(i);
  }
  removeCollider(t) {
    t.events.pipe(this.events), t.composite = null, ke(t, this._colliders), this._collisionProcessor.untrack(t), this._dynamicAABBTree.untrackCollider(t);
  }
  getColliders() {
    return this._colliders;
  }
  get worldPos() {
    var t, e;
    return ((e = (t = this._transform) == null ? void 0 : t.pos) != null ? e : v.Zero).add(this.offset);
  }
  get center() {
    var t, e;
    return ((e = (t = this._transform) == null ? void 0 : t.pos) != null ? e : v.Zero).add(this.offset);
  }
  get bounds() {
    var t, e;
    const i = this.getColliders();
    return i.reduce(
      (n, o) => n.combine(o.bounds),
      (e = (t = i[0]) == null ? void 0 : t.bounds) != null ? e : new F().translate(this.worldPos)
    ).translate(this.offset);
  }
  get localBounds() {
    var t, e;
    const i = this.getColliders();
    return i.reduce((n, o) => n.combine(o.localBounds), (e = (t = i[0]) == null ? void 0 : t.localBounds) != null ? e : new F());
  }
  get axes() {
    const t = this.getColliders();
    let e = [];
    for (const i of t)
      e = e.concat(i.axes);
    return e;
  }
  getFurthestPoint(t) {
    const e = this.getColliders(), i = [];
    for (const o of e)
      i.push(o.getFurthestPoint(t));
    let s = i[0], n = -Number.MAX_VALUE;
    for (const o of i) {
      const a = o.dot(t);
      a > n && (s = o, n = a);
    }
    return s;
  }
  getInertia(t) {
    const e = this.getColliders();
    let i = 0;
    for (const s of e)
      i += s.getInertia(t);
    return i;
  }
  collide(t) {
    let e = [t];
    t instanceof ht && (e = t.getColliders());
    const i = [];
    for (const n of e)
      this._dynamicAABBTree.query(n, (o) => (i.push(new xt(n, o)), !1));
    let s = [];
    for (const n of i)
      s = s.concat(n.collide());
    return s;
  }
  getClosestLineBetween(t) {
    const e = this.getColliders(), i = [];
    if (t instanceof ht) {
      const s = t.getColliders();
      for (const n of e)
        for (const o of s) {
          const a = n.getClosestLineBetween(o);
          a && i.push(a);
        }
    } else
      for (const s of e) {
        const n = t.getClosestLineBetween(s);
        n && i.push(n);
      }
    if (i.length) {
      let s = i[0].getLength(), n = i[0];
      for (const o of i) {
        const a = o.getLength();
        a < s && (s = a, n = o);
      }
      return n;
    }
    return null;
  }
  contains(t) {
    const e = this.getColliders();
    for (const i of e)
      if (i.contains(t))
        return !0;
    return !1;
  }
  rayCast(t, e) {
    const i = this.getColliders(), s = [];
    for (const n of i) {
      const o = n.rayCast(t, e);
      o && s.push(o);
    }
    if (s.length) {
      let n = s[0], o = n.point.dot(t.dir);
      for (const a of s) {
        const h = t.dir.dot(a.point);
        h < o && (n = a, o = h);
      }
      return n;
    }
    return null;
  }
  project(t) {
    const e = this.getColliders(), i = [];
    for (const s of e) {
      const n = s.project(t);
      n && i.push(n);
    }
    if (i.length) {
      const s = new Si(i[0].min, i[0].max);
      for (const n of i)
        s.min = Math.min(n.min, s.min), s.max = Math.max(n.max, s.max);
      return s;
    }
    return null;
  }
  update(t) {
    if (t) {
      const e = this.getColliders();
      for (const i of e)
        i.owner = this.owner, i.update(t);
    }
  }
  debug(t, e, i) {
    const s = this.getColliders();
    t.save(), t.translate(this.offset.x, this.offset.y);
    for (const n of s)
      n.debug(t, e, i);
    t.restore();
  }
  clone() {
    const t = new ht(this._colliders.map((e) => e.clone()));
    return t.offset = this.offset.clone(), t;
  }
}
function Oi(r, t) {
  const i = r.dir(), s = t.dir(), n = i.dot(i), o = s.dot(s);
  if (n < 1e-9 && o < 1e-9)
    return new K(r.begin, t.begin);
  if (n < 1e-9) {
    const x = D(s.dot(r.begin.sub(t.begin)) / o, 0, 1), m = t.begin.add(s.scale(x));
    return new K(r.begin, m);
  }
  if (o < 1e-9) {
    const x = D(i.dot(t.begin.sub(r.begin)) / n, 0, 1), m = r.begin.add(i.scale(x));
    return new K(m, t.begin);
  }
  const a = r.begin.sub(t.begin), h = n, l = o, c = s.dot(a), d = h * l - Math.pow(i.dot(s), 2);
  let u = 0, _ = 0;
  Math.abs(d) > 1e-9 ? u = D((i.dot(s) * c - l * i.dot(a)) / d, 0, 1) : u = D(i.dot(a) / h, 0, 1), Math.abs(l) > 1e-9 ? _ = D((i.dot(s) * u + c) / l, 0, 1) : _ = 0;
  const p = r.begin.add(i.scale(u)), g = t.begin.add(s.scale(_));
  return new K(p, g);
}
const Zt = {
  PolygonPolygonClosestLine(r, t) {
    const e = r.getSides(), i = t.getSides();
    let s = Number.MAX_VALUE, n = null;
    for (let o = 0; o < e.length; o++)
      for (let a = 0; a < i.length; a++) {
        const h = Oi(e[o], i[a]), l = h.getLength();
        l < s && (s = l, n = h);
      }
    return n;
  },
  PolygonEdgeClosestLine(r, t) {
    const i = t.worldPos.sub(r.worldPos), s = new Ce(r.worldPos, i), n = r.rayCast(s).point.add(s.dir.scale(0.1)), o = r.getClosestFace(n), a = t.asLine();
    return Oi(o.face, a);
  },
  PolygonCircleClosestLine(r, t) {
    const e = t.worldPos, i = e.sub(r.worldPos), s = new Ce(r.worldPos, i.normalize()), n = r.rayCast(s).point.add(s.dir.scale(0.1)), o = r.getClosestFace(n), a = o.face.begin, h = o.face.getEdge();
    let l = (h.x * (e.x - a.x) + h.y * (e.y - a.y)) / (h.x * h.x + h.y * h.y);
    l > 1 ? l = 1 : l < 0 && (l = 0);
    const c = Math.sqrt(Math.pow(a.x + h.x * l - e.x, 2) + Math.pow(a.y + h.y * l - e.y, 2)) - t.radius, d = (a.x + h.x * l - e.x) * t.radius / (t.radius + c), u = (a.y + h.y * l - e.y) * t.radius / (t.radius + c);
    return new K(h.scale(l).add(a), new v(e.x + d, e.y + u));
  },
  CircleCircleClosestLine(r, t) {
    const i = t.worldPos.sub(r.worldPos), n = r.worldPos.sub(t.worldPos), o = new Ce(r.worldPos, i), a = new Ce(t.worldPos, n), h = r.rayCast(o), l = t.rayCast(a);
    return new K(h.point, l.point);
  },
  CircleEdgeClosestLine(r, t) {
    const e = r.worldPos, i = t.asLine(), s = i.begin, n = i.getEdge(), o = s, a = n;
    let h = (a.x * (e.x - o.x) + a.y * (e.y - o.y)) / (a.x * a.x + a.y * a.y);
    h > 1 ? h = 1 : h < 0 && (h = 0);
    const l = Math.sqrt(Math.pow(o.x + a.x * h - e.x, 2) + Math.pow(o.y + a.y * h - e.y, 2)) - r.radius, c = (o.x + a.x * h - e.x) * r.radius / (r.radius + l), d = (o.y + a.y * h - e.y) * r.radius / (r.radius + l);
    return new K(a.scale(h).add(o), new v(e.x + c, e.y + d));
  },
  EdgeEdgeClosestLine(r, t) {
    const e = r.asLine(), i = t.asLine();
    return Oi(e, i);
  }
};
class ut extends Ei {
  constructor(t) {
    super(), this.offset = v.Zero, this._globalMatrix = j.identity(), this._localBoundsDirty = !0, this.offset = t.offset || v.Zero, this.radius = t.radius || 0, this._globalMatrix.translate(this.offset.x, this.offset.y);
  }
  get worldPos() {
    return this._globalMatrix.getPosition();
  }
  /**
   * Get the radius of the circle
   */
  get radius() {
    var t;
    if (this._radius)
      return this._radius;
    const e = this._transform, i = (t = e == null ? void 0 : e.globalScale) != null ? t : v.One;
    return this._radius = this._naturalRadius * Math.min(i.x, i.y);
  }
  /**
   * Set the radius of the circle
   */
  set radius(t) {
    var e;
    const i = this._transform, s = (e = i == null ? void 0 : i.globalScale) != null ? e : v.One;
    this._naturalRadius = t / Math.min(s.x, s.y), this._localBoundsDirty = !0, this._radius = t;
  }
  /**
   * Returns a clone of this shape, not associated with any collider
   */
  clone() {
    return new ut({
      offset: this.offset.clone(),
      radius: this.radius
    });
  }
  /**
   * Get the center of the collider in world coordinates
   */
  get center() {
    return this._globalMatrix.getPosition();
  }
  /**
   * Tests if a point is contained in this collider
   */
  contains(t) {
    var e, i;
    return ((i = (e = this._transform) == null ? void 0 : e.pos) != null ? i : this.offset).distance(t) <= this.radius;
  }
  /**
   * Casts a ray at the Circle collider and returns the nearest point of collision
   * @param ray
   */
  rayCast(t, e = 1 / 0) {
    var i, s;
    const n = this.center, o = t.dir, a = t.pos, h = n.sub(a), l = o.scale(h.dot(o)), d = h.sub(l).magnitude;
    if (d > this.radius)
      return null;
    {
      let u = 0;
      if (so(d, this.radius, 1e-4)) {
        if (u = -o.dot(a.sub(n)), u > 0 && u < e) {
          const _ = t.getPoint(u);
          return {
            point: _,
            normal: _.sub(n).normalize(),
            collider: this,
            body: (i = this.owner) == null ? void 0 : i.get(U),
            distance: u
          };
        }
        return null;
      } else {
        const _ = Math.sqrt(Math.pow(o.dot(a.sub(n)), 2) - Math.pow(a.sub(n).distance(), 2) + Math.pow(this.radius, 2)), p = -o.dot(a.sub(n)) + _, g = -o.dot(a.sub(n)) - _, x = [];
        p >= 0 && x.push(p), g >= 0 && x.push(g);
        const m = Math.min(...x);
        if (m <= e) {
          const f = t.getPoint(m);
          return {
            point: f,
            normal: f.sub(n).normalize(),
            collider: this,
            body: (s = this.owner) == null ? void 0 : s.get(U),
            distance: m
          };
        }
        return null;
      }
    }
  }
  getClosestLineBetween(t) {
    if (t instanceof ut)
      return Zt.CircleCircleClosestLine(this, t);
    if (t instanceof ct)
      return Zt.PolygonCircleClosestLine(t, this).flip();
    if (t instanceof At)
      return Zt.CircleEdgeClosestLine(this, t).flip();
    throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof t}`);
  }
  /**
   * @inheritdoc
   */
  collide(t) {
    if (t instanceof ut)
      return Ot.CollideCircleCircle(this, t);
    if (t instanceof ct)
      return Ot.CollideCirclePolygon(this, t);
    if (t instanceof At)
      return Ot.CollideCircleEdge(this, t);
    throw new Error(`Circle could not collide with unknown CollisionShape ${typeof t}`);
  }
  /**
   * Find the point on the collider furthest in the direction specified
   */
  getFurthestPoint(t) {
    return this.center.add(t.normalize().scale(this.radius));
  }
  /**
   * Find the local point on the shape in the direction specified
   * @param direction
   */
  getFurthestLocalPoint(t) {
    return t.normalize().scale(this.radius);
  }
  /**
   * Get the axis aligned bounding box for the circle collider in world coordinates
   */
  get bounds() {
    return this.localBounds.transform(this._globalMatrix);
  }
  /**
   * Get the axis aligned bounding box for the circle collider in local coordinates
   */
  get localBounds() {
    return this._localBoundsDirty && (this._localBounds = new F(-this._naturalRadius, -this._naturalRadius, +this._naturalRadius, +this._naturalRadius), this._localBoundsDirty = !1), this._localBounds;
  }
  /**
   * Get axis not implemented on circles, since there are infinite axis in a circle
   */
  get axes() {
    return [];
  }
  /**
   * Returns the moment of inertia of a circle given it's mass
   * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
   */
  getInertia(t) {
    return t * this.radius * this.radius / 2;
  }
  /* istanbul ignore next */
  update(t) {
    var e;
    this._transform = t, ((e = t.matrix) != null ? e : this._globalMatrix).clone(this._globalMatrix), this._globalMatrix.translate(this.offset.x, this.offset.y), this._radius = void 0;
  }
  /**
   * Project the circle along a specified axis
   */
  project(t) {
    const e = [], s = this.center.dot(t);
    return e.push(s), e.push(s + this.radius), e.push(s - this.radius), new Si(Math.min.apply(Math, e), Math.max.apply(Math, e));
  }
  debug(t, e, i) {
    var s, n, o, a;
    const { lineWidth: h } = { lineWidth: 1, ...i }, l = this._transform, c = (s = l == null ? void 0 : l.globalScale) != null ? s : v.One, d = (n = l == null ? void 0 : l.globalRotation) != null ? n : 0, u = (o = l == null ? void 0 : l.globalPos) != null ? o : v.Zero;
    t.save(), t.translate(u.x, u.y), t.rotate(d), t.scale(c.x, c.y), t.debug.drawCircle((a = this.offset) != null ? a : v.Zero, this._naturalRadius, T.Transparent, e, h), t.restore();
  }
}
class we {
  constructor(t, e, i, s, n, o, a, h) {
    this._canceled = !1, this.bodyA = null, this.bodyB = null;
    var l, c, d, u, _, p;
    if (this.colliderA = t, this.colliderB = e, this.mtv = i, this.normal = s, this.tangent = n, this.points = o, this.localPoints = a, this.info = h, this.id = xt.calculatePairHash(t.id, e.id), t.composite || e.composite) {
      const g = ((l = t.composite) == null ? void 0 : l.compositeStrategy) === "separate" ? t.id : (d = (c = t.composite) == null ? void 0 : c.id) != null ? d : t.id, x = ((u = e.composite) == null ? void 0 : u.compositeStrategy) === "separate" ? e.id : (p = (_ = e.composite) == null ? void 0 : _.id) != null ? p : e.id;
      this.id += "|" + xt.calculatePairHash(g, x);
    }
    this.colliderA.owner && (this.bodyA = this.colliderA.owner.get(U)), this.colliderB.owner && (this.bodyB = this.colliderB.owner.get(U));
  }
  isCanceled() {
    return this._canceled;
  }
  cancel() {
    this._canceled = !0;
  }
  /**
   * Biases the contact so that the given collider is colliderA
   */
  bias(t) {
    if (t !== this.colliderA && t !== this.colliderB)
      throw new Error("Collider must be either colliderA or colliderB from this contact");
    if (t === this.colliderA)
      return this;
    const e = this.colliderA, i = this.colliderB;
    return this.colliderB = e, this.colliderA = i, this.mtv = this.mtv.negate(), this.normal = this.normal.negate(), this.tangent = this.tangent.negate(), this;
  }
}
class us {
  constructor(t, e, i = 100) {
    this.builder = t, this.recycler = e, this.maxObjects = i, this.totalAllocations = 0, this.index = 0, this.objects = [], this.disableWarnings = !1, this._logger = R.getInstance();
  }
  dispose() {
    this.objects.length = 0;
  }
  preallocate() {
    for (let t = 0; t < this.maxObjects; t++)
      this.objects[t] = this.builder();
  }
  /**
   * Use many instances out of the in the context and return all to the pool.
   *
   * By returning values out of the context they will be un-hooked from the pool and are free to be passed to consumers
   * @param context
   */
  using(t) {
    const e = t(this);
    return e ? this.done(...e) : this.done();
  }
  /**
   * Use a single instance out of th pool and immediately return it to the pool
   * @param context
   */
  borrow(t) {
    const e = this.get();
    t(e), this.index--;
  }
  /**
   * Retrieve a value from the pool, will allocate a new instance if necessary or recycle from the pool
   */
  get() {
    return this.index === this.maxObjects && (this.disableWarnings || this._logger.warn("Max pooled objects reached, possible memory leak? Doubling"), this.maxObjects = this.maxObjects * 2), this.objects[this.index] ? this.recycler ? this.recycler(this.objects[this.index++]) : this.objects[this.index++] : (this.totalAllocations++, this.objects[this.index++] = this.builder());
  }
  done(...t) {
    this.index = 0;
    for (const e of t) {
      const i = this.objects.indexOf(e);
      this.objects[i] = this.builder(), this.totalAllocations++;
    }
    return t;
  }
}
class bo {
  constructor() {
    this.axis = w(0, 0), this.localAxis = w(0, 0), this.side = new K(w(0, 0), w(0, 0)), this.localSide = new K(w(0, 0), w(0, 0)), this.point = w(0, 0), this.localPoint = w(0, 0);
  }
}
const xe = class qt {
  static findPolygonPolygonSeparation(t, e) {
    if (e.transform.matrix.determinant() === 0)
      return qt.findPolygonPolygonSeparationDegenerate(t, e);
    let i = -Number.MAX_VALUE, s = -1, n;
    const o = e.transform.inverse.multiply(t.transform.matrix, qt._SCRATCH_MATRIX), a = o.getRotation(), h = t.normals, l = t.points, c = e.points;
    for (let _ = 0; _ < l.length; _++) {
      const p = h[_].rotate(a, qt._ZERO, qt._SCRATCH_NORMAL), g = o.multiply(l[_], qt._SCRATCH_POINT);
      let x = Number.MAX_VALUE, m;
      for (let f = 0; f < c.length; f++) {
        const b = p.dot(c[f].sub(g, qt._SCRATCH_SUB_POINT));
        b < x && (x = b, m = c[f]);
      }
      x > i && (i = x, s = _, n = m);
    }
    const d = (s + 1) % l.length, u = qt.SeparationPool.get();
    return u.collider = t, u.separation = i, i > 0 || (h[s].clone(u.localAxis), h[s].rotate(t.transform.rotation, qt._ZERO, u.axis), t.transform.matrix.multiply(l[s], u.side.begin), t.transform.matrix.multiply(l[d], u.side.end), e.transform.matrix.multiply(n, u.point), u.sideId = s, n.clone(u.localPoint), l[s].clone(u.localSide.begin), l[d].clone(u.localSide.end)), u;
  }
  static findCirclePolygonSeparation(t, e) {
    const i = e.axes, n = e.center.sub(t.worldPos), o = e.getFurthestPoint(n.negate());
    i.push(o.sub(t.worldPos).normalize());
    let a = Number.MAX_VALUE, h = null, l = -1;
    for (let c = 0; c < i.length; c++) {
      const d = e.project(i[c]), u = t.project(i[c]), _ = d.getOverlap(u);
      if (_ <= 0)
        return null;
      _ < a && (a = _, h = i[c], l = c);
    }
    return l < 0 ? null : h.normalize().scale(a);
  }
  static findPolygonPolygonSeparationDegenerate(t, e) {
    let i = -Number.MAX_VALUE, s = null, n = null, o = -1, a = null;
    const h = t.getSides(), l = t.getLocalSides();
    for (let c = 0; c < h.length; c++) {
      const d = h[c], u = d.normal(), _ = e.getFurthestPoint(u.negate()), p = d.distanceToPoint(_, !0);
      p > i && (i = p, s = d, n = u, o = c, a = _);
    }
    return {
      collider: t,
      separation: n ? i : 99,
      axis: n,
      side: s,
      localSide: l[o],
      sideId: o,
      point: a,
      localPoint: n ? e.getFurthestLocalPoint(n.negate()) : null
    };
  }
};
xe.SeparationPool = new us(
  () => new bo(),
  (r) => r,
  // no recycle
  500
);
xe._ZERO = w(0, 0);
xe._SCRATCH_POINT = w(0, 0);
xe._SCRATCH_SUB_POINT = w(0, 0);
xe._SCRATCH_NORMAL = w(0, 0);
xe._SCRATCH_MATRIX = j.identity();
let Ve = xe;
Ve.SeparationPool.disableWarnings = !0;
const yo = v.Zero, Co = v.Zero, To = j.identity(), Ot = {
  CollideCircleCircle(r, t) {
    const e = r.worldPos, i = t.worldPos, s = r.radius + t.radius, n = e.distance(i);
    if (n > s)
      return [];
    const o = s - n, a = i.sub(e).normalize(), h = a.perpendicular(), l = a.scale(o), c = r.getFurthestPoint(a), d = r.getFurthestLocalPoint(a), u = {
      collider: r,
      separation: o,
      axis: a,
      point: c
    };
    return [new we(r, t, l, a, h, [c], [d], u)];
  },
  CollideCirclePolygon(r, t) {
    var e, i;
    let s = Ve.findCirclePolygonSeparation(r, t);
    if (!s)
      return [];
    s = s.dot(t.center.sub(r.center)) < 0 ? s.negate() : s;
    const o = r.getFurthestPoint(s), h = ((i = (e = r.owner) == null ? void 0 : e.get(P)) != null ? i : new P()).applyInverse(o), l = s.normalize(), c = {
      collider: r,
      separation: -s.magnitude,
      axis: l,
      point: o,
      localPoint: h,
      side: t.findSide(l.negate()),
      localSide: t.findLocalSide(l.negate())
    };
    return [new we(r, t, s, l, l.perpendicular(), [o], [h], c)];
  },
  CollideCircleEdge(r, t) {
    const e = r.center, i = t.asLine(), s = i.end.sub(i.begin), n = s.dot(i.end.sub(e)), o = s.dot(e.sub(i.begin)), a = t.asLine(), h = t.asLocalLine();
    if (o <= 0) {
      const m = i.begin.sub(e), f = m.dot(m);
      if (f > r.radius * r.radius)
        return [];
      const b = m.normalize(), C = r.radius - Math.sqrt(f), S = {
        collider: r,
        separation: C,
        axis: b,
        point: a.begin,
        side: a,
        localSide: h
      };
      return [
        new we(r, t, b.scale(C), b, b.perpendicular(), [a.begin], [h.begin], S)
      ];
    }
    if (n <= 0) {
      const m = i.end.sub(e), f = m.dot(m);
      if (f > r.radius * r.radius)
        return [];
      const b = m.normalize(), C = r.radius - Math.sqrt(f), S = {
        collider: r,
        separation: C,
        axis: b,
        point: a.end,
        side: a,
        localSide: h
      };
      return [
        new we(r, t, b.scale(C), b, b.perpendicular(), [a.end], [h.end], S)
      ];
    }
    const l = s.dot(s), c = i.begin.scale(n).add(i.end.scale(o)).scale(1 / l), d = e.sub(c), u = d.dot(d);
    if (u > r.radius * r.radius)
      return [];
    let _ = s.perpendicular();
    _.dot(e.sub(i.begin)) < 0 && (_.x = -_.x, _.y = -_.y), _ = _.normalize();
    const p = r.radius - Math.sqrt(u), g = _.scale(p), x = {
      collider: r,
      separation: p,
      axis: _,
      point: c,
      side: a,
      localSide: h
    };
    return [
      new we(
        r,
        t,
        g,
        _.negate(),
        _.negate().perpendicular(),
        [c],
        [c.sub(t.worldPos)],
        x
      )
    ];
  },
  CollideEdgeEdge() {
    return [];
  },
  CollidePolygonEdge(r, t) {
    var e;
    const i = r.center, n = t.center.sub(i).normalize(), o = new ct({
      points: [t.begin, t.end, t.end.add(n.scale(100)), t.begin.add(n.scale(100))],
      offset: t.offset
    });
    o.owner = t.owner, ((e = t.owner) == null ? void 0 : e.get(P)) && o.update(t.owner.get(P).get());
    const h = this.CollidePolygonPolygon(r, o);
    return h.length && (h[0].colliderB = t, h[0].id = xt.calculatePairHash(r.id, t.id)), h;
  },
  CollidePolygonPolygon(r, t) {
    const e = Ve.findPolygonPolygonSeparation(r, t);
    if (e.separation > 0)
      return [];
    const i = Ve.findPolygonPolygonSeparation(t, r);
    if (i.separation > 0)
      return [];
    const s = e.separation > i.separation ? e : i, n = s.collider === r ? t : r, o = s.collider === r ? r : t, a = n.transform.inverse.multiply(o.transform.matrix, To), h = a.getRotation(), l = o.normals[s.sideId].rotate(h, yo, Co);
    let c = Number.MAX_VALUE, d = 0;
    for (let m = 0; m < n.normals.length; m++) {
      const f = l.dot(n.normals[m]);
      f < c && (c = f, d = m);
    }
    if (!s.localSide || !s.localAxis || !s.axis)
      return [];
    const u = s.localSide.transform(a), _ = s.localAxis.perpendicular().negate().rotate(h), g = new K(n.points[d], n.points[(d + 1) % n.points.length]).clip(_.negate(), -_.dot(u.begin), !1);
    let x = null;
    if (g && (x = g.clip(_, _.dot(u.end), !1)), x) {
      const m = [], f = [], b = x.getPoints();
      for (let I = 0; I < b.length; I++) {
        const y = b[I];
        u.below(y) && (m.push(y), f.push(n.transform.apply(y)));
      }
      let C = s.axis, S = C.perpendicular();
      return t.center.sub(r.center).dot(C) < 0 && (C = C.negate(), S = C.perpendicular()), [new we(r, t, C.scale(-s.separation), C, S, f, m, s)];
    }
    return [];
  },
  FindContactSeparation(r, t) {
    var e, i, s, n;
    const o = r.colliderA, a = (i = (e = r.bodyA) == null ? void 0 : e.transform) != null ? i : new P(), h = r.colliderB, l = (n = (s = r.bodyB) == null ? void 0 : s.transform) != null ? n : new P();
    if (o instanceof ut && h instanceof ut) {
      const c = o.radius + h.radius, d = a.pos.distance(l.pos);
      return -(c - d);
    }
    if (o instanceof ct && h instanceof ct && r.info.localSide) {
      let c, d;
      return r.info.collider === o ? (c = new K(
        a.apply(r.info.localSide.begin).add(o.offset),
        a.apply(r.info.localSide.end).add(o.offset)
      ), d = l.apply(t).add(h.offset)) : (c = new K(
        l.apply(r.info.localSide.begin).add(h.offset),
        l.apply(r.info.localSide.end).add(h.offset)
      ), d = a.apply(t).add(o.offset)), c.distanceToPoint(d, !0);
    }
    if (o instanceof ct && h instanceof ut || h instanceof ct && o instanceof ut) {
      const c = a.apply(t);
      if (r.info.side)
        return r.info.side.distanceToPoint(c, !0);
    }
    if (o instanceof At && h instanceof ct || h instanceof At && o instanceof ct) {
      let c;
      if (r.info.collider === o ? c = l.apply(t) : c = a.apply(t), r.info.side)
        return r.info.side.distanceToPoint(c, !0);
    }
    if (o instanceof ut && h instanceof At || h instanceof ut && o instanceof At) {
      const c = l.apply(t);
      let d;
      o instanceof ut && (d = o.getFurthestPoint(r.normal));
      const u = c.distance(d);
      if (r.info.side)
        return u > 0 ? -u : 0;
    }
    return 0;
  }
};
class At extends Ei {
  constructor(t) {
    var e;
    super(), this._globalMatrix = j.identity(), this.begin = t.begin || v.Zero, this.end = t.end || v.Zero, this.offset = (e = t.offset) != null ? e : v.Zero;
  }
  /**
   * Returns a clone of this Edge, not associated with any collider
   */
  clone() {
    return new At({
      begin: this.begin.clone(),
      end: this.end.clone()
    });
  }
  get worldPos() {
    var t;
    const e = this._transform;
    return (t = e == null ? void 0 : e.globalPos.add(this.offset)) != null ? t : this.offset;
  }
  /**
   * Get the center of the collision area in world coordinates
   */
  get center() {
    const t = this._getTransformedBegin(), e = this._getTransformedEnd();
    return t.average(e);
  }
  _getTransformedBegin() {
    return this._globalMatrix.multiply(this.begin);
  }
  _getTransformedEnd() {
    return this._globalMatrix.multiply(this.end);
  }
  /**
   * Returns the slope of the line in the form of a vector
   */
  getSlope() {
    const t = this._getTransformedBegin(), e = this._getTransformedEnd(), i = t.distance(e);
    return e.sub(t).scale(1 / i);
  }
  /**
   * Returns the length of the line segment in pixels
   */
  getLength() {
    const t = this._getTransformedBegin(), e = this._getTransformedEnd();
    return t.distance(e);
  }
  /**
   * Tests if a point is contained in this collision area
   */
  contains() {
    return !1;
  }
  /**
   * @inheritdoc
   */
  rayCast(t, e = 1 / 0) {
    var i;
    const s = this._getTransformedBegin().sub(t.pos);
    if (t.dir.cross(this.getSlope()) === 0 && s.cross(t.dir) !== 0)
      return null;
    const n = t.dir.cross(this.getSlope());
    if (n === 0)
      return null;
    const o = s.cross(this.getSlope()) / n;
    if (o >= 0 && o <= e) {
      const a = s.cross(t.dir) / n / this.getLength();
      if (a >= 0 && a <= 1)
        return {
          distance: o,
          normal: this.asLine().normal(),
          collider: this,
          body: (i = this.owner) == null ? void 0 : i.get(U),
          point: t.getPoint(o)
        };
    }
    return null;
  }
  /**
   * Returns the closes line between this and another collider, from this -> collider
   * @param shape
   */
  getClosestLineBetween(t) {
    if (t instanceof ut)
      return Zt.CircleEdgeClosestLine(t, this);
    if (t instanceof ct)
      return Zt.PolygonEdgeClosestLine(t, this).flip();
    if (t instanceof At)
      return Zt.EdgeEdgeClosestLine(this, t);
    throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof t}`);
  }
  /**
   * @inheritdoc
   */
  collide(t) {
    if (t instanceof ut)
      return Ot.CollideCircleEdge(t, this);
    if (t instanceof ct)
      return Ot.CollidePolygonEdge(t, this);
    if (t instanceof At)
      return Ot.CollideEdgeEdge();
    throw new Error(`Edge could not collide with unknown CollisionShape ${typeof t}`);
  }
  /**
   * Find the point on the collider furthest in the direction specified
   */
  getFurthestPoint(t) {
    const e = this._getTransformedBegin(), i = this._getTransformedEnd();
    return t.dot(e) > 0 ? e : i;
  }
  _boundsFromBeginEnd(t, e, i = 10) {
    return new F(
      Math.min(t.x, e.x) - i,
      Math.min(t.y, e.y) - i,
      Math.max(t.x, e.x) + i,
      Math.max(t.y, e.y) + i
    );
  }
  /**
   * Get the axis aligned bounding box for the edge collider in world space
   */
  get bounds() {
    const t = this._getTransformedBegin(), e = this._getTransformedEnd();
    return this._boundsFromBeginEnd(t, e);
  }
  /**
   * Get the axis aligned bounding box for the edge collider in local space
   */
  get localBounds() {
    return this._boundsFromBeginEnd(this.begin, this.end);
  }
  /**
   * Returns this edge represented as a line in world coordinates
   */
  asLine() {
    return new K(this._getTransformedBegin(), this._getTransformedEnd());
  }
  /**
   * Return this edge as a line in local line coordinates (relative to the position)
   */
  asLocalLine() {
    return new K(this.begin, this.end);
  }
  /**
   * Get the axis associated with the edge
   */
  get axes() {
    const e = this._getTransformedEnd().sub(this._getTransformedBegin()).normal(), i = [];
    return i.push(e), i.push(e.negate()), i.push(e.normal()), i.push(e.normal().negate()), i;
  }
  /**
   * Get the moment of inertia for an edge
   * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
   */
  getInertia(t) {
    const e = this.end.sub(this.begin).distance() / 2;
    return t * e * e;
  }
  /**
   * @inheritdoc
   */
  update(t) {
    var e;
    this._transform = t, ((e = t.matrix) != null ? e : this._globalMatrix).clone(this._globalMatrix), this._globalMatrix.translate(this.offset.x, this.offset.y);
  }
  /**
   * Project the edge along a specified axis
   */
  project(t) {
    const e = [], i = [this._getTransformedBegin(), this._getTransformedEnd()], s = i.length;
    for (let n = 0; n < s; n++)
      e.push(i[n].dot(t));
    return new Si(Math.min.apply(Math, e), Math.max.apply(Math, e));
  }
  debug(t, e) {
    const i = this._getTransformedBegin(), s = this._getTransformedEnd();
    t.debug.drawLine(i, s, { color: e, lineWidth: 2 }), t.debug.drawCircle(i, 2, e), t.debug.drawCircle(s, 2, e);
  }
}
class ct extends Ei {
  constructor(t) {
    var e;
    super(), this._logger = R.getInstance(), this._transform = new re(), this._transformedPoints = [], this._sides = [], this._localSides = [], this._transformedPointsDirty = !0, this._sidesDirty = !0, this._localSidesDirty = !0, this._localBoundsDirty = !0, this.offset = (e = t.offset) != null ? e : v.Zero, this._transform.pos.x += this.offset.x, this._transform.pos.y += this.offset.y, this.points = t.points, this.isConvex() || t.suppressConvexWarning || this._logger.warn(
      "Excalibur only supports convex polygon colliders and will not behave properly.Call PolygonCollider.triangulate() to build a new collider composed of smaller convex triangles"
    ), this._calculateTransformation();
  }
  flagDirty() {
    this._localBoundsDirty = !0, this._localSidesDirty = !0, this._transformedPointsDirty = !0, this._sidesDirty = !0;
  }
  get normals() {
    return this._normals;
  }
  /**
   * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.
   * Excalibur stores these in counter-clockwise order
   */
  set points(t) {
    if (t.length < 3)
      throw new Error("PolygonCollider cannot be created with less that 3 points");
    this._points = t, this._checkAndUpdateWinding(this._points), this._calculateNormals(), this.flagDirty();
  }
  _calculateNormals() {
    const t = [];
    for (let e = 0; e < this._points.length; e++)
      t.push(this._points[(e + 1) % this._points.length].sub(this._points[e]).normal());
    this._normals = t;
  }
  /**
   * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.
   * Excalibur stores these in counter-clockwise order
   */
  get points() {
    return this._points;
  }
  get transform() {
    return this._transform;
  }
  _checkAndUpdateWinding(t) {
    this._isCounterClockwiseWinding(t) || t.reverse();
  }
  _isCounterClockwiseWinding(t) {
    let e = 0;
    for (let i = 0; i < t.length; i++)
      e += (t[(i + 1) % t.length].x - t[i].x) * (t[(i + 1) % t.length].y + t[i].y);
    return e < 0;
  }
  /**
   * Returns if the polygon collider is convex, Excalibur does not handle non-convex collision shapes.
   * Call {@apilink Polygon.triangulate} to generate a {@apilink CompositeCollider} from this non-convex shape
   */
  isConvex() {
    if (this.points.length < 3)
      return !1;
    let t = this.points[this.points.length - 2], e = this.points[this.points.length - 1], i = Math.atan2(e.y - t.y, e.x - t.x), s = 0, n = 0, o = 0;
    for (const [a, h] of this.points.entries()) {
      if (t = e, s = i, e = h, i = Math.atan2(e.y - t.y, e.x - t.x), t.equals(e))
        return !1;
      let l = i - s;
      if (l <= -Math.PI ? l += Math.PI * 2 : l > Math.PI && (l -= Math.PI * 2), a === 0) {
        if (l === 0)
          return !1;
        n = l > 0 ? 1 : -1;
      } else if (n * l <= 0)
        return !1;
      o += l;
    }
    return Math.abs(Math.round(o / (Math.PI * 2))) === 1;
  }
  /**
   * Tessellates the polygon into a triangle fan as a {@apilink CompositeCollider} of triangle polygons
   */
  tessellate() {
    const t = [];
    for (let e = 1; e < this.points.length - 2; e++)
      t.push([this.points[0], this.points[e + 1], this.points[e + 2]]);
    return t.push([this.points[0], this.points[1], this.points[2]]), new ht(t.map((e) => _t.Polygon(e)));
  }
  /**
   * Triangulate the polygon collider using the "Ear Clipping" algorithm.
   * Returns a new {@apilink CompositeCollider} made up of smaller triangles.
   */
  triangulate() {
    if (this.points.length < 3)
      throw Error("Invalid polygon");
    const t = [], e = [...this.points].reverse();
    let i = e.length;
    function s(d) {
      return d === 0 ? i - 1 : d - 1;
    }
    function n(d) {
      return d === i - 1 ? 0 : d + 1;
    }
    function o(d) {
      const u = s(d), _ = n(d), p = e[u], g = e[d], x = e[_], m = p.sub(g), f = x.sub(g);
      return !(m.cross(f) < 0);
    }
    const a = e.map((d, u) => o(u));
    function h(d, u, _, p) {
      const g = _.sub(u), x = p.sub(_), m = u.sub(p), f = d.sub(u), b = d.sub(_), C = d.sub(p), S = g.cross(f), I = x.cross(b), y = m.cross(C);
      return !(S > 0 || I > 0 || y > 0);
    }
    function l() {
      for (let d = 0; d < i; d++)
        if (a[d]) {
          const u = s(d), _ = n(d), p = e[u], g = e[d], x = e[_];
          let m = !0;
          for (let f = 0; f < i; f++) {
            if (f === d || f === u || f === _)
              continue;
            const b = e[f];
            if (h(b, p, g, x)) {
              m = !1;
              break;
            }
          }
          if (m)
            return d;
        }
      for (let d = 0; d < i; d++)
        if (a[d])
          return d;
      return 0;
    }
    function c(d) {
      const u = s(d), _ = n(d), p = e[u], g = e[d], x = e[_];
      t.push([p, g, x]), e.splice(d, 1), a.splice(d, 1), i--;
    }
    for (; i > 3; ) {
      const d = l();
      c(d);
      for (let u = 0; u < i; u++)
        a[u] = o(u);
    }
    return t.push([e[0], e[1], e[2]]), new ht(t.map((d) => _t.Polygon(d, v.Zero, !0)));
  }
  /**
   * Returns a clone of this ConvexPolygon, not associated with any collider
   */
  clone() {
    return new ct({
      offset: this.offset.clone(),
      points: this.points.map((t) => t.clone())
    });
  }
  /**
   * Returns the world position of the collider, which is the current body transform plus any defined offset
   */
  get worldPos() {
    return this._transform.pos;
  }
  /**
   * Get the center of the collider in world coordinates
   */
  get center() {
    return this.bounds.center;
  }
  /**
   * Calculates the underlying transformation from the body relative space to world space
   */
  _calculateTransformation() {
    const t = this.points, e = t.length;
    this._transformedPoints.length = 0;
    for (let i = 0; i < e; i++)
      this._transformedPoints[i] = this._transform.apply(t[i].clone());
  }
  /**
   * Gets the points that make up the polygon in world space, from actor relative space (if specified)
   */
  getTransformedPoints() {
    return this._transformedPointsDirty && (this._calculateTransformation(), this._transformedPointsDirty = !1), this._transformedPoints;
  }
  /**
   * Gets the sides of the polygon in world space
   */
  getSides() {
    if (this._sidesDirty) {
      const t = [], e = this.getTransformedPoints(), i = e.length;
      for (let s = 0; s < i; s++)
        t.push(new K(e[s], e[(s + 1) % i]));
      this._sides = t, this._sidesDirty = !1;
    }
    return this._sides;
  }
  /**
   * Returns the local coordinate space sides
   */
  getLocalSides() {
    if (this._localSidesDirty) {
      const t = [], e = this.points, i = e.length;
      for (let s = 0; s < i; s++)
        t.push(new K(e[s], e[(s + 1) % i]));
      this._localSides = t, this._localSidesDirty = !1;
    }
    return this._localSides;
  }
  /**
   * Given a direction vector find the world space side that is most in that direction
   * @param direction
   */
  findSide(t) {
    const e = this.getSides();
    let i = e[0], s = -Number.MAX_VALUE;
    for (let n = 0; n < e.length; n++) {
      const o = e[n], h = o.normal().dot(t);
      h > s && (i = o, s = h);
    }
    return i;
  }
  /**
   * Given a direction vector find the local space side that is most in that direction
   * @param direction
   */
  findLocalSide(t) {
    const e = this.getLocalSides();
    let i = e[0], s = -Number.MAX_VALUE;
    for (let n = 0; n < e.length; n++) {
      const o = e[n], h = o.normal().dot(t);
      h > s && (i = o, s = h);
    }
    return i;
  }
  /**
   * Get the axis associated with the convex polygon
   */
  get axes() {
    const t = [], e = this.getSides();
    for (let i = 0; i < e.length; i++)
      t.push(e[i].normal());
    return t;
  }
  /**
   * Updates the transform for the collision geometry
   *
   * Collision geometry (points/bounds) will not change until this is called.
   * @param transform
   */
  update(t) {
    t && (t.cloneWithParent(this._transform), this._transformedPointsDirty = !0, this._sidesDirty = !0, (this.offset.x !== 0 || this.offset.y !== 0) && (this._transform.pos.x += this.offset.x, this._transform.pos.y += this.offset.y), this._transform.isMirrored() && (this.points = this.points.map((e) => w(e.x * q(this._transform.scale.x), e.y * q(this._transform.scale.y))), this._transform.scale.x = Math.abs(this._transform.scale.x), this._transform.scale.y = Math.abs(this._transform.scale.y)));
  }
  /**
   * Tests if a point is contained in this collider in world space
   */
  contains(t) {
    const e = this._transform.applyInverse(t), i = new Ce(e, new v(1, 0));
    let s = 0;
    const n = this.getLocalSides();
    for (let o = 0; o < n.length; o++) {
      const a = n[o];
      i.intersect(a) >= 0 && s++;
    }
    return s % 2 !== 0;
  }
  getClosestLineBetween(t) {
    if (t instanceof ut)
      return Zt.PolygonCircleClosestLine(this, t);
    if (t instanceof ct)
      return Zt.PolygonPolygonClosestLine(this, t);
    if (t instanceof At)
      return Zt.PolygonEdgeClosestLine(this, t);
    throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof t}`);
  }
  /**
   * Returns a collision contact if the 2 colliders collide, otherwise collide will
   * return null.
   * @param collider
   */
  collide(t) {
    if (t instanceof ut)
      return Ot.CollideCirclePolygon(t, this);
    if (t instanceof ct)
      return Ot.CollidePolygonPolygon(this, t);
    if (t instanceof At)
      return Ot.CollidePolygonEdge(this, t);
    throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof t}`);
  }
  /**
   * Find the point on the collider furthest in the direction specified
   */
  getFurthestPoint(t) {
    const e = this.getTransformedPoints();
    let i = null, s = -Number.MAX_VALUE;
    for (let n = 0; n < e.length; n++) {
      const o = t.dot(e[n]);
      o > s && (s = o, i = e[n]);
    }
    return i;
  }
  /**
   * Find the local point on the collider furthest in the direction specified
   * @param direction
   */
  getFurthestLocalPoint(t) {
    const e = this.points;
    let i = e[0], s = -Number.MAX_VALUE;
    for (let n = 0; n < e.length; n++) {
      const o = t.dot(e[n]);
      o > s && (s = o, i = e[n]);
    }
    return i;
  }
  /**
   * Finds the closes face to the point using perpendicular distance
   * @param point point to test against polygon
   */
  getClosestFace(t) {
    const e = this.getSides();
    let i = Number.POSITIVE_INFINITY, s = -1, n = -1;
    for (let o = 0; o < e.length; o++) {
      const a = e[o].distanceToPoint(t);
      a < i && (i = a, s = o, n = a);
    }
    return s !== -1 ? {
      distance: e[s].normal().scale(n),
      face: e[s]
    } : null;
  }
  /**
   * Get the axis aligned bounding box for the polygon collider in world coordinates
   */
  get bounds() {
    return this.localBounds.transform(this._transform.matrix);
  }
  /**
   * Get the axis aligned bounding box for the polygon collider in local coordinates
   */
  get localBounds() {
    return this._localBoundsDirty && (this._localBounds = F.fromPoints(this.points), this._localBoundsDirty = !1), this._localBounds;
  }
  /**
   * Get the moment of inertia for an arbitrary polygon
   * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
   */
  getInertia(t) {
    if (this._cachedMass === t && this._cachedInertia)
      return this._cachedInertia;
    let e = 0, i = 0;
    const s = this.points;
    for (let n = 0; n < s.length; n++) {
      const o = (n + 1) % s.length, a = s[o].cross(s[n]);
      e += a * (s[n].dot(s[n]) + s[n].dot(s[o]) + s[o].dot(s[o])), i += a;
    }
    return this._cachedMass = t, this._cachedInertia = t / 6 * (e / i);
  }
  /**
   * Casts a ray into the polygon and returns a vector representing the point of contact (in world space) or null if no collision.
   */
  rayCast(t, e = 1 / 0) {
    var i;
    const s = this.getSides(), n = s.length;
    let o = Number.MAX_VALUE, a, h = -1;
    for (let l = 0; l < n; l++) {
      const c = t.intersect(s[l]);
      c >= 0 && c < o && c <= e && (o = c, a = s[l], h = l);
    }
    return h >= 0 ? {
      collider: this,
      distance: o,
      body: (i = this.owner) == null ? void 0 : i.get(U),
      point: t.getPoint(o),
      normal: a.normal()
    } : null;
  }
  /**
   * Project the edges of the polygon along a specified axis
   */
  project(t) {
    const e = this.getTransformedPoints(), i = e.length;
    let s = Number.MAX_VALUE, n = -Number.MAX_VALUE;
    for (let o = 0; o < i; o++) {
      const a = e[o].dot(t);
      s = Math.min(s, a), n = Math.max(n, a);
    }
    return new Si(s, n);
  }
  debug(t, e, i) {
    const s = this.getTransformedPoints();
    St.drawPolygon(s, { color: e });
  }
}
class _t {
  /**
   * Creates a box collider, under the hood defines a {@apilink PolygonCollider} collider
   * @param width Width of the box
   * @param height Height of the box
   * @param anchor Anchor of the box (default (.5, .5)) which positions the box relative to the center of the collider's position
   * @param offset Optional offset relative to the collider in local coordinates
   */
  static Box(t, e, i = v.Half, s = v.Zero) {
    return new ct({
      points: new F(-t * i.x, -e * i.y, t - t * i.x, e - e * i.y).getPoints().slice(),
      offset: s
    });
  }
  /**
   * Creates a new {@apilink PolygonCollider | `arbitrary polygon`} collider
   *
   * PolygonColliders are useful for creating convex polygon shapes
   * @param points Points specified in counter clockwise
   * @param offset Optional offset relative to the collider in local coordinates
   */
  static Polygon(t, e = v.Zero, i = !1) {
    return new ct({
      points: t,
      offset: e,
      suppressConvexWarning: i
    });
  }
  /**
   * Creates a new {@apilink CircleCollider | `circle`} collider
   *
   * Circle colliders are useful for balls, or to make collisions more forgiving on sharp edges
   * @param radius Radius of the circle collider
   * @param offset Optional offset relative to the collider in local coordinates
   */
  static Circle(t, e = v.Zero) {
    return new ut({
      radius: t,
      offset: e
    });
  }
  /**
   * Creates a new {@apilink EdgeCollider | `edge`} collider
   *
   * Edge colliders are useful for  floors, walls, and other barriers
   * @param begin Beginning of the edge in local coordinates to the collider
   * @param end Ending of the edge in local coordinates to the collider
   */
  static Edge(t, e) {
    return new At({
      begin: t,
      end: e
    });
  }
  /**
   * Creates a new capsule shaped {@apilink CompositeCollider} using 2 circles and a box
   *
   * Capsule colliders are useful for platformers with incline or jagged floors to have a smooth
   * player experience.
   * @param width
   * @param height
   * @param offset Optional offset
   */
  static Capsule(t, e, i = v.Zero) {
    const s = R.getInstance();
    if (t === e && s.warn("A capsule collider with equal width and height is a circle, consider using a ex.Shape.Circle or ex.CircleCollider"), e >= t) {
      const o = new ht([
        _t.Circle(t / 2, w(0, -e / 2 + t / 2).add(i)),
        _t.Box(t, e - t, v.Half, i),
        _t.Circle(t / 2, w(0, e / 2 - t / 2).add(i))
      ]);
      return o.compositeStrategy = "together", o;
    } else {
      const o = new ht([
        _t.Circle(e / 2, w(-t / 2 + e / 2, 0).add(i)),
        _t.Box(t - e, e, v.Half, i),
        _t.Circle(e / 2, w(t / 2 - e / 2, 0).add(i))
      ]);
      return o.compositeStrategy = "together", o;
    }
  }
}
function Pt(r, t) {
  return r && (r.__isProxy === void 0 ? new Proxy(r, {
    set: (e, i, s) => (e[i] !== s && (e[i] = s, typeof i == "string" && i[0] !== "_" && t(e)), !0),
    get: (e, i) => i !== "__isProxy" ? e[i] : !0
  }) : r);
}
const nr = (r = [], t, e) => ({
  get: (i, s) => s === "__isProxy" ? !0 : typeof i[s] == "object" && i[s] != null ? new Proxy(i[s], nr([...r, s], t, e)) : i[s],
  set: (i, s, n) => (typeof s == "string" && s[0] !== "_" && t(e), i[s] = n, !0)
});
function So(r, t) {
  return r && (r.__isProxy === void 0 ? new Proxy(r, nr([], t, r)) : r);
}
const rr = class or {
  constructor(t) {
    this.id = or._ID++, this.transform = j.identity(), this._transformStale = !0, this.showDebug = !1, this._flipHorizontal = !1, this._flipVertical = !1, this._rotation = 0, this.opacity = 1, this._scale = v.One, this._width = 0, this._height = 0;
    var e, i, s, n, o, a, h;
    t && (this.origin = (e = t.origin) != null ? e : this.origin, this.flipHorizontal = (i = t.flipHorizontal) != null ? i : this.flipHorizontal, this.flipVertical = (s = t.flipVertical) != null ? s : this.flipVertical, this.rotation = (n = t.rotation) != null ? n : this.rotation, this.opacity = (o = t.opacity) != null ? o : this.opacity, this.scale = (a = t.scale) != null ? a : this.scale, this.tint = (h = t.tint) != null ? h : this.tint, t.width && (this._width = t.width), t.height && (this._height = t.height));
  }
  isStale() {
    return this._transformStale;
  }
  /**
   * Gets or sets the flipHorizontal, which will flip the graphic horizontally (across the y axis)
   */
  get flipHorizontal() {
    return this._flipHorizontal;
  }
  set flipHorizontal(t) {
    this._flipHorizontal = t, this._transformStale = !0;
  }
  /**
   * Gets or sets the flipVertical, which will flip the graphic vertically (across the x axis)
   */
  get flipVertical() {
    return this._flipVertical;
  }
  set flipVertical(t) {
    this._flipVertical = t, this._transformStale = !0;
  }
  /**
   * Gets or sets the rotation of the graphic
   */
  get rotation() {
    return this._rotation;
  }
  set rotation(t) {
    this._rotation = t, this._transformStale = !0;
  }
  /**
   * Gets or sets the scale of the graphic, this affects the width and
   */
  get scale() {
    return this._scale;
  }
  set scale(t) {
    this._scale = Pt(t, () => {
      this._transformStale = !0;
    }), this._transformStale = !0;
  }
  /**
   * Gets or sets the origin of the graphic, if not set the center of the graphic is the origin
   */
  get origin() {
    return this._origin;
  }
  set origin(t) {
    t && (this._origin = Pt(t, () => {
      this._transformStale = !0;
    })), this._transformStale = !0;
  }
  cloneGraphicOptions() {
    return {
      width: this.width / this.scale.x,
      height: this.height / this.scale.y,
      origin: this.origin ? this.origin.clone() : void 0,
      flipHorizontal: this.flipHorizontal,
      flipVertical: this.flipVertical,
      rotation: this.rotation,
      opacity: this.opacity,
      scale: this.scale ? this.scale.clone() : void 0,
      tint: this.tint ? this.tint.clone() : void 0
    };
  }
  /**
   * Gets or sets the width of the graphic (always positive)
   */
  get width() {
    return Math.abs(this._width * this.scale.x);
  }
  /**
   * Gets or sets the height of the graphic (always positive)
   */
  get height() {
    return Math.abs(this._height * this.scale.y);
  }
  set width(t) {
    this._width = t, this._transformStale = !0;
  }
  set height(t) {
    this._height = t, this._transformStale = !0;
  }
  /**
   * Gets a copy of the bounds in pixels occupied by the graphic on the the screen. This includes scale.
   */
  get localBounds() {
    return F.fromDimension(this.width, this.height, v.Zero);
  }
  /**
   * Draw the whole graphic to the context including transform
   * @param ex The excalibur graphics context
   * @param x
   * @param y
   */
  draw(t, e, i) {
    this._preDraw(t, e, i), this._drawImage(t, 0, 0), this._postDraw(t);
  }
  /**
   * Apply affine transformations to the graphics context to manipulate the graphic before {@apilink Graphic._drawImage}
   * @param ex
   * @param x
   * @param y
   */
  _preDraw(t, e, i) {
    t.save(), t.translate(e, i), this._transformStale && (this.transform.reset(), this.transform.scale(Math.abs(this.scale.x), Math.abs(this.scale.y)), this._rotate(this.transform), this._flip(this.transform), this._transformStale = !1), t.multiply(this.transform), t.opacity = t.opacity * this.opacity, this.tint && (t.tint = this.tint);
  }
  _rotate(t) {
    var e;
    const i = this.scale.x > 0 ? 1 : -1, s = this.scale.y > 0 ? 1 : -1, n = (e = this.origin) != null ? e : w(this.width / 2, this.height / 2);
    t.translate(n.x, n.y), t.rotate(this.rotation), t.scale(i, s), t.translate(-n.x, -n.y);
  }
  _flip(t) {
    this.flipHorizontal && (t.translate(this.width / this.scale.x, 0), t.scale(-1, 1)), this.flipVertical && (t.translate(0, this.height / this.scale.y), t.scale(1, -1));
  }
  /**
   * Apply any additional work after {@apilink Graphic._drawImage} and restore the context state.
   * @param ex
   */
  _postDraw(t) {
    this.showDebug && t.debug.drawRect(0, 0, this.width, this.height), t.restore();
  }
};
rr._ID = 0;
let nt = rr;
var Ao = /* @__PURE__ */ ((r) => (r.Forward = "forward", r.Backward = "backward", r))(Ao || {}), Po = /* @__PURE__ */ ((r) => (r.End = "end", r.Loop = "loop", r.PingPong = "pingpong", r.Freeze = "freeze", r))(Po || {});
const Ul = {
  Frame: "frame",
  Loop: "loop",
  End: "end"
}, ar = class ts extends nt {
  constructor(t) {
    var e, i, s;
    super(t), this.events = new X(), this.frames = [], this.strategy = "loop", this.frameDuration = 100, this._idempotencyToken = -1, this._firstTick = !0, this._currentFrame = 0, this._timeLeftInFrame = 0, this._pingPongDirection = 1, this._done = !1, this._playing = !0, this._speed = 1, this._wasResetDuringFrameCalc = !1, this._reversed = !1, this.frames = t.frames, this.speed = (e = t.speed) != null ? e : this.speed, this.strategy = (i = t.strategy) != null ? i : this.strategy, this.frameDuration = t.totalDuration ? t.totalDuration / this.frames.length : (s = t.frameDuration) != null ? s : this.frameDuration, this.data = t.data ? new Map(Object.entries(t.data)) : /* @__PURE__ */ new Map(), t.reverse && this.reverse(), this.goToFrame(0);
  }
  clone() {
    const t = this.constructor;
    return new t({
      frames: this.frames.map((e) => ({ ...e })),
      frameDuration: this.frameDuration,
      speed: this.speed,
      reverse: this._reversed,
      strategy: this.strategy,
      ...this.cloneGraphicOptions()
    });
  }
  get width() {
    const t = this.currentFrame;
    return t && t.graphic ? Math.abs(t.graphic.width * this.scale.x) : 0;
  }
  get height() {
    const t = this.currentFrame;
    return t && t.graphic ? Math.abs(t.graphic.height * this.scale.y) : 0;
  }
  /**
   * Create an Animation from a {@apilink SpriteSheet}, a list of indices into the sprite sheet, a duration per frame
   * and optional {@apilink AnimationStrategy}
   *
   * Example:
   * ```typescript
   * const spriteSheet = SpriteSheet.fromImageSource({...});
   *
   * const anim = Animation.fromSpriteSheet(spriteSheet, range(0, 5), 200, AnimationStrategy.Loop);
   * ```
   * @param spriteSheet ex.SpriteSheet
   * @param spriteSheetIndex 0 based index from left to right, top down (row major order) of the ex.SpriteSheet
   * @param durationPerFrame duration per frame in milliseconds
   * @param strategy Optional strategy, default AnimationStrategy.Loop
   */
  static fromSpriteSheet(t, e, i, s = "loop", n) {
    const o = t.sprites.length - 1, a = [], h = [];
    return e.forEach((l) => {
      l < 0 || l > o ? h.push(l) : a.push(l);
    }), h.length && ts._LOGGER.warn(
      `Indices into SpriteSheet were provided that don't exist: frames ${h.join(",")} will not be shown`
    ), new this({
      frames: a.map((l) => ({
        graphic: t.sprites[l],
        duration: i
      })),
      strategy: s,
      data: n
    });
  }
  /**
   * Create an {@apilink Animation} from a {@apilink SpriteSheet} given a list of coordinates
   *
   * Example:
   * ```typescript
   * const spriteSheet = SpriteSheet.fromImageSource({...});
   *
   * const anim = Animation.fromSpriteSheetCoordinates({
   *  spriteSheet,
   *  frameCoordinates: [
   *    {x: 0, y: 5, duration: 100, options { flipHorizontal: true }},
   *    {x: 1, y: 5, duration: 200},
   *    {x: 2, y: 5},
   *    {x: 3, y: 5}
   *  ],
   *  strategy: AnimationStrategy.PingPong
   * });
   * ```
   * @param options
   * @returns Animation
   */
  static fromSpriteSheetCoordinates(t) {
    var e;
    const { spriteSheet: i, frameCoordinates: s, durationPerFrame: n, durationPerFrameMs: o, speed: a, strategy: h, reverse: l, data: c } = t, d = (e = n != null ? n : o) != null ? e : 100, u = [];
    for (const _ of s) {
      const { x: p, y: g, duration: x, options: m } = _, f = i.getSprite(p, g, m);
      f ? u.push({
        graphic: f,
        duration: x != null ? x : d
      }) : ts._LOGGER.warn(
        `Skipping frame! SpriteSheet does not have coordinate (${p}, ${g}), please check your SpriteSheet to confirm that sprite exists`
      );
    }
    return new this({
      frames: u,
      strategy: h,
      speed: a,
      reverse: l,
      data: c
    });
  }
  /**
   * Current animation speed
   *
   * 1 meaning normal 1x speed.
   * 2 meaning 2x speed and so on.
   */
  get speed() {
    return this._speed;
  }
  /**
   * Current animation speed
   *
   * 1 meaning normal 1x speed.
   * 2 meaning 2x speed and so on.
   */
  set speed(t) {
    this._speed = D(Math.abs(t), 0, 1 / 0);
  }
  /**
   * Returns the current Frame of the animation
   *
   * Use {@apilink Animation.currentFrameIndex} to get the frame number and
   * {@apilink Animation.goToFrame} to set the current frame index
   */
  get currentFrame() {
    return this._currentFrame >= 0 && this._currentFrame < this.frames.length ? this.frames[this._currentFrame] : null;
  }
  /**
   * Returns the current frame index of the animation
   *
   * Use {@apilink Animation.currentFrame} to grab the current {@apilink Frame} object
   */
  get currentFrameIndex() {
    return this._currentFrame;
  }
  /**
   * Returns the amount of time in milliseconds left in the current frame
   */
  get currentFrameTimeLeft() {
    return this._timeLeftInFrame;
  }
  /**
   * Returns `true` if the animation is playing
   */
  get isPlaying() {
    return this._playing;
  }
  get isReversed() {
    return this._reversed;
  }
  /**
   * Reverses the play direction of the Animation, this preserves the current frame
   */
  reverse() {
    this.frames = this.frames.slice().reverse(), this._reversed = !this._reversed;
  }
  /**
   * Returns the current play direction of the animation
   */
  get direction() {
    return !!(this._reversed && this._pingPongDirection === 1) ? "backward" : "forward";
  }
  /**
   * Plays or resumes the animation from the current frame
   */
  play() {
    this._playing = !0;
  }
  /**
   * Pauses the animation on the current frame
   */
  pause() {
    this._playing = !1, this._firstTick = !0;
  }
  /**
   * Reset the animation back to the beginning, including if the animation were done
   */
  reset() {
    this._wasResetDuringFrameCalc = !0, this._done = !1, this._firstTick = !0, this._currentFrame = 0, this._timeLeftInFrame = this.frameDuration;
    const t = this.frames[this._currentFrame];
    t && (this._timeLeftInFrame = (t == null ? void 0 : t.duration) || this.frameDuration);
  }
  /**
   * Returns `true` if the animation can end
   */
  get canFinish() {
    switch (this.strategy) {
      case "end":
      case "freeze":
        return !0;
      default:
        return !1;
    }
  }
  /**
   * Returns `true` if the animation is done, for looping type animations
   * `ex.AnimationStrategy.PingPong` and `ex.AnimationStrategy.Loop` this will always return `false`
   *
   * See the `ex.Animation.canFinish()` method to know if an animation type can end
   */
  get done() {
    return this._done;
  }
  /**
   * Jump the animation immediately to a specific frame if it exists
   *
   * Optionally specify an override for the duration of the frame, useful for
   * keeping multiple animations in sync with one another.
   * @param frameNumber
   * @param duration
   */
  goToFrame(t, e) {
    this._currentFrame = t, this._timeLeftInFrame = e != null ? e : this.frameDuration;
    const i = this.frames[this._currentFrame];
    i && !this._done && (this._timeLeftInFrame = e != null ? e : (i == null ? void 0 : i.duration) || this.frameDuration, this.events.emit("frame", { ...i, frameIndex: this.currentFrameIndex }));
  }
  _nextFrame() {
    this._wasResetDuringFrameCalc = !1;
    const t = this._currentFrame;
    if (this._done)
      return t;
    let e = -1;
    switch (this.strategy) {
      case "loop": {
        e = (t + 1) % this.frames.length, e === 0 && this.events.emit("loop", this);
        break;
      }
      case "end": {
        e = t + 1, e >= this.frames.length && (this._done = !0, this._currentFrame = this.frames.length, this.events.emit("end", this));
        break;
      }
      case "freeze": {
        e = D(t + 1, 0, this.frames.length - 1), t + 1 >= this.frames.length && (this._done = !0, this.events.emit("end", this));
        break;
      }
      case "pingpong": {
        t + this._pingPongDirection >= this.frames.length && (this._pingPongDirection = -1, this.events.emit("loop", this)), t + this._pingPongDirection < 0 && (this._pingPongDirection = 1, this.events.emit("loop", this)), e = t + this._pingPongDirection % this.frames.length;
        break;
      }
    }
    return this._wasResetDuringFrameCalc ? (this._wasResetDuringFrameCalc = !1, this._currentFrame) : e;
  }
  /**
   * Called internally by Excalibur to update the state of the animation potential update the current frame
   * @param elapsed Milliseconds elapsed
   * @param idempotencyToken Prevents double ticking in a frame by passing a unique token to the frame
   */
  tick(t, e = 0) {
    this._idempotencyToken !== e && (this._idempotencyToken = e, this._playing && (this._firstTick && (this._firstTick = !1, this.events.emit("frame", { ...this.currentFrame, frameIndex: this.currentFrameIndex })), this._timeLeftInFrame -= t * this._speed, this._timeLeftInFrame <= 0 && this.goToFrame(this._nextFrame())));
  }
  _drawImage(t, e, i) {
    this.currentFrame && this.currentFrame.graphic && this.currentFrame.graphic.draw(t, e, i);
  }
};
ar._LOGGER = R.getInstance();
let _s = ar;
class Ze extends nt {
  constructor(t) {
    var e;
    super(t), this._logger = R.getInstance(), this.useAnchor = !0, this.members = [], this.members = t.members, this.useAnchor = (e = t.useAnchor) != null ? e : this.useAnchor, this._updateDimensions();
  }
  clone() {
    return new Ze({
      members: [...this.members],
      ...this.cloneGraphicOptions()
    });
  }
  _updateDimensions() {
    const t = this.localBounds;
    return this.width = t.width, this.height = t.height, t;
  }
  get localBounds() {
    const t = new F();
    for (const e of this.members)
      if (e instanceof nt)
        e.localBounds.combine(t, t);
      else {
        const { graphic: i, offset: s, useBounds: n } = e;
        i ? (n === void 0 ? !0 : n) && i.localBounds.translate(s).combine(t, t) : this._logger.warnOnce(`Graphics group member has an null or undefined graphic, member definition: ${JSON.stringify(e)}.`);
      }
    return t;
  }
  _isAnimationOrGroup(t) {
    return t instanceof _s || t instanceof Ze;
  }
  tick(t, e) {
    for (const i of this.members) {
      let s;
      i instanceof nt ? s = i : s = i.graphic, this._isAnimationOrGroup(s) && s.tick(t, e);
    }
  }
  reset() {
    for (const t of this.members) {
      let e;
      t instanceof nt ? e = t : e = t.graphic, this._isAnimationOrGroup(e) && e.reset();
    }
  }
  _preDraw(t, e, i) {
    this._updateDimensions(), super._preDraw(t, this.useAnchor ? e : 0, this.useAnchor ? i : 0);
  }
  _drawImage(t, e, i) {
    const s = v.Zero;
    for (const n of this.members) {
      let o;
      n instanceof nt ? o = n : (o = n.graphic, n.offset.clone(s)), o && (t.save(), t.translate(e, i), o.draw(t, s.x, s.y), this.showDebug && t.debug.drawRect(0, 0, this.width, this.height), t.restore());
    }
  }
}
class ti extends nt {
  constructor(t) {
    var e, i, s, n, o, a, h, l, c, d;
    super(Yn({ ...t }, ["width", "height"])), this.lineCap = "butt", this.quality = 1, this._dirty = !0, this._smoothing = !1, this._color = Pt(T.Black, () => this.flagDirty()), this._lineWidth = 1, this._lineDash = [], this._padding = 0, t && (this.quality = (e = t.quality) != null ? e : this.quality, this.color = (i = t.color) != null ? i : T.Black, this.strokeColor = t == null ? void 0 : t.strokeColor, this.smoothing = (s = t.smoothing) != null ? s : this.smoothing, this.lineWidth = (n = t.lineWidth) != null ? n : this.lineWidth, this.lineDash = (o = t.lineDash) != null ? o : this.lineDash, this.lineCap = (a = t.lineCap) != null ? a : this.lineCap, this.padding = (h = t.padding) != null ? h : this.padding, this.filtering = (l = t.filtering) != null ? l : this.filtering), this._bitmap = document.createElement("canvas");
    const u = (c = t == null ? void 0 : t.width) != null ? c : this._bitmap.width, _ = (d = t == null ? void 0 : t.height) != null ? d : this._bitmap.height;
    this.width = u, this.height = _;
    const p = this._bitmap.getContext("2d");
    if (p)
      this._ctx = p;
    else
      throw new Error("Browser does not support 2d canvas drawing, cannot create Raster graphic");
  }
  cloneRasterOptions() {
    return {
      color: this.color ? this.color.clone() : void 0,
      strokeColor: this.strokeColor ? this.strokeColor.clone() : void 0,
      smoothing: this.smoothing,
      lineWidth: this.lineWidth,
      lineDash: this.lineDash,
      lineCap: this.lineCap,
      quality: this.quality,
      padding: this.padding
    };
  }
  /**
   * Gets whether the graphic is dirty, this means there are changes that haven't been re-rasterized
   */
  get dirty() {
    return this._dirty;
  }
  /**
   * Flags the graphic as dirty, meaning it must be re-rasterized before draw.
   * This should be called any time the graphics state changes such that it affects the outputted drawing
   */
  flagDirty() {
    this._dirty = !0;
  }
  /**
   * Gets or sets the current width of the Raster graphic. Setting the width will cause the raster
   * to be flagged dirty causing a re-raster on the next draw.
   *
   * Any `padding`s or `quality` set will be factored into the width
   */
  get width() {
    return Math.abs(this._getTotalWidth() * this.scale.x);
  }
  set width(t) {
    t /= Math.abs(this.scale.x), this._bitmap.width = t, this._originalWidth = t, this.flagDirty();
  }
  /**
   * Gets or sets the current height of the Raster graphic. Setting the height will cause the raster
   * to be flagged dirty causing a re-raster on the next draw.
   *
   * Any `padding` or `quality` set will be factored into the height
   */
  get height() {
    return Math.abs(this._getTotalHeight() * this.scale.y);
  }
  set height(t) {
    t /= Math.abs(this.scale.y), this._bitmap.height = t, this._originalHeight = t, this.flagDirty();
  }
  _getTotalWidth() {
    var t;
    return (((t = this._originalWidth) != null ? t : this._bitmap.width) + this.padding * 2) * 1;
  }
  _getTotalHeight() {
    var t;
    return (((t = this._originalHeight) != null ? t : this._bitmap.height) + this.padding * 2) * 1;
  }
  /**
   * Returns the local bounds of the Raster including the padding
   */
  get localBounds() {
    return F.fromDimension(this._getTotalWidth() * this.scale.x, this._getTotalHeight() * this.scale.y, v.Zero);
  }
  /**
   * Gets or sets the smoothing (anti-aliasing of the graphic). Setting the height will cause the raster
   * to be flagged dirty causing a re-raster on the next draw.
   */
  get smoothing() {
    return this._smoothing;
  }
  set smoothing(t) {
    this._smoothing = t, this.flagDirty();
  }
  /**
   * Gets or sets the fillStyle of the Raster graphic. Setting the fillStyle will cause the raster to be
   * flagged dirty causing a re-raster on the next draw.
   */
  get color() {
    return this._color;
  }
  set color(t) {
    this.flagDirty(), this._color = Pt(t, () => this.flagDirty());
  }
  /**
   * Gets or sets the strokeStyle of the Raster graphic. Setting the strokeStyle will cause the raster to be
   * flagged dirty causing a re-raster on the next draw.
   */
  get strokeColor() {
    return this._strokeColor;
  }
  set strokeColor(t) {
    this.flagDirty(), t && (this._strokeColor = Pt(t, () => this.flagDirty()));
  }
  /**
   * Gets or sets the line width of the Raster graphic. Setting the lineWidth will cause the raster to be
   * flagged dirty causing a re-raster on the next draw.
   */
  get lineWidth() {
    return this._lineWidth;
  }
  set lineWidth(t) {
    this._lineWidth = t, this.flagDirty();
  }
  get lineDash() {
    return this._lineDash;
  }
  set lineDash(t) {
    this._lineDash = t, this.flagDirty();
  }
  get padding() {
    return this._padding;
  }
  set padding(t) {
    this._padding = t, this.flagDirty();
  }
  /**
   * Rasterize the graphic to a bitmap making it usable as in excalibur. Rasterize is called automatically if
   * the graphic is {@apilink Raster.dirty} on the next {@apilink Graphic.draw} call
   */
  rasterize() {
    this._dirty = !1, this._ctx.clearRect(0, 0, this._getTotalWidth(), this._getTotalHeight()), this._ctx.save(), this._applyRasterProperties(this._ctx), this.execute(this._ctx), this._ctx.restore();
  }
  _applyRasterProperties(t) {
    var e, i, s, n;
    this._bitmap.width = this._getTotalWidth() * this.quality, this._bitmap.height = this._getTotalHeight() * this.quality, this._bitmap.setAttribute("filtering", this.filtering), this._bitmap.setAttribute("forceUpload", "true"), t.scale(this.quality, this.quality), t.translate(this.padding, this.padding), t.imageSmoothingEnabled = this.smoothing, t.lineWidth = this.lineWidth, t.setLineDash((e = this.lineDash) != null ? e : t.getLineDash()), t.lineCap = this.lineCap, t.strokeStyle = (s = (i = this.strokeColor) == null ? void 0 : i.toString()) != null ? s : "", t.fillStyle = (n = this.color) == null ? void 0 : n.toString();
  }
  _drawImage(t, e, i) {
    this._dirty && this.rasterize(), t.scale(1 / this.quality, 1 / this.quality), t.drawImage(this._bitmap, e, i);
  }
}
var hr = /* @__PURE__ */ ((r) => (r.Em = "em", r.Rem = "rem", r.Px = "px", r.Pt = "pt", r.Percent = "%", r))(hr || {}), lr = /* @__PURE__ */ ((r) => (r.Left = "left", r.Right = "right", r.Center = "center", r.Start = "start", r.End = "end", r))(lr || {}), cr = /* @__PURE__ */ ((r) => (r.Top = "top", r.Hanging = "hanging", r.Middle = "middle", r.Alphabetic = "alphabetic", r.Ideographic = "ideographic", r.Bottom = "bottom", r))(cr || {}), dr = /* @__PURE__ */ ((r) => (r.Normal = "normal", r.Italic = "italic", r.Oblique = "oblique", r))(dr || {}), ur = /* @__PURE__ */ ((r) => (r.LeftToRight = "ltr", r.RightToLeft = "rtl", r))(ur || {}), wt = /* @__PURE__ */ ((r) => (r.Pixel = "Pixel", r.Blended = "Blended", r))(wt || {});
function ei(r) {
  switch (r) {
    case "Pixel":
      return "Pixel";
    case "Blended":
      return "Blended";
    default:
      return;
  }
}
function es(r, t = T.Red, e, i, s, n, o = 1, a = "butt") {
  r.save(), r.beginPath(), r.lineWidth = o, r.lineCap = a, r.strokeStyle = t.toString(), r.moveTo(e, i), r.lineTo(s, n), r.closePath(), r.stroke(), r.restore();
}
function Eo(r, t = T.Red, e) {
  r.beginPath(), r.strokeStyle = t.toString(), r.arc(e.x, e.y, 5, 0, Math.PI * 2), r.closePath(), r.stroke();
}
function Io(r, t, e, i, s = 1) {
  const n = t ? t.toString() : "blue", o = i.scale(s);
  r.beginPath(), r.strokeStyle = n, r.moveTo(e.x, e.y), r.lineTo(e.x + o.x, e.y + o.y), r.closePath(), r.stroke();
}
function is(r, t, e, i, s, n = 5, o = T.White, a = null) {
  let h;
  if (typeof n == "number")
    h = { tl: n, tr: n, br: n, bl: n };
  else {
    const l = { tl: 0, tr: 0, br: 0, bl: 0 };
    for (const c in l)
      if (l.hasOwnProperty(c)) {
        const d = c;
        h[d] = n[d] || l[d];
      }
  }
  r.beginPath(), r.moveTo(t + h.tl, e), r.lineTo(t + i - h.tr, e), r.quadraticCurveTo(t + i, e, t + i, e + h.tr), r.lineTo(t + i, e + s - h.br), r.quadraticCurveTo(t + i, e + s, t + i - h.br, e + s), r.lineTo(t + h.bl, e + s), r.quadraticCurveTo(t, e + s, t, e + s - h.bl), r.lineTo(t, e + h.tl), r.quadraticCurveTo(t, e, t + h.tl, e), r.closePath(), a && (r.fillStyle = a.toString(), r.fill()), o && (r.strokeStyle = o.toString(), r.stroke());
}
function Ro(r, t, e, i, s = T.White, n = null) {
  r.beginPath(), r.arc(t, e, i, 0, Math.PI * 2), r.closePath(), n && (r.fillStyle = n.toString(), r.fill()), s && (r.strokeStyle = s.toString(), r.stroke());
}
const Mo = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  circle: Ro,
  line: es,
  point: Eo,
  roundRect: is,
  vector: Io
}, Symbol.toStringTag, { value: "Module" }));
class ii {
  constructor(t, e, i = 1) {
    this.builder = t, this.cleaner = e, this._pool = [], this._size = 0, this.grow(i);
  }
  /**
   * Grow the pool size by an amount
   * @param amount
   */
  grow(t) {
    if (t > 0) {
      this._size += t;
      for (let e = 0; e < t; e++)
        this._pool.push(this.builder());
    }
  }
  /**
   * Rent an object from the pool, optionally clean it. If not cleaned previous state may be set.
   *
   * The pool will automatically double if depleted
   * @param clean
   */
  rent(t = !1) {
    return this._pool.length === 0 && this.grow(this._size), t ? this.cleaner(this._pool.pop()) : this._pool.pop();
  }
  /**
   * Return an object to the pool
   * @param object
   */
  return(t) {
    this._pool.push(t);
  }
}
class Fo {
  constructor() {
    this._pool = new ii(
      () => j.identity(),
      (t) => t.reset(),
      100
    ), this._transforms = [], this._currentTransform = this._pool.rent(!0);
  }
  save() {
    this._transforms.push(this._currentTransform), this._currentTransform = this._currentTransform.clone(this._pool.rent());
  }
  restore() {
    this._pool.return(this._currentTransform), this._currentTransform = this._transforms.pop();
  }
  translate(t, e) {
    return this._currentTransform.translate(t, e);
  }
  rotate(t) {
    return this._currentTransform.rotate(t);
  }
  scale(t, e) {
    return this._currentTransform.scale(t, e);
  }
  reset() {
    this._currentTransform.reset();
  }
  set current(t) {
    this._currentTransform = t;
  }
  get current() {
    return this._currentTransform;
  }
}
class Do {
  constructor() {
    this.opacity = 1, this.z = 0, this.tint = T.White, this.material = null;
  }
}
class _r {
  constructor() {
    this._pool = new ii(
      () => new Do(),
      (t) => (t.opacity = 1, t.z = 0, t.tint = T.White, t.material = null, t),
      100
    ), this.current = this._pool.rent(!0), this._states = [];
  }
  _cloneState(t) {
    var e;
    return t.opacity = this.current.opacity, t.z = this.current.z, t.tint = (e = this.current.tint) == null ? void 0 : e.clone(), t.material = this.current.material, t;
  }
  save() {
    this._states.push(this.current), this.current = this._cloneState(this._pool.rent());
  }
  restore() {
    this._pool.return(this.current), this.current = this._states.pop();
  }
}
const zl = {
  Complete: "complete",
  Load: "load",
  LoadStart: "loadstart",
  Progress: "progress",
  Error: "error"
};
class Ii {
  /**
   * @param path          Path to the remote resource
   * @param responseType  The type to expect as a response: "" | "arraybuffer" | "blob" | "document" | "json" | "text";
   * @param bustCache     Whether or not to cache-bust requests
   */
  constructor(t, e, i = !1) {
    this.path = t, this.responseType = e, this.bustCache = i, this.data = null, this.logger = R.getInstance(), this.events = new X();
  }
  /**
   * Returns true if the Resource is completely loaded and is ready
   * to be drawn.
   */
  isLoaded() {
    return this.data !== null;
  }
  _cacheBust(t) {
    return /\?\w*=\w*/.test(t) ? t += "&__=" + Date.now() : t += "?__=" + Date.now(), t;
  }
  /**
   * Begin loading the resource and returns a promise to be resolved on completion
   */
  load() {
    return new Promise((t, e) => {
      if (this.data !== null) {
        this.logger.debug("Already have data for resource", this.path), this.events.emit("complete", this.data), t(this.data);
        return;
      }
      const i = new XMLHttpRequest();
      i.open("GET", this.bustCache ? this._cacheBust(this.path) : this.path, !0), i.responseType = this.responseType, i.addEventListener("loadstart", (s) => this.events.emit("loadstart", s)), i.addEventListener("progress", (s) => this.events.emit("progress", s)), i.addEventListener("error", (s) => this.events.emit("error", s)), i.addEventListener("load", (s) => this.events.emit("load", s)), i.addEventListener("load", () => {
        if (i.status !== 0 && i.status !== 200) {
          this.logger.error("Failed to load resource ", this.path, " server responded with error code", i.status), this.events.emit("error", i.response), e(new Error(i.statusText));
          return;
        }
        if (i.response instanceof Blob && i.response.type === "text/html") {
          const s = `Expected blob (usually image) data from the server when loading ${this.path}, but got HTML content instead!

Check your server configuration, for example Vite serves static files from the /public folder`;
          this.events.emit("error", i.response), e(new Error(s));
          return;
        }
        this.data = i.response, this.events.emit("complete", this.data), this.logger.debug("Completed loading resource", this.path), t(this.data);
      }), i.send();
    });
  }
}
class Bt extends nt {
  constructor(t) {
    var e, i;
    super(t), this._logger = R.getInstance(), this._dirty = !0, this.image = t.image;
    const { width: s, height: n } = t;
    this.sourceView = (e = t.sourceView) != null ? e : { x: 0, y: 0, width: s != null ? s : 0, height: n != null ? n : 0 }, this.destSize = (i = t.destSize) != null ? i : { width: s != null ? s : 0, height: n != null ? n : 0 }, this._updateSpriteDimensions(), this.image.ready.then(() => {
      this._updateSpriteDimensions();
    });
  }
  static from(t, e) {
    return new Bt({
      image: t,
      ...e
    });
  }
  get width() {
    return Math.abs(this.destSize.width * this.scale.x);
  }
  get height() {
    return Math.abs(this.destSize.height * this.scale.y);
  }
  set width(t) {
    t /= Math.abs(this.scale.x), this.destSize.width = t, super.width = Math.ceil(this.destSize.width);
  }
  set height(t) {
    t /= Math.abs(this.scale.y), this.destSize.height = t, super.height = Math.ceil(this.destSize.height);
  }
  _updateSpriteDimensions() {
    var t, e, i, s, n, o;
    const { width: a, height: h } = this.image;
    this.sourceView.width = ((t = this.sourceView) == null ? void 0 : t.width) || a, this.sourceView.height = ((e = this.sourceView) == null ? void 0 : e.height) || h, this.destSize.width = ((i = this.destSize) == null ? void 0 : i.width) || ((s = this.sourceView) == null ? void 0 : s.width) || a, this.destSize.height = ((n = this.destSize) == null ? void 0 : n.height) || ((o = this.sourceView) == null ? void 0 : o.height) || h, this.width = Math.ceil(this.destSize.width) * this.scale.x, this.height = Math.ceil(this.destSize.height) * this.scale.y;
  }
  _preDraw(t, e, i) {
    this.image.isLoaded() && this._dirty && (this._dirty = !1, this._updateSpriteDimensions()), super._preDraw(t, e, i);
  }
  _drawImage(t, e, i) {
    this.image.isLoaded() ? t.drawImage(
      this.image.image,
      this.sourceView.x,
      this.sourceView.y,
      this.sourceView.width,
      this.sourceView.height,
      e,
      i,
      this.destSize.width,
      this.destSize.height
    ) : this._logger.warnOnce(
      `ImageSource ${this.image.path} is not yet loaded and won't be drawn. Please call .load() or include in a Loader.

Read https://excaliburjs.com/docs/imagesource for more information.`
    );
  }
  clone() {
    return new Bt({
      image: this.image,
      sourceView: { ...this.sourceView },
      destSize: { ...this.destSize },
      ...this.cloneGraphicOptions()
    });
  }
}
var ft = /* @__PURE__ */ ((r) => (r.Clamp = "Clamp", r.Repeat = "Repeat", r.Mirror = "Mirror", r))(ft || {});
function Wt(r) {
  switch (r) {
    case "Clamp":
      return "Clamp";
    case "Repeat":
      return "Repeat";
    case "Mirror":
      return "Mirror";
    default:
      return "Clamp";
  }
}
const si = class Ct {
  constructor(t, e) {
    this._garbageCollector = e, this._textureMap = /* @__PURE__ */ new Map(), this._collect = (s) => {
      var n;
      if (this._gl) {
        const o = (n = s.dataset.originalSrc) != null ? n : s.constructor.name;
        return Ct._LOGGER.debug(`WebGL Texture for ${o} collected`), this.delete(s), !0;
      }
      return !1;
    };
    var i;
    this._gl = t, Ct._MAX_TEXTURE_SIZE = t.getParameter(t.MAX_TEXTURE_SIZE), this._garbageCollector && (Ct._LOGGER.debug("WebGL Texture collection interval:", this._garbageCollector.collectionInterval), (i = this._garbageCollector.garbageCollector) == null || i.registerCollector("texture", this._garbageCollector.collectionInterval, this._collect));
  }
  dispose() {
    for (const [t] of this._textureMap)
      this.delete(t);
    this._textureMap.clear(), this._gl = null;
  }
  /**
   * Get the WebGL Texture from a source image
   * @param image
   */
  get(t) {
    return this._textureMap.get(t);
  }
  /**
   * Returns whether a source image has been loaded as a texture
   * @param image
   */
  has(t) {
    return this._textureMap.has(t);
  }
  /**
   * Loads a graphic into webgl and returns it's texture info, a webgl context must be previously registered
   * @param image Source graphic
   * @param options {ImageSourceOptions} Optionally configure the ImageFiltering and ImageWrapping mode to apply to the loaded texture
   * @param forceUpdate Optionally force a texture to be reloaded, useful if the source graphic has changed
   */
  load(t, e, i = !1) {
    var s, n;
    const o = this._gl;
    if (!o)
      return null;
    const { filtering: a, wrapping: h } = { ...e };
    let l = null;
    if (this.has(t) && (l = this.get(t)), l)
      return i && (o.bindTexture(o.TEXTURE_2D, l), o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, o.RGBA, o.UNSIGNED_BYTE, t)), (s = this._garbageCollector) == null || s.garbageCollector.touch(t), l;
    l = o.createTexture(), Ct.checkImageSizeSupportedAndLog(t), o.bindTexture(o.TEXTURE_2D, l), o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0);
    let c;
    h && (typeof h == "string" ? c = {
      x: h,
      y: h
    } : c = {
      x: h.x,
      y: h.y
    });
    const { x: d, y: u } = c != null ? c : Ct.wrapping;
    switch (d) {
      case ft.Clamp:
        o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.CLAMP_TO_EDGE);
        break;
      case ft.Repeat:
        o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.REPEAT);
        break;
      case ft.Mirror:
        o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.MIRRORED_REPEAT);
        break;
      default:
        o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.CLAMP_TO_EDGE);
    }
    switch (u) {
      case ft.Clamp:
        o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.CLAMP_TO_EDGE);
        break;
      case ft.Repeat:
        o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.REPEAT);
        break;
      case ft.Mirror:
        o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.MIRRORED_REPEAT);
        break;
      default:
        o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.CLAMP_TO_EDGE);
    }
    const _ = a != null ? a : Ct.filtering;
    return o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, _ === wt.Pixel ? o.NEAREST : o.LINEAR), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, _ === wt.Pixel ? o.NEAREST : o.LINEAR), o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, o.RGBA, o.UNSIGNED_BYTE, t), this._textureMap.set(t, l), (n = this._garbageCollector) == null || n.garbageCollector.addCollectableResource("texture", t), l;
  }
  delete(t) {
    const e = this._gl;
    if (e && this.has(t)) {
      const i = this.get(t);
      i && (this._textureMap.delete(t), e.deleteTexture(i));
    }
  }
  /**
   * Takes an image and returns if it meets size criteria for hardware
   * @param image
   * @returns if the image will be supported at runtime
   */
  static checkImageSizeSupportedAndLog(t) {
    var e;
    const i = (e = t.dataset.originalSrc) != null ? e : "internal canvas bitmap";
    return t.width > Ct._MAX_TEXTURE_SIZE || t.height > Ct._MAX_TEXTURE_SIZE ? (Ct._LOGGER.error(
      `The image [${i}] provided to Excalibur is too large for the device's maximum texture size of (${Ct._MAX_TEXTURE_SIZE}x${Ct._MAX_TEXTURE_SIZE}) please resize to an image for excalibur to render properly.

Images will likely render as black rectangles.

Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`
    ), !1) : ((t.width > 4096 || t.height > 4096) && Ct._LOGGER.warn(
      `The image [${i}] provided to excalibur is too large may not work on all mobile devices, it is recommended you resize images to a maximum (4096x4096).

Images will likely render as black rectangles on some mobile platforms.

Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`
    ), !0);
  }
};
si._LOGGER = R.getInstance();
si.filtering = wt.Blended;
si.wrapping = { x: ft.Clamp, y: ft.Clamp };
si._MAX_TEXTURE_SIZE = 4096;
let Ge = si;
const z = {
  Filtering: "filtering",
  WrappingX: "wrapping-x",
  WrappingY: "wrapping-y"
};
class Nt {
  constructor(t, e, i) {
    this._logger = R.getInstance(), this.data = new Image(), this._readyFuture = new yt(), this.ready = this._readyFuture.promise, this.path = t;
    let s = !1, n;
    typeof e == "boolean" ? s = e : { filtering: i, wrapping: n, bustCache: s } = { ...e }, this._resource = new Ii(t, "blob", s), this.filtering = i != null ? i : this.filtering, typeof n == "string" ? this.wrapping = {
      x: n,
      y: n
    } : this.wrapping = n != null ? n : this.wrapping, t.endsWith(".gif") && this._logger.warn(
      `Use the ex.Gif type to load gifs, you may have mixed results with ${t} in ex.ImageSource. Fully supported: svg, jpg, bmp, and png`
    );
  }
  /**
   * The original size of the source image in pixels
   */
  get width() {
    return this.image.naturalWidth;
  }
  /**
   * The original height of the source image in pixels
   */
  get height() {
    return this.image.naturalHeight;
  }
  /**
   * Returns true if the Texture is completely loaded and is ready
   * to be drawn.
   */
  isLoaded() {
    return this._src || (this._src = this.data.src), !!this._src;
  }
  get image() {
    return this.data;
  }
  /**
   * Create an ImageSource from and HTML <image> tag element
   * @param image
   */
  static fromHtmlImageElement(t, e) {
    const i = new Nt("");
    if (i._src = "image-element", i.data = t, i.data.setAttribute("data-original-src", "image-element"), e != null && e.filtering ? i.data.setAttribute(z.Filtering, e == null ? void 0 : e.filtering) : i.data.setAttribute(z.Filtering, wt.Blended), e != null && e.wrapping) {
      let s;
      typeof e.wrapping == "string" ? s = {
        x: e.wrapping,
        y: e.wrapping
      } : s = {
        x: e.wrapping.x,
        y: e.wrapping.y
      }, i.data.setAttribute(z.WrappingX, s.x), i.data.setAttribute(z.WrappingY, s.y);
    } else
      i.data.setAttribute(z.WrappingX, ft.Clamp), i.data.setAttribute(z.WrappingY, ft.Clamp);
    return Ge.checkImageSizeSupportedAndLog(t), i._readyFuture.resolve(t), i;
  }
  static fromHtmlCanvasElement(t, e) {
    const i = new Nt("");
    if (i._src = "canvas-element-blob", i.data.setAttribute("data-original-src", "canvas-element-blob"), e != null && e.filtering ? i.data.setAttribute(z.Filtering, e == null ? void 0 : e.filtering) : i.data.setAttribute(z.Filtering, wt.Blended), e != null && e.wrapping) {
      let s;
      typeof e.wrapping == "string" ? s = {
        x: e.wrapping,
        y: e.wrapping
      } : s = {
        x: e.wrapping.x,
        y: e.wrapping.y
      }, i.data.setAttribute(z.WrappingX, s.x), i.data.setAttribute(z.WrappingY, s.y);
    } else
      i.data.setAttribute(z.WrappingX, ft.Clamp), i.data.setAttribute(z.WrappingY, ft.Clamp);
    return Ge.checkImageSizeSupportedAndLog(t), t.toBlob((s) => {
      const n = URL.createObjectURL(s);
      i.image.onload = () => {
        URL.revokeObjectURL(n), i.data = i.image, i._readyFuture.resolve(i.image);
      }, i.image.src = n;
    }), i;
  }
  static fromSvgString(t, e) {
    const i = new Blob([t], { type: "image/svg+xml" }), s = URL.createObjectURL(i);
    return new Nt(s, e);
  }
  /**
   * Should excalibur add a cache busting querystring? By default false.
   * Must be set before loading
   */
  get bustCache() {
    return this._resource.bustCache;
  }
  set bustCache(t) {
    this._resource.bustCache = t;
  }
  /**
   * Begins loading the image and returns a promise that resolves when the image is loaded
   */
  async load() {
    var t, e, i, s;
    if (this.isLoaded())
      return this.data;
    try {
      let n;
      if (this.path.includes("data:image/"))
        n = this.path;
      else {
        const h = await this._resource.load();
        n = URL.createObjectURL(h);
      }
      const o = new Image(), a = new yt();
      o.onload = () => a.resolve(), o.src = n, o.setAttribute("data-original-src", this.path), await a.promise, this.data = o, Ge.checkImageSizeSupportedAndLog(this.data);
    } catch (n) {
      throw `Error loading ImageSource from path '${this.path}' with error [${n.message}]`;
    }
    return this.data.setAttribute(z.Filtering, this.filtering), this.data.setAttribute(z.WrappingX, (e = (t = this.wrapping) == null ? void 0 : t.x) != null ? e : ft.Clamp), this.data.setAttribute(z.WrappingY, (s = (i = this.wrapping) == null ? void 0 : i.y) != null ? s : ft.Clamp), this._readyFuture.resolve(this.data), this.data;
  }
  /**
   * Build a sprite from this ImageSource
   */
  toSprite(t) {
    return Bt.from(this, t);
  }
  /**
   * Unload images from memory
   */
  unload() {
    this.data = new Image();
  }
}
class fs extends nt {
  constructor(t) {
    super(t), this._text = "", this.alphabet = "", this.shadow = void 0, this.caseInsensitive = !1, this.spacing = 0, this.lineHeight = void 0, this._logger = R.getInstance();
    const { alphabet: e, spriteSheet: i, caseInsensitive: s, spacing: n, shadow: o, lineHeight: a } = t;
    this.alphabet = e, this.spriteSheet = i, this.caseInsensitive = s != null ? s : this.caseInsensitive, this.spacing = n != null ? n : this.spacing, this.shadow = o != null ? o : this.shadow, this.lineHeight = a != null ? a : this.lineHeight;
  }
  _getCharacterSprites(t) {
    const e = [], i = this.caseInsensitive ? t.toLocaleLowerCase() : t, s = this.caseInsensitive ? this.alphabet.toLocaleLowerCase() : this.alphabet;
    for (let n = 0; n < i.length; n++) {
      const o = i[n];
      let a = s.indexOf(o);
      a === -1 && (a = 0, this._logger.warnOnce(`SpriteFont - Cannot find letter '${o}' in configured alphabet '${s}'.`), this._logger.warnOnce("There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged."));
      const h = this.spriteSheet.sprites[a];
      h ? e.push(h) : (this._logger.warnOnce(`SpriteFont - Cannot find sprite for '${o}' at index '${a}' in configured SpriteSheet`), this._logger.warnOnce("There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged."));
    }
    return e;
  }
  measureText(t, e) {
    const i = this._getLinesFromText(t, e), s = i.reduce((h, l) => h.length > l.length ? h : l), n = this._getCharacterSprites(s);
    let o = 0, a = 0;
    for (const h of n)
      o += h.width + this.spacing, a = Math.max(a, h.height);
    return F.fromDimension(o * this.scale.x, a * i.length * this.scale.y, v.Zero);
  }
  _drawImage(t, e, i, s) {
    var n;
    let o = 0, a = 0, h = 0;
    const l = this._getLinesFromText(this._text, s);
    for (const c of l) {
      for (const d of this._getCharacterSprites(c))
        d.draw(t, e + o, i + a), o += d.width + this.spacing, h = Math.max(h, d.height);
      o = 0, a += (n = this.lineHeight) != null ? n : h;
    }
  }
  render(t, e, i, s, n, o) {
    this._text = e;
    const a = this.measureText(e, o);
    this.width = a.width, this.height = a.height, this.shadow && (t.save(), t.translate(this.shadow.offset.x, this.shadow.offset.y), this._preDraw(t, s, n), this._drawImage(t, 0, 0, o), this._postDraw(t), t.restore()), this._preDraw(t, s, n), this._drawImage(t, 0, 0, o), this._postDraw(t);
  }
  clone() {
    return new fs({
      alphabet: this.alphabet,
      spriteSheet: this.spriteSheet,
      spacing: this.spacing
    });
  }
  _getLinesFromText(t, e) {
    var i;
    if (this._cachedText === t && this._cachedRenderWidth === e && ((i = this._cachedLines) != null && i.length))
      return this._cachedLines;
    const s = t.split(`
`);
    if (e == null)
      return s;
    for (let n = 0; n < s.length; n++) {
      let o = s[n], a = "";
      if (this.measureText(o).width > e) {
        for (; this.measureText(o).width > e; )
          a = o[o.length - 1] + a, o = o.slice(0, -1);
        s[n] = o, s[n + 1] = a;
      }
    }
    return this._cachedText = t, this._cachedLines = s, this._cachedRenderWidth = e, s;
  }
}
class Ri extends Bt {
  constructor(t) {
    super({
      image: t.image,
      sourceView: t.sourceView,
      destSize: { width: t.width, height: t.height },
      flipHorizontal: t.flipHorizontal,
      flipVertical: t.flipVertical,
      rotation: t.rotation,
      scale: t.scale,
      opacity: t.opacity,
      tint: t.tint,
      origin: t.origin
    }), this._ready = new yt(), this.ready = this._ready.promise, this._options = t, this.image.isLoaded() ? this._applyTiling() : this.image.ready.then(() => this._applyTiling());
  }
  static fromSprite(t, e) {
    return new Ri({
      sourceView: { ...t.sourceView },
      width: t.width,
      height: t.height,
      ...e,
      image: t.image
    });
  }
  _applyTiling() {
    const { width: t, height: e, filtering: i, wrapping: s } = { ...this._options }, n = document.createElement("canvas");
    n.width = this.sourceView.width, n.height = this.sourceView.height, n.getContext("2d").drawImage(
      this.image.image,
      this.sourceView.x,
      this.sourceView.y,
      this.sourceView.width,
      this.sourceView.height,
      0,
      0,
      this.sourceView.width,
      this.sourceView.height
    );
    const a = Nt.fromHtmlCanvasElement(n, {
      wrapping: s != null ? s : ft.Repeat,
      filtering: i
    });
    t && (this.destSize.width = t, this.sourceView.width = t), e && (this.destSize.height = e, this.sourceView.height = e), this.sourceView.x = 0, this.sourceView.y = 0, this.image = a, this.image.ready.then(() => this._ready.resolve());
  }
}
class Te {
  /**
   * Build a new sprite sheet from a list of sprites
   *
   * Use {@apilink SpriteSheet.fromImageSource} to create a SpriteSheet from an {@apilink ImageSource} organized in a grid
   * @param options
   */
  constructor(t) {
    this.sprites = [];
    const { sprites: e, rows: i, columns: s } = t;
    this.sprites = e, this.rows = i != null ? i : 1, this.columns = s != null ? s : this.sprites.length;
  }
  /**
   * Find a sprite by their x/y integer coordinates in the SpriteSheet, for example `getSprite(0, 0)` is the {@apilink Sprite} in the top-left
   * and `getSprite(1, 0)` is the sprite one to the right.
   * @param x
   * @param y
   */
  getSprite(t, e, i) {
    var s, n, o, a, h, l, c, d, u;
    if (t >= this.columns || t < 0)
      throw Error(`No sprite exists in the SpriteSheet at (${t}, ${e}), x: ${t} should be between 0 and ${this.columns - 1} columns`);
    if (e >= this.rows || e < 0)
      throw Error(`No sprite exists in the SpriteSheet at (${t}, ${e}), y: ${e} should be between 0 and ${this.rows - 1} rows`);
    const _ = t + e * this.columns, p = this.sprites[_];
    if (p) {
      if (i) {
        const g = p.clone();
        return g.flipHorizontal = (s = i.flipHorizontal) != null ? s : g.flipHorizontal, g.flipVertical = (n = i.flipVertical) != null ? n : g.flipVertical, g.width = (o = i.width) != null ? o : g.width, g.height = (a = i.height) != null ? a : g.height, g.rotation = (h = i.rotation) != null ? h : g.rotation, g.scale = (l = i.scale) != null ? l : g.scale, g.opacity = (c = i.opacity) != null ? c : g.opacity, g.tint = (d = i.tint) != null ? d : g.tint, g.origin = (u = i.origin) != null ? u : g.origin, g;
      }
      return p;
    }
    throw Error(`Invalid sprite coordinates (${t}, ${e})`);
  }
  /**
   * Find a sprite by their x/y integer coordinates in the SpriteSheet and configures tiling to repeat by default,
   * for example `getTiledSprite(0, 0)` is the {@apilink TiledSprite} in the top-left
   * and `getTiledSprite(1, 0)` is the sprite one to the right.
   *
   * Example:
   *
   * ```typescript
   * spriteSheet.getTiledSprite(1, 0, {
   * width: game.screen.width,
   * height: 200,
   * wrapping: {
   * x: ex.ImageWrapping.Repeat,
   * y: ex.ImageWrapping.Clamp
   * }
   * });
   * ```
   * @param x
   * @param y
   * @param options
   */
  getTiledSprite(t, e, i) {
    if (t >= this.columns || t < 0)
      throw Error(`No sprite exists in the SpriteSheet at (${t}, ${e}), x: ${t} should be between 0 and ${this.columns - 1} columns`);
    if (e >= this.rows || e < 0)
      throw Error(`No sprite exists in the SpriteSheet at (${t}, ${e}), y: ${e} should be between 0 and ${this.rows - 1} rows`);
    const s = t + e * this.columns, n = this.sprites[s];
    if (n)
      return Ri.fromSprite(n, i);
    throw Error(`Invalid sprite coordinates (${t}, ${e})`);
  }
  /**
   * Returns a sprite that has a new backing image the exact size of the sprite that tha is a copy of the original sprite slice.
   *
   * Useful if you need to apply effects, manipulate, or mutate the image and you don't want to disturb the original sprite sheet.
   *
   */
  async getSpriteAsStandalone(t, e) {
    if (t >= this.columns || t < 0)
      throw Error(`No sprite exists in the SpriteSheet at (${t}, ${e}), x: ${t} should be between 0 and ${this.columns - 1} columns`);
    if (e >= this.rows || e < 0)
      throw Error(`No sprite exists in the SpriteSheet at (${t}, ${e}), y: ${e} should be between 0 and ${this.rows - 1} rows`);
    const i = t + e * this.columns, s = this.sprites[i], n = document.createElement("canvas"), o = n.getContext("2d");
    if (n.width = s.width, n.height = s.height, !s)
      throw Error(`Invalid sprite coordinates (${t}, ${e})`);
    if (!o)
      throw Error("Unable to create canvas context");
    o.drawImage(
      s.image.image,
      s.sourceView.x,
      s.sourceView.y,
      s.sourceView.width,
      s.sourceView.height,
      0,
      0,
      s.sourceView.width,
      s.sourceView.height
    );
    const a = new Nt(n.toDataURL());
    return await a.load(), new Bt({
      image: a,
      sourceView: {
        x: 0,
        y: 0,
        width: s.width,
        height: s.height
      },
      destSize: {
        width: s.width,
        height: s.height
      }
    });
  }
  /**
   * Returns a new image exact size and copy of the original sprite slice.
   *
   * Useful if you need to apply effects, manipulate, or mutate the image and you don't want to disturb the original sprite sheet.
   */
  async getSpriteAsImage(t, e) {
    if (t >= this.columns || t < 0)
      throw Error(`No sprite exists in the SpriteSheet at (${t}, ${e}), x: ${t} should be between 0 and ${this.columns - 1} columns`);
    if (e >= this.rows || e < 0)
      throw Error(`No sprite exists in the SpriteSheet at (${t}, ${e}), y: ${e} should be between 0 and ${this.rows - 1} rows`);
    const i = t + e * this.columns, s = this.sprites[i], n = document.createElement("canvas"), o = n.getContext("2d");
    if (n.width = s.width, n.height = s.height, !s)
      throw Error(`Invalid sprite coordinates (${t}, ${e})`);
    if (!o)
      throw Error("Unable to create canvas context");
    o.drawImage(
      s.image.image,
      s.sourceView.x,
      s.sourceView.y,
      s.sourceView.width,
      s.sourceView.height,
      0,
      0,
      s.sourceView.width,
      s.sourceView.height
    );
    const a = new Image(s.width, s.height);
    return a.src = n.toDataURL(), await new Promise((h, l) => {
      a.onload = () => {
        h(a);
      }, a.onerror = (c) => {
        l(c);
      };
    });
  }
  /**
   * Create a sprite sheet from a sparse set of {@apilink SourceView} rectangles
   * @param options
   */
  static fromImageSourceWithSourceViews(t) {
    const e = t.sourceViews.map((i) => new Bt({
      image: t.image,
      sourceView: i
    }));
    return new Te({ sprites: e });
  }
  /**
   * Create a SpriteSheet from an {@apilink ImageSource} organized in a grid
   *
   * Example:
   * ```
   * const spriteSheet = SpriteSheet.fromImageSource({
   *   image: imageSource,
   *   grid: {
   *     rows: 5,
   *     columns: 2,
   *     spriteWidth: 32, // pixels
   *     spriteHeight: 32 // pixels
   *   },
   *   // Optionally specify spacing
   *   spacing: {
   *     // pixels from the top left to start the sprite parsing
   *     originOffset: {
   *       x: 5,
   *       y: 5
   *     },
   *     // pixels between each sprite while parsing
   *     margin: {
   *       x: 1,
   *       y: 1
   *     }
   *   }
   * })
   * ```
   * @param options
   */
  static fromImageSource(t) {
    var e;
    const i = [];
    t.spacing = (e = t.spacing) != null ? e : {};
    const {
      image: s,
      grid: { rows: n, columns: o, spriteWidth: a, spriteHeight: h },
      spacing: { originOffset: l, margin: c }
    } = t;
    let d, u;
    l instanceof v ? u = { x: l.x, y: l.y } : l && (u = { x: l.x, y: l.y }), c instanceof v ? d = { x: c.x, y: c.y } : c && (d = { x: c.x, y: c.y });
    const _ = { x: 0, y: 0, ...u }, p = { x: 0, y: 0, ...d };
    for (let g = 0; g < o; g++)
      for (let x = 0; x < n; x++)
        i[g + x * o] = new Bt({
          image: s,
          sourceView: {
            x: g * a + p.x * g + _.x,
            y: x * h + p.y * x + _.y,
            width: a,
            height: h
          },
          destSize: { height: h, width: a }
        });
    return new Te({
      sprites: i,
      rows: n,
      columns: o
    });
  }
  clone() {
    return new Te({
      sprites: this.sprites.map((t) => t.clone()),
      rows: this.rows,
      columns: this.columns
    });
  }
}
const Bo = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAYAAABS3GwHAAAAAXNSR0IB2cksfwAAAARnQU1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB+kLGhIwLEfXSw4AAAaVSURBVHja7d3BduQoDIVhas68/ytnNtOz6DPVBiEBtr9/l8RxMBVzQUiX1gAAAAC8iU/WjX5+fn5aa+3z+XxGruv9vez2RH/+6/v/dWBnu6PPOfsc+HO//qUr8Gb+vsub2qsYv4/Q0RF7VBFWK9jvzzPajurr7wIFAAU4eeS/+vrbCHg1Yr1tTm0t8f/PSQHQRIEWzllXrwF65/6jUayrOfnq/pxt/1W0K/t5q+/f2z8UANYAj5K0wTVBdP/ibnPn0TVT9XOu6q+rdlMAUIAT3+hoFChr5H5aVKR3P+H0NWH250cBQAFOfONH5/Kr5qzfdpZXPX9Wv1df3+wEA0B7X5Zlb4yfAgAAAAAAAAAAAABtUUXYroqqrAqv3uzPaEVSdUVVdf+0l/r/fOsfO8FoskETndKy8rdX5etX+eKMKuHq/lnlC5Tty5Q1I+EMB/TUA/S6IGS7JWR7aGatSZAzUo+ukUY9Wns/PwqAJgqU4LRW5X7c+8Zn+8yMRo2y5tJZUaDT3BdO+fuc4YA/rQFWvcmzUZUrH5vonDOqINVRmd5a6OznzaqZznaGy4oKUQBQgJVzxlkntqfMWXe3v2ofoDdas3o/gTMckJkLNDqHW5UbE/X2rM69OSVX6q0nxFgDAMDTfX4aXyAAAAAAAAAAAAAgwRcoK3do9f1Py2WKukJUV8BluVTscgnhCwS0CV+gX9/PeiOr3/is61fV/kazK3edWJ/9d6LKltX/FAAUYOWbeerJ9Nq/px7gyoWkuh0UABTgJLfe09szW4GVFZ26+8gf/fyjUScKAIwoQO/cf3TEqnZ7rp6LZ0dtshzgqkby7BG32oeIAgCZa4BRH5hVc9m7uxS0m0atnqYEFAAUoOdNyt75u7p/tD2nuCtX9+dVnPybE9tse66U4BS36t7npQAAAAAAAAAAAAAAAKA9+KT4U3x7Vp1ZVuVScer1VefyRrNEo6c/qggD2sJzgk/3Bdrlk/MUF4psp7mqfP5ZRzoKAOx0heALFPPHuaqXqPLoPKVibLQfKAAQUYC7V4S9rfZ298i/SgmitekUAMiIAlXP3bPcnk+Zo0fbmx3l2O30dno0jgKAArQXuRHvfo5R1+OskXS3896pnycFAAU40ffm1PtHozTZnpbZUbjRHePqqOCq+1IANNmghW+eXBycDAUAAAAAAAAA8DZ+/kVPoNkHANo7d4Lvmoe+K4cl68yvXdmeWbXFd8sAoABoskFfVHNbpSS7FS4rO7ZtPrmdAgB3qggbzS/ffe5vlQtG1jnEs897F2/OrH6Z/f+hAKAAFVGH6EhW7ZY82v5vc9tZt+TZ/smae896c+5yxMv6f6AAoADtxd6g2ecKtIdGvZ4aHaQAoABPise/3WW6WmmfpoAUABRg5c5flTt09CysXb5DVWuX6jn76LkFuxS3tx0UAMDz6y6u/t5b60AoANQDYL0X5+66CNEwCgAAAAAAAAAAzQ4rgv2bfV2zDwA09QB41rnNuyvtKAAoQIXvSm/Vf/b9s10bql0qVl9/9wq5bGc+CgAKUOm7En2DR9/ou7s2jPrjZNU+jyrJ6ufvVbRo+ygAKMAJfj6n1paujqKsUrK7tafXIY4CAE/aB9g9N101R89aC51+Us8uxf32NQUABajw7Vl97sDo2iHa/t6ReVQxen12ou2/2icZ7denKBIFACqy8mRlyoptXCEAUSDw+aEAAAAAAAAAANDOOh9gNEfjbVmGszXTu/vp6Z9X7y64fQBQAMRPTL/6/resz1NOinn7jjEFQJMLtGENcMr1WXnxV3POqE9P1ogePVd4tH6htz+z/X0oAJBZEVZd/T86AkVHntXPs6smePTnUT+gbJ+iq0q3amc7CgAKcOJIOTqnjo6s2b452ddFPVNno0yjI3S1x2d0LUcBgJ59gFmPyNmoS+8aYPS6rJ3a2X2AqDuEeL0oELBuJziau3JKnP609qzKBdq9ZqAAAAAAAAAAAAAAAAAA7dhcoOocmuzrs3JjsnKMTsthyvocRnOfstpVla0sFwhNRVggDz16umL0ZPCseoRo9uPo/UfrFaL9H72+Jbs+RGuIe38vek7zVU05BQAFyKgZrXIkm53j3sWfKOoC8dSTIGfPK3ZSPHDSKZGzc/TomiFrTbL6xPRVrhS7vUmj/lCzUSdrAGBmH6C6Nnb1PsDTPVB3nYeQve8RjS5ZAwDOB0A79NyFLOe3UV8pCgAKAJx6hlfWzr9cIAAAAAAAAAAv5R8sG/KSRHx9UQAAAABJRU5ErkJggg==", Mi = class gt {
  static registerDebugConfig(t) {
    gt.config = t;
  }
  static draw(t) {
    this._drawCalls.push(t);
  }
  static drawPoint(t, e) {
    gt.draw((i) => {
      i.debug.drawPoint(t, e);
    });
  }
  static drawLine(t, e, i) {
    gt.draw((s) => {
      s.debug.drawLine(t, e, i);
    });
  }
  static drawLines(t, e) {
    t.length > 1 && gt.draw((i) => {
      for (let s = 0; s < t.length - 1; s++)
        i.debug.drawLine(t[s], t[s + 1], e);
    });
  }
  static drawText(t, e) {
    gt.draw((i) => {
      i.debug.drawText(t, e);
    });
  }
  static drawPolygon(t, e) {
    t.length > 1 && gt.draw((i) => {
      const s = t[0], n = [...t, s];
      for (let o = 0; o < n.length - 1; o++)
        i.debug.drawLine(n[o], n[o + 1], e);
    });
  }
  static drawCircle(t, e, i) {
    const { color: s, strokeColor: n, width: o } = {
      color: T.Black,
      strokeColor: void 0,
      width: void 0,
      ...i
    };
    gt.draw((a) => {
      a.debug.drawCircle(t, e, s, n, o);
    });
  }
  static drawBounds(t, e) {
    gt.draw((i) => {
      i.debug.drawRect(t.left, t.top, t.width, t.height, e);
    });
  }
  static drawRay(t, e) {
    const { distance: i, color: s } = {
      color: T.Blue,
      distance: 10,
      ...e
    };
    gt.draw((n) => {
      n.z = gt.config.settings.z.ray;
      const o = t.pos, a = t.pos.add(t.dir.scale(i));
      n.debug.drawLine(o, a, { color: s });
    });
  }
  static flush(t) {
    t.save(), t.z = gt.z;
    for (const e of gt._drawCalls)
      e(t);
    t.restore(), gt.clear();
  }
  static clear() {
    gt._drawCalls.length = 0;
  }
};
Mi._drawCalls = [];
Mi.z = 1 / 0;
Mi.config = {
  // add some defaults
  settings: {
    text: {
      foreground: T.Black,
      background: T.Transparent,
      border: T.Transparent
    },
    z: {
      text: Number.POSITIVE_INFINITY,
      point: Number.MAX_SAFE_INTEGER - 1,
      ray: Number.MAX_SAFE_INTEGER - 1,
      dashed: Number.MAX_SAFE_INTEGER - 2,
      solid: Number.MAX_SAFE_INTEGER - 3
    }
  }
};
let St = Mi;
class fr {
  constructor() {
    this.fontSheet = Bo, this.size = 16, this.load();
  }
  get foregroundColor() {
    return St.config.settings.text.foreground;
  }
  get backgroundColor() {
    return St.config.settings.text.background;
  }
  get borderColor() {
    return St.config.settings.text.border;
  }
  load() {
    return this._imageSource = new Nt(this.fontSheet), this._imageSource.load().then(() => {
      this._spriteSheet = Te.fromImageSource({
        image: this._imageSource,
        grid: {
          rows: 8,
          columns: 16,
          spriteWidth: 10,
          // hack to avoid sample bleed
          spriteHeight: 24
        },
        spacing: {
          // hack to avoid sample bleed
          originOffset: { x: 2, y: 0 },
          margin: { x: 2, y: 0 }
        }
      }), this._spriteFont = new fs({
        alphabet: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~?",
        caseInsensitive: !1,
        spriteSheet: this._spriteSheet,
        spacing: 2
      });
    });
  }
  /**
   * Writes debug text using the built in sprint font
   * @param ctx
   * @param text
   * @param pos
   */
  write(t, e, i, s, n) {
    var o, a, h;
    if (this._imageSource.isLoaded()) {
      const l = t.getTransform().getPosition();
      t.save(), t.resetTransform(), t.z = St.config.settings.z.text, t.translate(l.x, l.y);
      const c = this._spriteFont.measureText(e), d = (o = s != null ? s : this.foregroundColor) != null ? o : T.Black, u = (a = n != null ? n : this.backgroundColor) != null ? a : T.Transparent;
      t.save(), t.z = St.config.settings.z.solid, t.drawRectangle(i, c.width, c.height, u, (h = this.borderColor) != null ? h : T.Transparent, 1), t.restore(), t.tint = d, this._spriteFont.render(t, e, null, i.x, i.y), t.restore();
    }
  }
}
class ko {
  constructor(t, e) {
    this._gl = t, this._texture = e;
  }
  use() {
    const t = this._gl;
    t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, this._texture);
  }
  disable() {
    const t = this._gl;
    t.bindTexture(t.TEXTURE_2D, null);
  }
}
class ri {
  constructor(t) {
    this.antialias = !1, this.samples = 1;
    var e, i;
    this._gl = t.gl, this.width = t.width, this.height = t.height, this.transparency = t.transparency, this.antialias = (e = t.antialias) != null ? e : this.antialias, this.samples = (i = t.samples) != null ? i : this._gl.getParameter(this._gl.MAX_SAMPLES);
    const s = this._gl;
    s.drawingBufferFormat ? this.bufferFormat = s.drawingBufferFormat : this.transparency ? this.bufferFormat = s.RGBA8 : this.bufferFormat = s.RGB8, this._setupRenderBuffer(), this._setupFramebuffer();
  }
  setResolution(t, e) {
    const i = this._gl;
    this.width = t, this.height = e, i.bindTexture(i.TEXTURE_2D, this._frameTexture), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, this.width, this.height, 0, i.RGBA, i.UNSIGNED_BYTE, null), this._renderBuffer && (i.bindRenderbuffer(i.RENDERBUFFER, this._renderBuffer), i.renderbufferStorageMultisample(
      i.RENDERBUFFER,
      Math.min(this.samples, i.getParameter(i.MAX_SAMPLES)),
      this.bufferFormat,
      this.width,
      this.height
    ));
  }
  get renderBuffer() {
    return this._renderBuffer;
  }
  get renderFrameBuffer() {
    return this._renderFrameBuffer;
  }
  get frameBuffer() {
    return this._frameBuffer;
  }
  get frameTexture() {
    return this._frameTexture;
  }
  _setupRenderBuffer() {
    if (this.antialias) {
      const t = this._gl;
      this._renderBuffer = t.createRenderbuffer(), this._renderFrameBuffer = t.createFramebuffer(), t.bindRenderbuffer(t.RENDERBUFFER, this._renderBuffer), t.renderbufferStorageMultisample(
        t.RENDERBUFFER,
        Math.min(this.samples, t.getParameter(t.MAX_SAMPLES)),
        this.bufferFormat,
        this.width,
        this.height
      ), t.bindFramebuffer(t.FRAMEBUFFER, this._renderFrameBuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, this._renderBuffer);
    }
  }
  _setupFramebuffer() {
    const t = this._gl;
    this._frameTexture = t.createTexture(), t.bindTexture(t.TEXTURE_2D, this._frameTexture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, this.width, this.height, 0, t.RGBA, t.UNSIGNED_BYTE, null), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE);
    const e = t.COLOR_ATTACHMENT0;
    this._frameBuffer = t.createFramebuffer(), t.bindFramebuffer(t.FRAMEBUFFER, this._frameBuffer), t.framebufferTexture2D(t.FRAMEBUFFER, e, t.TEXTURE_2D, this._frameTexture, 0), this.disable();
  }
  toRenderSource() {
    return this.renderBuffer && this.blitRenderBufferToFrameBuffer(), new ko(this._gl, this._frameTexture);
  }
  blitToScreen() {
    const t = this._gl;
    this._renderBuffer ? (t.bindFramebuffer(t.READ_FRAMEBUFFER, this.renderFrameBuffer), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), t.clearBufferfv(t.COLOR, 0, [0, 0, 1, 1]), t.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, t.COLOR_BUFFER_BIT, t.LINEAR)) : (t.bindFramebuffer(t.READ_FRAMEBUFFER, this.frameBuffer), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), t.clearBufferfv(t.COLOR, 0, [0, 0, 1, 1]), t.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, t.COLOR_BUFFER_BIT, t.LINEAR));
  }
  blitRenderBufferToFrameBuffer() {
    if (this._renderBuffer) {
      const t = this._gl;
      t.bindFramebuffer(t.READ_FRAMEBUFFER, this.renderFrameBuffer), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, this.frameBuffer), t.clearBufferfv(t.COLOR, 0, [0, 0, 1, 1]), t.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, t.COLOR_BUFFER_BIT, t.LINEAR);
    }
  }
  copyToTexture(t) {
    const e = this._gl;
    this._renderBuffer && this.blitRenderBufferToFrameBuffer(), e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer), e.bindTexture(e.TEXTURE_2D, t), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, 0, 0, this.width, this.height, 0);
  }
  /**
   * When called, all drawing gets redirected to this render target
   */
  use() {
    const t = this._gl;
    this.antialias ? t.bindFramebuffer(t.FRAMEBUFFER, this._renderFrameBuffer) : t.bindFramebuffer(t.FRAMEBUFFER, this._frameBuffer), t.viewport(0, 0, this.width, this.height);
  }
  /**
   * When called, all drawing is sent back to the canvas
   */
  disable() {
    const t = this._gl;
    t.bindFramebuffer(t.FRAMEBUFFER, null), t.bindTexture(t.TEXTURE_2D, null);
  }
}
const Lo = `#version 300 es
in vec2 a_position;
in vec4 a_color;
in float a_lengthSoFar;

out lowp vec4 v_color;
out float v_lengthSoFar;

uniform mat4 u_matrix;

void main() {
   // Set the vertex position using the ortho transform matrix
   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);

   // Passthrough the color
   v_color = a_color;

   // Passthrough the line length so far
   v_lengthSoFar = a_lengthSoFar;
}
`, Uo = `#version 300 es
precision mediump float;

// Color
in lowp vec4 v_color;
in float v_lengthSoFar;

out vec4 fragColor;

uniform bool u_dashed;

void main() {
  fragColor = v_color;
  if (u_dashed) {
    fragColor.a = smoothstep(0.5, 0.55, fract(v_lengthSoFar / 10.0)); // 10 pixel dashes
    fragColor.rgb *= fragColor.a;
  }
}
`;
class gr extends nt {
  constructor(t) {
    super(), this.color = T.Black, this.thickness = 1;
    const { start: e, end: i, color: s, thickness: n } = t;
    this.start = e, this.end = i, this.color = s != null ? s : this.color, this.thickness = n != null ? n : this.thickness, this._localBounds = this._calculateBounds();
    const { width: o, height: a } = this._localBounds;
    this.width = o, this.height = a;
  }
  get localBounds() {
    return this._localBounds;
  }
  _calculateBounds() {
    const t = this.end.sub(this.start).normal(), e = this.thickness / 2, i = [
      this.start.add(t.scale(e)),
      this.end.add(t.scale(e)),
      this.end.add(t.scale(-e)),
      this.start.add(t.scale(-e))
    ];
    return F.fromPoints(i);
  }
  _drawImage(t, e, i) {
    t.drawLine(this.start, this.end, this.color, this.thickness);
  }
  clone() {
    return new gr({
      start: this.start,
      end: this.end,
      color: this.color,
      thickness: this.thickness
    });
  }
}
class gs extends kt {
  constructor(t, e = !0) {
    super(), this.draw = t, this.useTransform = e;
  }
}
class ps extends kt {
  constructor(t) {
    super(), this.parallaxFactor = w(1, 1), this.parallaxFactor = t != null ? t : this.parallaxFactor;
  }
}
const Le = class et {
  static measureText(t, e, i) {
    const s = Se.getHashCode(e, t);
    if (et._MEASURE_CACHE.has(s))
      return et._MEASURE_CACHE.get(s);
    et._LOGGER.debug("Font text measurement cache miss");
    const n = e.measureTextWithoutCache(t, i);
    return et._MEASURE_CACHE.set(s, n), n;
  }
  static getTextInstance(t, e, i) {
    const s = Se.getHashCode(e, t, i);
    let n = et._TEXT_CACHE.get(s);
    return n || (n = new Se(e, t, i), et._TEXT_CACHE.set(s, n), et._LOGGER.debug("Font text instance cache miss")), et._TEXT_USAGE.set(n, performance.now()), n;
  }
  static checkAndClearCache() {
    const t = [], e = /* @__PURE__ */ new Set();
    for (const [s, n] of et._TEXT_USAGE.entries())
      if (n + et.FONT_TIMEOUT < performance.now())
        et._LOGGER.debug(`Text cache entry timed out ${s.text}`), t.push(s), s.dispose();
      else {
        const o = s.getHashCode(!1);
        e.add(o);
      }
    t.forEach((s) => {
      et._TEXT_USAGE.delete(s);
    }), this._TEXT_CACHE.clear();
    for (const [s] of this._TEXT_USAGE.entries())
      this._TEXT_CACHE.set(s.getHashCode(), s);
    const i = /* @__PURE__ */ new Map();
    for (const s of e)
      et._MEASURE_CACHE.has(s) && i.set(s, et._MEASURE_CACHE.get(s));
    this._MEASURE_CACHE.clear(), this._MEASURE_CACHE = i;
  }
  static get cacheSize() {
    return et._TEXT_USAGE.size;
  }
  /**
   * Force clear all cached text bitmaps
   */
  static clearCache() {
    for (const [t] of et._TEXT_USAGE.entries())
      t.dispose();
    et._TEXT_USAGE.clear(), et._TEXT_CACHE.clear(), et._MEASURE_CACHE.clear();
  }
};
Le.FONT_TIMEOUT = 500;
Le._LOGGER = R.getInstance();
Le._TEXT_USAGE = /* @__PURE__ */ new Map();
Le._TEXT_CACHE = /* @__PURE__ */ new Map();
Le._MEASURE_CACHE = /* @__PURE__ */ new Map();
let ss = Le;
function zo(r, t, e, i) {
  if (r.parent !== t.parent) {
    const c = r.clone(), d = r.globalPos.clone(), u = r.globalScale.clone(), _ = r.globalRotation;
    c.parent = t.parent, c.globalPos = d, c.globalScale = u, c.globalRotation = _, r = c;
  }
  let s = t.pos, n = t.scale, o = t.rotation;
  s = t.pos.scale(e).add(r.pos.scale(1 - e)), n = t.scale.scale(e).add(r.scale.scale(1 - e));
  const a = (1 - e) * Math.cos(r.rotation) + e * Math.cos(t.rotation), h = (1 - e) * Math.sin(r.rotation) + e * Math.sin(t.rotation);
  o = Math.atan2(h, a);
  const l = i != null ? i : new re();
  return l.setTransform(s, o, n), l;
}
class pr extends Ft {
  constructor(t) {
    super(), this.world = t, this.systemType = Mt.Draw, this._token = 0, this._sortedTransforms = [], this._zHasChanged = !1, this._zIndexUpdate = () => {
      this._zHasChanged = !0;
    }, this._targetInterpolationTransform = new re(), this.query = this.world.query([P, tt]), this.query.entityAdded$.subscribe((e) => {
      const i = e.get(P);
      this._sortedTransforms.push(i), i.zIndexChanged$.subscribe(this._zIndexUpdate), this._zHasChanged = !0;
    }), this.query.entityRemoved$.subscribe((e) => {
      const i = e.get(P);
      i.zIndexChanged$.unsubscribe(this._zIndexUpdate);
      const s = this._sortedTransforms.indexOf(i);
      s > -1 && this._sortedTransforms.splice(s, 1);
    });
  }
  get sortedTransforms() {
    return this._sortedTransforms;
  }
  initialize(t, e) {
    this._camera = e.camera, this._engine = e.engine;
  }
  preupdate() {
    this._graphicsContext = this._engine.graphicsContext, this._zHasChanged && (this._sortedTransforms.sort((t, e) => t.globalZ - e.globalZ), this._zHasChanged = !1);
  }
  update(t) {
    this._token++;
    let e;
    ss.checkAndClearCache(), this._graphicsContext.save(), this._camera && this._camera.draw(this._graphicsContext);
    for (let i = 0; i < this._sortedTransforms.length; i++) {
      const s = this._sortedTransforms[i], n = s.owner;
      if (n.hasTag("ex.offscreen") || (e = n.get(tt), !e.isVisible))
        continue;
      e.onPreTransformDraw && e.onPreTransformDraw(this._graphicsContext, t), n.events.emit("pretransformdraw", new Cn(this._graphicsContext, t, n)), s.coordPlane === at.Screen && this._graphicsContext.restore(), this._graphicsContext.save(), s.coordPlane === at.Screen && this._graphicsContext.translate(this._engine.screen.contentArea.left, this._engine.screen.contentArea.top), e.update(t, this._token);
      const o = n.get(ps);
      if (o) {
        const a = v.One.sub(o.parallaxFactor), h = this._camera.drawPos.scale(a);
        this._graphicsContext.translate(h.x, h.y);
      }
      this._applyTransform(n), e.material && (this._graphicsContext.material = e.material), e.onPreDraw && e.onPreDraw(this._graphicsContext, t), n.events.emit("predraw", new Qe(this._graphicsContext, t, n)), this._applyOpacity(n), this._drawGraphicsComponent(e, s), e.onPostDraw && e.onPostDraw(this._graphicsContext, t), n.events.emit("postdraw", new Je(this._graphicsContext, t, n)), this._graphicsContext.restore(), s.coordPlane === at.Screen && (this._graphicsContext.save(), this._camera && this._camera.draw(this._graphicsContext)), e.onPostTransformDraw && e.onPostTransformDraw(this._graphicsContext, t), n.events.emit("posttransformdraw", new Tn(this._graphicsContext, t, n));
    }
    this._graphicsContext.restore();
  }
  _drawGraphicsComponent(t, e) {
    var i, s;
    if (t.isVisible) {
      const n = t.flipHorizontal, o = t.flipVertical, a = t.current, h = (i = t.currentOptions) != null ? i : {};
      if (a) {
        let l = t.anchor, c = t.offset, d = 1, u = 1;
        h != null && h.anchor && (l = h.anchor), h != null && h.offset && (c = h.offset);
        const _ = e.globalScale;
        d *= a.scale.x * _.x, u *= a.scale.y * _.y;
        const p = -a.width * l.x + c.x * d, g = -a.height * l.y + c.y * u, x = a.flipHorizontal, m = a.flipVertical;
        if ((n || o) && (a.flipHorizontal = n ? !x : x, a.flipVertical = o ? !m : m), a == null || a.draw(this._graphicsContext, p, g), (n || o) && (a.flipHorizontal = x, a.flipVertical = m), (s = this._engine) != null && s.isDebug && this._engine.debug.graphics.showBounds) {
          this._graphicsContext.save();
          const f = w(p, g);
          if (a instanceof Ze)
            for (const b of a.members) {
              let C, S = v.Zero;
              b instanceof nt ? C = b : (C = b.graphic, S = b.offset), a.useAnchor ? C == null || C.localBounds.translate(f.add(S)).debug(this._graphicsContext, { color: this._engine.debug.graphics.boundsColor, dashed: !0 }) : C == null || C.localBounds.translate(S).debug(this._graphicsContext, { color: this._engine.debug.graphics.boundsColor, dashed: !0 });
            }
          else
            a == null || a.localBounds.translate(f).debug(this._graphicsContext, { color: this._engine.debug.graphics.boundsColor, dashed: !0 });
          this._graphicsContext.restore();
        }
      }
    }
  }
  /**
   * This applies the current entity transform to the graphics context
   * @param entity
   */
  _applyTransform(t) {
    const e = t.getAncestors();
    for (let i = 0; i < e.length; i++) {
      const s = e[i], n = s == null ? void 0 : s.get(P), o = s == null ? void 0 : s.get(U);
      if (n) {
        let a = n.get();
        if (o && !o.isSleeping && this._engine.fixedUpdateTimestep && o.__oldTransformCaptured && o.enableFixedUpdateInterpolate) {
          const h = this._engine.currentFrameLagMs / this._engine.fixedUpdateTimestep;
          a = zo(o.oldTransform, n.get(), h, this._targetInterpolationTransform);
        }
        this._graphicsContext.z = n.globalZ, this._graphicsContext.translate(a.pos.x, a.pos.y), this._graphicsContext.scale(a.scale.x, a.scale.y), this._graphicsContext.rotate(a.rotation);
      }
    }
  }
  _applyOpacity(t) {
    var e;
    const i = t.getAncestors();
    for (let s = 0; s < i.length; s++) {
      const n = i[s], o = n == null ? void 0 : n.get(tt);
      this._graphicsContext.opacity *= (e = o == null ? void 0 : o.opacity) != null ? e : 1;
    }
  }
}
pr.priority = Kt.Average;
class mr extends Ft {
  constructor(t) {
    super(), this.world = t, this.systemType = Mt.Draw, this.query = this.world.query([P, tt]);
  }
  initialize(t, e) {
    this._camera = e.camera, this._screen = e.engine.screen;
  }
  update() {
    this._worldBounds = this._screen.getWorldBounds();
    let t, e, i;
    for (let s = 0; s < this.query.entities.length; s++) {
      const n = this.query.entities[s];
      e = n.get(tt), t = n.get(P), i = n.get(ps);
      let o;
      if (i) {
        const h = v.One.sub(i.parallaxFactor);
        o = this._camera.pos.scale(h);
      }
      const a = this._isOffscreen(t, e, o);
      a && !n.hasTag("ex.offscreen") && (n.events.emit("exitviewport", new Un(n)), n.addTag("ex.offscreen")), !a && n.hasTag("ex.offscreen") && (n.events.emit("enterviewport", new zn(n)), n.removeTag("ex.offscreen"));
    }
  }
  _isOffscreen(t, e, i) {
    if (e.forceOnScreen)
      return !1;
    if (t.coordPlane === at.World) {
      let s = e.localBounds;
      i && (s = s.translate(i));
      const n = s.transform(t.get().matrix);
      return !this._worldBounds.overlaps(n);
    } else
      return !1;
  }
}
mr.priority = Kt.Higher;
class ms extends ti {
  constructor(t) {
    var e, i, s;
    super(t), this._radius = 0;
    const n = (e = t.lineWidth) != null ? e : t.strokeColor ? 1 : 0;
    this.padding = (i = t.padding) != null ? i : 2 + n / 2, this.radius = t.radius, this.filtering = (s = t.filtering) != null ? s : wt.Blended, this.rasterize();
  }
  get radius() {
    return this._radius;
  }
  set radius(t) {
    this._radius = t, this.width = this._radius * 2, this.height = this._radius * 2, this.flagDirty();
  }
  clone() {
    return new ms({
      radius: this.radius,
      ...this.cloneGraphicOptions(),
      ...this.cloneRasterOptions()
    });
  }
  execute(t) {
    this.radius > 0 && (t.beginPath(), t.arc(this.radius, this.radius, this.radius, 0, Math.PI * 2), this.color && t.fill(), this.strokeColor && t.stroke());
  }
}
class Fi extends ti {
  constructor(t) {
    super(t), this.width = t.width, this.height = t.height, this.rasterize();
  }
  clone() {
    return new Fi({
      width: this.width,
      height: this.height,
      ...this.cloneGraphicOptions(),
      ...this.cloneRasterOptions()
    });
  }
  execute(t) {
    this.color && t.fillRect(0, 0, this.width, this.height), this.strokeColor && t.strokeRect(0, 0, this.width, this.height);
  }
}
class xr extends ti {
  constructor(t) {
    super(t), this._points = [], this.points = t.points, this.filtering = wt.Blended, this.rasterize();
  }
  get points() {
    return this._points;
  }
  set points(t) {
    this._points = t;
    const e = this.minPoint;
    this.width = this._points.reduce((i, s) => Math.max(s.x, i), 0) - e.x, this.height = this._points.reduce((i, s) => Math.max(s.y, i), 0) - e.y, this.flagDirty();
  }
  get minPoint() {
    const t = this._points.reduce((i, s) => Math.min(s.x, i), 1 / 0), e = this._points.reduce((i, s) => Math.min(s.y, i), 1 / 0);
    return w(t, e);
  }
  clone() {
    return new xr({
      points: this.points.map((t) => t.clone()),
      ...this.cloneGraphicOptions(),
      ...this.cloneRasterOptions()
    });
  }
  execute(t) {
    if (this.points && this.points.length) {
      t.beginPath();
      const e = this.minPoint.negate(), i = this.points[0].add(e);
      t.moveTo(i.x, i.y), this.points.forEach((s) => {
        t.lineTo(s.x + e.x, s.y + e.y);
      }), t.lineTo(i.x, i.y), t.closePath(), this.color && t.fill(), this.strokeColor && t.stroke();
    }
  }
}
class xs extends ti {
  constructor(t = {}) {
    super(t), this._options = t;
  }
  /**
   * Return the 2D graphics context of this canvas
   */
  get ctx() {
    return this._ctx;
  }
  clone() {
    return new xs({
      ...this._options,
      ...this.cloneGraphicOptions(),
      ...this.cloneRasterOptions()
    });
  }
  execute(t) {
    var e, i;
    (e = this._options) != null && e.draw && ((i = this._options) == null || i.draw(t)), this._options.cache || this.flagDirty();
  }
}
var Ho = /* @__PURE__ */ ((r) => (r.Stretch = "stretch", r.Tile = "tile", r.TileFit = "tile-fit", r))(Ho || {});
class vr extends nt {
  constructor(t) {
    super(t), this._logger = R.getInstance(), this._config = t, this._imgSource = t.source, this._canvasA = document.createElement("canvas"), this._canvasB = document.createElement("canvas"), this._canvasC = document.createElement("canvas"), this._canvasD = document.createElement("canvas"), this._canvasE = document.createElement("canvas"), this._canvasF = document.createElement("canvas"), this._canvasG = document.createElement("canvas"), this._canvasH = document.createElement("canvas"), this._canvasI = document.createElement("canvas"), this._initialize(), this._imgSource.ready.then(() => {
      this._initialize();
    });
  }
  /**
   * Sets the target width of the 9 slice (pixels), and recalculates the 9 slice if desired (auto)
   * @param newWidth
   * @param auto
   */
  setTargetWidth(t, e = !1) {
    this._config.width = t, e && this._initialize();
  }
  /**
   * Sets the target height of the 9 slice (pixels), and recalculates the 9 slice if desired (auto)
   * @param newHeight
   * @param auto
   */
  setTargetHeight(t, e = !1) {
    this._config.height = t, e && this._initialize();
  }
  /**
   *  Sets the 9 slice margins (pixels), and recalculates the 9 slice if desired (auto)
   */
  setMargins(t, e, i, s, n = !1) {
    this._config.sourceConfig.leftMargin = t, this._config.sourceConfig.topMargin = e, this._config.sourceConfig.rightMargin = i, this._config.sourceConfig.bottomMargin = s, n && this._initialize();
  }
  /**
   *  Sets the stretching strategy for the 9 slice, and recalculates the 9 slice if desired (auto)
   *
   */
  setStretch(t, e, i = !1) {
    t === "horizontal" ? this._config.destinationConfig.horizontalStretch = e : t === "vertical" ? this._config.destinationConfig.verticalStretch = e : (this._config.destinationConfig.horizontalStretch = e, this._config.destinationConfig.verticalStretch = e), i && this._initialize();
  }
  /**
   *  Returns the config of the 9 slice
   */
  getConfig() {
    return this._config;
  }
  /**
   * Draws 1 of the 9 tiles based on parameters passed in
   * context is the ExcaliburGraphicsContext from the _drawImage function
   * destinationSize is the size of the destination image as a vector (width,height)
   * targetCanvas is the canvas to draw to
   * horizontalStretch and verticalStretch are the horizontal and vertical stretching strategies
   * marginW and marginH are optional margins for the 9 slice for positioning
   * @param context
   * @param targetCanvas
   * @param destinationSize
   * @param horizontalStretch
   * @param verticalStretch
   * @param marginWidth
   * @param marginHeight
   */
  _drawTile(t, e, i, s, n, o, a) {
    const h = o || 0, l = a || 0;
    let c, d, u, _;
    const p = this._getNumberOfTiles(e.width, i.x, s), g = this._getNumberOfTiles(e.height, i.y, n);
    for (let x = 0; x < p; x++)
      for (let m = 0; m < g; m++) {
        let { tempSize: f, tempPosition: b } = this._calculateParams(
          x,
          p,
          e.width,
          i.x,
          this._config.destinationConfig.horizontalStretch
        );
        c = f, d = b, { tempSize: f, tempPosition: b } = this._calculateParams(
          m,
          g,
          e.height,
          i.y,
          this._config.destinationConfig.verticalStretch
        ), u = f, _ = b, t.drawImage(
          e,
          0,
          0,
          e.width,
          e.height,
          h + d,
          l + _,
          c,
          u
        );
      }
  }
  /**
   *  Draws the 9 slices to the canvas
   */
  _drawImage(t, e, i) {
    this._imgSource.isLoaded() ? (this._drawTile(
      t,
      this._canvasA,
      new v(this._config.sourceConfig.leftMargin, this._config.sourceConfig.topMargin),
      this._config.destinationConfig.horizontalStretch,
      this._config.destinationConfig.verticalStretch
    ), this._drawTile(
      t,
      this._canvasB,
      new v(
        this._config.width - this._config.sourceConfig.leftMargin - this._config.sourceConfig.rightMargin,
        this._config.sourceConfig.topMargin
      ),
      this._config.destinationConfig.horizontalStretch,
      this._config.destinationConfig.verticalStretch,
      this._config.sourceConfig.leftMargin,
      0
    ), this._drawTile(
      t,
      this._canvasC,
      new v(this._config.sourceConfig.rightMargin, this._config.sourceConfig.topMargin),
      this._config.destinationConfig.horizontalStretch,
      this._config.destinationConfig.verticalStretch,
      this._config.width - this._config.sourceConfig.rightMargin,
      0
    ), this._drawTile(
      t,
      this._canvasD,
      new v(
        this._config.sourceConfig.leftMargin,
        this._config.height - this._config.sourceConfig.bottomMargin - this._config.sourceConfig.topMargin
      ),
      this._config.destinationConfig.horizontalStretch,
      this._config.destinationConfig.verticalStretch,
      0,
      this._config.sourceConfig.topMargin
    ), this._config.destinationConfig.drawCenter && this._drawTile(
      t,
      this._canvasE,
      new v(
        this._config.width - this._config.sourceConfig.leftMargin - this._config.sourceConfig.rightMargin,
        this._config.height - this._config.sourceConfig.bottomMargin - this._config.sourceConfig.topMargin
      ),
      this._config.destinationConfig.horizontalStretch,
      this._config.destinationConfig.verticalStretch,
      this._config.sourceConfig.leftMargin,
      this._config.sourceConfig.topMargin
    ), this._drawTile(
      t,
      this._canvasF,
      new v(
        this._config.sourceConfig.rightMargin,
        this._config.height - this._config.sourceConfig.bottomMargin - this._config.sourceConfig.topMargin
      ),
      this._config.destinationConfig.horizontalStretch,
      this._config.destinationConfig.verticalStretch,
      this._config.width - this._config.sourceConfig.rightMargin,
      this._config.sourceConfig.topMargin
    ), this._drawTile(
      t,
      this._canvasG,
      new v(this._config.sourceConfig.leftMargin, this._config.sourceConfig.bottomMargin),
      this._config.destinationConfig.horizontalStretch,
      this._config.destinationConfig.verticalStretch,
      0,
      this._config.height - this._config.sourceConfig.bottomMargin
    ), this._drawTile(
      t,
      this._canvasH,
      new v(
        this._config.width - this._config.sourceConfig.leftMargin - this._config.sourceConfig.rightMargin,
        this._config.sourceConfig.bottomMargin
      ),
      this._config.destinationConfig.horizontalStretch,
      this._config.destinationConfig.verticalStretch,
      this._config.sourceConfig.leftMargin,
      this._config.height - this._config.sourceConfig.bottomMargin
    ), this._drawTile(
      t,
      this._canvasI,
      new v(this._config.sourceConfig.rightMargin, this._config.sourceConfig.bottomMargin),
      this._config.destinationConfig.horizontalStretch,
      this._config.destinationConfig.verticalStretch,
      this._config.width - this._config.sourceConfig.rightMargin,
      this._config.height - this._config.sourceConfig.bottomMargin
    )) : this._logger.warnOnce(
      `NineSlice ImageSource ${this._imgSource.path} is not yet loaded and won't be drawn. Please call .load() or include in a Loader.

Read https://excaliburjs.com/docs/imagesource for more information.`
    );
  }
  /**
   * Slices the source sprite into the 9 slice canvases internally
   */
  _initialize() {
    this._sourceSprite = this._imgSource.image, this._canvasA.width = this._config.sourceConfig.leftMargin, this._canvasA.height = this._config.sourceConfig.topMargin;
    const t = this._canvasA.getContext("2d");
    t == null || t.drawImage(this._sourceSprite, 0, 0, this._canvasA.width, this._canvasA.height, 0, 0, this._canvasA.width, this._canvasA.height), this._canvasB.width = this._config.sourceConfig.width - this._config.sourceConfig.leftMargin - this._config.sourceConfig.rightMargin, this._canvasB.height = this._config.sourceConfig.topMargin;
    const e = this._canvasB.getContext("2d");
    e == null || e.drawImage(
      this._sourceSprite,
      this._config.sourceConfig.leftMargin,
      0,
      this._canvasB.width,
      this._canvasB.height,
      0,
      0,
      this._canvasB.width,
      this._canvasB.height
    ), this._canvasC.width = this._config.sourceConfig.rightMargin, this._canvasC.height = this._config.sourceConfig.topMargin;
    const i = this._canvasC.getContext("2d");
    i == null || i.drawImage(
      this._sourceSprite,
      this._sourceSprite.width - this._config.sourceConfig.rightMargin,
      0,
      this._canvasC.width,
      this._canvasC.height,
      0,
      0,
      this._canvasC.width,
      this._canvasC.height
    ), this._canvasD.width = this._config.sourceConfig.leftMargin, this._canvasD.height = this._config.sourceConfig.height - this._config.sourceConfig.topMargin - this._config.sourceConfig.bottomMargin;
    const s = this._canvasD.getContext("2d");
    s == null || s.drawImage(
      this._sourceSprite,
      0,
      this._config.sourceConfig.topMargin,
      this._canvasD.width,
      this._canvasD.height,
      0,
      0,
      this._canvasD.width,
      this._canvasD.height
    ), this._canvasE.width = this._config.sourceConfig.width - this._config.sourceConfig.leftMargin - this._config.sourceConfig.rightMargin, this._canvasE.height = this._config.sourceConfig.height - this._config.sourceConfig.topMargin - this._config.sourceConfig.bottomMargin;
    const n = this._canvasE.getContext("2d");
    n == null || n.drawImage(
      this._sourceSprite,
      this._config.sourceConfig.leftMargin,
      this._config.sourceConfig.topMargin,
      this._canvasE.width,
      this._canvasE.height,
      0,
      0,
      this._canvasE.width,
      this._canvasE.height
    ), this._canvasF.width = this._config.sourceConfig.rightMargin, this._canvasF.height = this._config.sourceConfig.height - this._config.sourceConfig.topMargin - this._config.sourceConfig.bottomMargin;
    const o = this._canvasF.getContext("2d");
    o == null || o.drawImage(
      this._sourceSprite,
      this._config.sourceConfig.width - this._config.sourceConfig.rightMargin,
      this._config.sourceConfig.topMargin,
      this._canvasF.width,
      this._canvasF.height,
      0,
      0,
      this._canvasF.width,
      this._canvasF.height
    ), this._canvasG.width = this._config.sourceConfig.leftMargin, this._canvasG.height = this._config.sourceConfig.bottomMargin;
    const a = this._canvasG.getContext("2d");
    a == null || a.drawImage(
      this._sourceSprite,
      0,
      this._config.sourceConfig.height - this._config.sourceConfig.bottomMargin,
      this._canvasG.width,
      this._canvasG.height,
      0,
      0,
      this._canvasG.width,
      this._canvasG.height
    ), this._canvasH.width = this._config.sourceConfig.width - this._config.sourceConfig.leftMargin - this._config.sourceConfig.rightMargin, this._canvasH.height = this._config.sourceConfig.bottomMargin;
    const h = this._canvasH.getContext("2d");
    h == null || h.drawImage(
      this._sourceSprite,
      this._config.sourceConfig.leftMargin,
      this._config.sourceConfig.height - this._config.sourceConfig.bottomMargin,
      this._canvasH.width,
      this._canvasH.height,
      0,
      0,
      this._canvasH.width,
      this._canvasH.height
    ), this._canvasI.width = this._config.sourceConfig.rightMargin, this._canvasI.height = this._config.sourceConfig.bottomMargin;
    const l = this._canvasI.getContext("2d");
    l == null || l.drawImage(
      this._sourceSprite,
      this._sourceSprite.width - this._config.sourceConfig.rightMargin,
      this._config.sourceConfig.height - this._config.sourceConfig.bottomMargin,
      this._canvasI.width,
      this._canvasI.height,
      0,
      0,
      this._canvasI.width,
      this._canvasI.height
    );
  }
  /**
   * Clones the 9 slice
   */
  clone() {
    return new vr(this._config);
  }
  /**
   * Returns the number of tiles
   */
  _getNumberOfTiles(t, e, i) {
    switch (i) {
      case "stretch":
        return 1;
      case "tile":
        return Math.ceil(e / t);
      case "tile-fit":
        return Math.ceil(e / t);
    }
  }
  /**
   * Returns the position and size of the tile
   */
  _calculateParams(t, e, i, s, n) {
    switch (n) {
      case "stretch":
        return {
          tempPosition: 0,
          tempSize: s
        };
      case "tile":
        return t === e - 1 ? {
          tempPosition: t * i,
          tempSize: i - (e * i - s)
        } : {
          tempPosition: t * i,
          tempSize: i
        };
      case "tile-fit":
        const o = s / e;
        return {
          tempPosition: t * o,
          tempSize: o
        };
    }
  }
}
class wr extends _s {
  constructor(t) {
    super({
      ...t,
      frames: t.animation.frames.slice(),
      strategy: t.animation.strategy,
      frameDuration: t.animation.frameDuration,
      speed: t.animation.speed,
      reverse: t.animation.isReversed
    }), this._ready = new yt(), this.ready = this._ready.promise, this._tiledWidth = 0, this._tiledHeight = 0, this._sourceView = {}, this._sourceView = { ...t.sourceView }, this._tiledWidth = t.width, this._tiledHeight = t.height;
    const e = [];
    for (let i = 0; i < this.frames.length; i++) {
      const s = this.frames[i].graphic;
      if (s && s instanceof Bt) {
        const n = new Ri({
          image: s.image,
          width: t.width,
          height: t.height,
          sourceView: { ...s.sourceView },
          wrapping: t.wrapping,
          filtering: t.filtering
        });
        this.frames[i].graphic = n, n.ready.then(() => {
          n.sourceView = { ...n.sourceView, ...this._sourceView };
        }), e.push(n.ready);
      }
    }
    Promise.all(e).then(() => this._ready.resolve());
  }
  static fromAnimation(t, e) {
    return new wr({
      width: t.width,
      height: t.height,
      ...e,
      animation: t
    });
  }
  _updateSourceView() {
    for (let t = 0; t < this.frames.length; t++) {
      const e = this.frames[t].graphic;
      e && e instanceof Bt && (e.sourceView = { ...e.sourceView, ...this._sourceView });
    }
  }
  get sourceView() {
    return Pt(this._sourceView, () => this._updateSourceView());
  }
  set sourceView(t) {
    this._sourceView = Pt(t, () => this._updateSourceView()), this._updateSourceView();
  }
  _updateWidthHeight() {
    for (let t = 0; t < this.frames.length; t++) {
      const e = this.frames[t].graphic;
      e && e instanceof Bt && (e.sourceView.height = this._tiledHeight || e.height, e.destSize.height = this._tiledHeight || e.height, e.sourceView.width = this._tiledWidth || e.width, e.destSize.width = this._tiledWidth || e.width);
    }
  }
  get width() {
    return this._tiledWidth;
  }
  get height() {
    return this._tiledHeight;
  }
  set width(t) {
    this._tiledWidth = t, this._updateWidthHeight();
  }
  set height(t) {
    this._tiledHeight = t, this._updateWidthHeight();
  }
}
const Oo = {
  pixelArtSampler: !1,
  nativeContextAntialiasing: !1,
  multiSampleAntialiasing: !0,
  filtering: wt.Blended,
  canvasImageRendering: "auto"
}, No = {
  pixelArtSampler: !0,
  nativeContextAntialiasing: !1,
  multiSampleAntialiasing: !0,
  filtering: wt.Blended,
  canvasImageRendering: "auto"
}, Di = class di {
  static clear() {
    di.DrawCallCount = 0, di.DrawnImagesCount = 0, di.RendererSwaps = 0;
  }
};
Di.DrawCallCount = 0;
Di.DrawnImagesCount = 0;
Di.RendererSwaps = 0;
let Z = Di;
const Y = 1e-4;
class Wo {
  constructor(t) {
    this._ex = t, this._debugText = new fr();
  }
  /**
   * Draw a debug rectangle to the context
   * @param x
   * @param y
   * @param width
   * @param height
   */
  drawRect(t, e, i, s) {
    this._ex.__ctx.save(), this._ex.__ctx.strokeStyle = "red", this._ex.__ctx.strokeRect(
      this._ex.snapToPixel ? ~~(t + Y) : t,
      this._ex.snapToPixel ? ~~(e + Y) : e,
      this._ex.snapToPixel ? ~~(i + Y) : i,
      this._ex.snapToPixel ? ~~(s + Y) : s
    ), this._ex.__ctx.restore();
  }
  drawLine(t, e, i = { color: T.Black }) {
    var s, n;
    this._ex.__ctx.save(), this._ex.__ctx.beginPath(), this._ex.__ctx.strokeStyle = (n = (s = i.color) == null ? void 0 : s.toString()) != null ? n : "", this._ex.__ctx.moveTo(
      this._ex.snapToPixel ? ~~(t.x + Y) : t.x,
      this._ex.snapToPixel ? ~~(t.y + Y) : t.y
    ), this._ex.__ctx.lineTo(
      this._ex.snapToPixel ? ~~(e.x + Y) : e.x,
      this._ex.snapToPixel ? ~~(e.y + Y) : e.y
    ), this._ex.__ctx.lineWidth = 2, this._ex.__ctx.stroke(), this._ex.__ctx.closePath(), this._ex.__ctx.restore();
  }
  drawPoint(t, e = { color: T.Black, size: 5 }) {
    this._ex.__ctx.save(), this._ex.__ctx.beginPath(), this._ex.__ctx.fillStyle = e.color.toString(), this._ex.__ctx.arc(
      this._ex.snapToPixel ? ~~(t.x + Y) : t.x,
      this._ex.snapToPixel ? ~~(t.y + Y) : t.y,
      e.size,
      0,
      Math.PI * 2
    ), this._ex.__ctx.fill(), this._ex.__ctx.closePath(), this._ex.__ctx.restore();
  }
  drawCircle(t, e, i, s, n) {
    this._ex.__ctx.save(), this._ex.__ctx.beginPath(), s && (this._ex.__ctx.strokeStyle = s.toString()), n && (this._ex.__ctx.lineWidth = n), this._ex.__ctx.fillStyle = i.toString(), this._ex.__ctx.arc(
      this._ex.snapToPixel ? ~~(t.x + Y) : t.x,
      this._ex.snapToPixel ? ~~(t.y + Y) : t.y,
      e,
      0,
      Math.PI * 2
    ), this._ex.__ctx.fill(), s && this._ex.__ctx.stroke(), this._ex.__ctx.closePath(), this._ex.__ctx.restore();
  }
  drawText(t, e) {
    this._debugText.write(this._ex, t, e);
  }
}
class ns {
  constructor(t) {
    this.useDrawSorting = !1, this.z = 0, this.backgroundColor = T.ExcaliburBlue, this._state = new _r(), this.snapToPixel = !1, this.debug = new Wo(this);
    const { canvasElement: e, context: i, enableTransparency: s, snapToPixel: n, antialiasing: o, backgroundColor: a } = t;
    if (this.__ctx = i != null ? i : e.getContext("2d", {
      alpha: s != null ? s : !0
    }), !this.__ctx)
      throw new Error("Cannot build new ExcaliburGraphicsContext2D for some reason!");
    this.backgroundColor = a != null ? a : this.backgroundColor, this.snapToPixel = n != null ? n : this.snapToPixel, this.smoothing = o != null ? o : this.smoothing;
  }
  get width() {
    return this.__ctx.canvas.width;
  }
  get height() {
    return this.__ctx.canvas.height;
  }
  get opacity() {
    return this._state.current.opacity;
  }
  set opacity(t) {
    this._state.current.opacity = t;
  }
  get tint() {
    return this._state.current.tint;
  }
  set tint(t) {
    this._state.current.tint = t;
  }
  get smoothing() {
    return this.__ctx.imageSmoothingEnabled;
  }
  set smoothing(t) {
    this.__ctx.imageSmoothingEnabled = t;
  }
  resetTransform() {
    this.__ctx.resetTransform();
  }
  updateViewport(t) {
  }
  drawImage(t, e, i, s, n, o, a, h, l) {
    if (s === 0 || n === 0)
      return;
    if (h === 0 || l === 0)
      return;
    if (t.width === 0 || t.height === 0)
      return;
    this.__ctx.globalAlpha = this.opacity;
    const c = [t, e, i, s, n, o, a, h, l].filter((d) => d !== void 0).map((d) => typeof d == "number" && this.snapToPixel ? ~~d : d);
    this.__ctx.drawImage.apply(this.__ctx, c), Z.DrawCallCount++, Z.DrawnImagesCount = 1;
  }
  drawLine(t, e, i, s = 1) {
    this.__ctx.save(), this.__ctx.beginPath(), this.__ctx.strokeStyle = i.toString(), this.__ctx.moveTo(
      this.snapToPixel ? ~~(t.x + Y) : t.x,
      this.snapToPixel ? ~~(t.y + Y) : t.y
    ), this.__ctx.lineTo(this.snapToPixel ? ~~(e.x + Y) : e.x, this.snapToPixel ? ~~(e.y + Y) : e.y), this.__ctx.lineWidth = s, this.__ctx.stroke(), this.__ctx.closePath(), this.__ctx.restore();
  }
  drawRectangle(t, e, i, s) {
    this.__ctx.save(), this.__ctx.fillStyle = s.toString(), this.__ctx.fillRect(
      this.snapToPixel ? ~~(t.x + Y) : t.x,
      this.snapToPixel ? ~~(t.y + Y) : t.y,
      this.snapToPixel ? ~~(e + Y) : e,
      this.snapToPixel ? ~~(i + Y) : i
    ), this.__ctx.restore();
  }
  drawCircle(t, e, i, s, n) {
    this.__ctx.save(), this.__ctx.beginPath(), s && (this.__ctx.strokeStyle = s.toString()), n && (this.__ctx.lineWidth = n), this.__ctx.fillStyle = i.toString(), this.__ctx.arc(
      this.snapToPixel ? ~~(t.x + Y) : t.x,
      this.snapToPixel ? ~~(t.y + Y) : t.y,
      e,
      0,
      Math.PI * 2
    ), this.__ctx.fill(), s && this.__ctx.stroke(), this.__ctx.closePath(), this.__ctx.restore();
  }
  /**
   * Save the current state of the canvas to the stack (transforms and opacity)
   */
  save() {
    this.__ctx.save(), this._state.save();
  }
  /**
   * Restore the state of the canvas from the stack
   */
  restore() {
    this.__ctx.restore(), this._state.restore();
  }
  /**
   * Translate the origin of the context by an x and y
   * @param x
   * @param y
   */
  translate(t, e) {
    this.__ctx.translate(this.snapToPixel ? ~~(t + Y) : t, this.snapToPixel ? ~~(e + Y) : e);
  }
  /**
   * Rotate the context about the current origin
   */
  rotate(t) {
    this.__ctx.rotate(t);
  }
  /**
   * Scale the context by an x and y factor
   * @param x
   * @param y
   */
  scale(t, e) {
    this.__ctx.scale(t, e);
  }
  getTransform() {
    const t = this.__ctx.getTransform(), e = new j();
    return e.data[0] = t.a, e.data[1] = t.b, e.data[2] = t.c, e.data[3] = t.d, e.data[4] = t.e, e.data[5] = t.f, e;
  }
  multiply(t) {
    this.__ctx.setTransform(this.__ctx.getTransform().multiply(t.toDOMMatrix()));
  }
  addPostProcessor(t) {
  }
  removePostProcessor(t) {
  }
  clearPostProcessors() {
  }
  updatePostProcessors(t) {
  }
  beginDrawLifecycle() {
  }
  endDrawLifecycle() {
  }
  set material(t) {
    this._state.current.material = t;
  }
  get material() {
    return this._state.current.material;
  }
  createMaterial(t) {
    return null;
  }
  clear() {
    this.__ctx.clearRect(0, 0, this.width, this.height), this.__ctx.fillStyle = this.backgroundColor.toString(), this.__ctx.fillRect(0, 0, this.width, this.height), Z.clear();
  }
  /**
   * Flushes the batched draw calls to the screen
   */
  flush() {
  }
  dispose() {
    this.__ctx = void 0;
  }
}
class Vo {
  constructor(t) {
    this.type = "static";
    const { gl: e, size: i, type: s, data: n } = t;
    if (this._gl = e, this.buffer = e.createBuffer(), this._maxFloats = e.getParameter(e.MAX_UNIFORM_BLOCK_SIZE) / 32, !n && !i)
      throw Error("Must either provide data or a size to the UniformBuffer");
    if (n ? this.bufferData = n : this.bufferData = new Float32Array(i), this.bufferData.length > this._maxFloats)
      throw Error(`UniformBuffer exceeds browsers allowed number of floats ${this._maxFloats}`);
    this.type = s != null ? s : this.type, e.bindBuffer(e.UNIFORM_BUFFER, this.buffer), e.bufferData(e.UNIFORM_BUFFER, this.bufferData, this.type === "static" ? e.STATIC_DRAW : e.DYNAMIC_DRAW);
  }
  /**
   * Bind this uniform buffer
   */
  bind() {
    const t = this._gl;
    t.bindBuffer(t.UNIFORM_BUFFER, this.buffer);
  }
  unbind() {
    const t = this._gl;
    t.bindBuffer(t.UNIFORM_BUFFER, null);
  }
  upload(t) {
    const e = this._gl;
    e.bindBuffer(e.UNIFORM_BUFFER, this.buffer), t ? e.bufferSubData(e.UNIFORM_BUFFER, 0, this.bufferData, 0, t) : e.bufferData(e.UNIFORM_BUFFER, this.bufferData, this.type === "static" ? e.STATIC_DRAW : e.DYNAMIC_DRAW);
  }
  dispose() {
    this._gl.deleteBuffer(this.buffer), this._gl = null;
  }
}
function rs(r, t) {
  switch (t) {
    case r.INT:
    case r.UNSIGNED_INT:
    case r.FLOAT:
      return 4;
    case r.SHORT:
      return 2;
    case r.UNSIGNED_SHORT:
      return 2;
    case r.BYTE:
      return 1;
    case r.UNSIGNED_BYTE:
      return 1;
    default:
      return 1;
  }
}
function br(r, t) {
  const e = `(?<type>[a-z0-9]+)\\s+${t};`, s = new RegExp(e, "g").exec(r);
  return (s == null ? void 0 : s.length) > 0;
}
function yr(r, t, e) {
  var i;
  const s = `(?<type>[a-z0-9]+)\\s+${e};`, o = new RegExp(s, "g").exec(t);
  switch ((i = o == null ? void 0 : o.groups) == null ? void 0 : i.type) {
    case "float":
    case "vec2":
    case "vec3":
    case "vec4":
      return r.FLOAT;
    case "int":
    case "ivec2":
    case "ivec3":
    case "ivec4":
      return r.INT;
    case "uint":
    case "uvec2":
    case "uvec3":
    case "uvec4":
      return r.UNSIGNED_INT;
    case "bool":
    case "bvec2":
    case "bvec3":
    case "bvec4":
      return r.BOOL;
    case "short":
      return r.SHORT;
    case "ushort":
      return r.UNSIGNED_SHORT;
    case "ubyte":
      return r.UNSIGNED_BYTE;
    case "byte":
      return r.BYTE;
    default:
      return r.FLOAT;
  }
}
function Cr(r, t) {
  switch (t) {
    case r.LOW_FLOAT:
    case r.HIGH_FLOAT:
    case r.FLOAT:
      return 1;
    case r.FLOAT_VEC2:
      return 2;
    case r.FLOAT_VEC3:
      return 3;
    case r.FLOAT_VEC4:
      return 4;
    case r.BYTE:
      return 1;
    case r.UNSIGNED_BYTE:
      return 1;
    case r.UNSIGNED_SHORT:
    case r.SHORT:
      return 1;
    default:
      return 1;
  }
}
function Tr(r, t) {
  switch (t) {
    case r.LOW_FLOAT:
    case r.HIGH_FLOAT:
    case r.FLOAT:
    case r.FLOAT_VEC2:
    case r.FLOAT_VEC3:
    case r.FLOAT_VEC4:
      return r.FLOAT;
    case r.BYTE:
      return r.BYTE;
    case r.UNSIGNED_BYTE:
      return r.UNSIGNED_BYTE;
    case r.SHORT:
      return r.SHORT;
    case r.UNSIGNED_SHORT:
      return r.UNSIGNED_SHORT;
    default:
      return r.FLOAT;
  }
}
function vs(r, t) {
  const e = (s) => {
    const n = `#version 300 es
    precision mediump float;
    out vec4 fragColor;
    void main() {
      float index = 1.01;
      %%complexity%%
    }`;
    let o = "";
    for (let a = 0; a < s; a++)
      a === 0 ? o += `if (index <= ${a}.5) {
` : o += `   else if (index <= ${a}.5) {
`, o += `      fragColor = vec4(1.0);
`, o += `   }
`;
    return n.replace("%%complexity%%", o);
  };
  let i = !1;
  do {
    const s = e(t), n = r.createShader(r.FRAGMENT_SHADER);
    r.shaderSource(n, s), r.compileShader(n), i = r.getShaderParameter(n, r.COMPILE_STATUS), i || (t = t / 2 | 0);
  } while (!i);
  return t;
}
const Hl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getAttributeComponentSize: Cr,
  getAttributePointerType: Tr,
  getGLTypeFromSource: yr,
  getGlTypeSizeBytes: rs,
  getMaxShaderComplexity: vs,
  isAttributeInSource: br
}, Symbol.toStringTag, { value: "Module" }));
function Go(r, t) {
  switch (t) {
    case r.FLOAT:
      return "uniform1f";
    case r.FLOAT_VEC2:
      return "uniform2f";
    case r.FLOAT_VEC3:
      return "uniform3f";
    case r.FLOAT_VEC4:
      return "uniform4f";
    case r.INT:
      return "uniform1i";
    case r.INT_VEC2:
      return "uniform2i";
    case r.INT_VEC3:
      return "uniform3i";
    case r.INT_VEC4:
      return "uniform4i";
    case r.BOOL:
      return "uniform1i";
    case r.BOOL_VEC2:
      return "uniform2i";
    case r.BOOL_VEC3:
      return "uniform3i";
    case r.BOOL_VEC4:
      return "uniform4i";
    case r.FLOAT_MAT2:
      return "uniform1f";
    case r.FLOAT_MAT3:
      return "uniform1f";
    case r.FLOAT_MAT4:
      return "uniform1f";
    case r.SAMPLER_2D:
      return "uniform1f";
    case r.SAMPLER_CUBE:
      return "uniform1f";
    case r.UNSIGNED_INT:
      return "uniform1ui";
    case r.UNSIGNED_INT_VEC2:
      return "uniform2ui";
    case r.UNSIGNED_INT_VEC3:
      return "uniform3ui";
    case r.UNSIGNED_INT_VEC4:
      return "uniform4ui";
    case r.FLOAT_MAT2x3:
      return "uniformMatrix2x3fv";
    case r.FLOAT_MAT2x4:
      return "uniformMatrix2x4fv";
    case r.FLOAT_MAT3x2:
      return "uniformMatrix3x2fv";
    case r.FLOAT_MAT3x4:
      return "uniformMatrix3x4fv";
    case r.FLOAT_MAT4x2:
      return "uniformMatrix4x2fv";
    case r.FLOAT_MAT4x3:
      return "uniformMatrix4x3fv";
    case r.SAMPLER_2D_ARRAY:
      return "uniform1fv";
    case r.SAMPLER_2D_ARRAY_SHADOW:
      return "uniform1f";
    case r.SAMPLER_CUBE_SHADOW:
      return "uniform1f";
    case r.INT_SAMPLER_2D:
      return "uniform1f";
    case r.INT_SAMPLER_3D:
      return "uniform1f";
    case r.INT_SAMPLER_CUBE:
      return "uniform1f";
    case r.INT_SAMPLER_2D_ARRAY:
      return "uniform1f";
    case r.UNSIGNED_INT_SAMPLER_2D:
      return "uniform1ui";
    default:
      throw new Error(`Unknown uniform type: ${t}`);
  }
}
const Sr = class He {
  /**
   * Create a shader program in excalibur
   * @param options specify shader vertex and fragment source
   */
  constructor(t) {
    this.name = "anonymous shader", this._logger = R.getInstance(), this._textures = /* @__PURE__ */ new Map(), this.attributes = {}, this._uniforms = {}, this._uniformBuffers = {}, this._compiled = !1, this._dirtyUniforms = !0, this._startingTextureSlot = 0, this.uniforms = Pt({}, () => this.flagUniformsDirty()), this.images = {};
    const { name: e, graphicsContext: i, vertexSource: s, fragmentSource: n, onPreLink: o, onPostCompile: a, uniforms: h, images: l, startingTextureSlot: c } = t;
    if (this.name = e != null ? e : this.name, !(i instanceof Qt))
      throw new Error(`ExcaliburGraphicsContext provided to a shader ${this.name} must be WebGL`);
    this._gl = i.__gl, this._startingTextureSlot = c != null ? c : this._startingTextureSlot, this._maxTextureSlots = this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS) - this._startingTextureSlot, this.vertexSource = s, this.fragmentSource = n, this.uniforms = Pt(h != null ? h : this.uniforms, () => this.flagUniformsDirty()), this.images = l != null ? l : this.images, Object.keys(this.images).length >= this._maxTextureSlots && this._logger.warn(
      `Max number texture slots ${this._maxTextureSlots} have been reached for material "${this.name}", no more textures will be uploaded due to hardware constraints.`
    ), this._textureLoader = i.textureLoader, this._onPreLink = o, this._onPostCompile = a;
  }
  /**
   * Flags uniforms need to be re-uploaded on the next call to .use()
   */
  flagUniformsDirty() {
    this._dirtyUniforms = !0;
  }
  /**
   * Returns whether the shader is compiled
   */
  get compiled() {
    return this._compiled;
  }
  /**
   * Deletes the webgl program from the gpu
   */
  dispose() {
    this._gl.deleteProgram(this.program), this._gl = null;
  }
  /**
   * Binds the shader program
   */
  use() {
    this._gl.useProgram(this.program), He._ACTIVE_SHADER_INSTANCE = this, this._dirtyUniforms && (this._setUniforms(), this._dirtyUniforms = !1), this._setImages();
  }
  unuse() {
    const t = this._gl;
    He._ACTIVE_SHADER_INSTANCE = null, t.useProgram(null);
  }
  isCurrentlyBound() {
    return He._ACTIVE_SHADER_INSTANCE === this;
  }
  _setUniforms() {
    const t = this._gl, e = Object.entries(this.uniforms);
    if (e.length) {
      const i = this.getUniformDefinitions();
      for (const [s, n] of e)
        if (n instanceof Float32Array)
          this.setUniformBuffer(s, n);
        else if (Array.isArray(n) && n[0] instanceof Float32Array && typeof n[1] == "number")
          this.setUniformBuffer(s, n[0], n[1]);
        else if (typeof n == "number")
          this.trySetUniformFloat(s, n);
        else if (typeof n == "boolean")
          this.trySetUniformBoolean(s, n);
        else if (n instanceof v)
          this.trySetUniformFloatVector(s, n);
        else if (n instanceof T)
          this.trySetUniformFloatColor(s, n);
        else if (n instanceof j)
          this.setUniformAffineMatrix(s, n);
        else {
          const o = i.find((a) => a.name === s);
          if (o) {
            const a = Go(t, o.glType);
            this.trySetUniform(a, s, n);
          } else
            this._logger.warnOnce(
              `Could not locate uniform named ${s}, this can happen if the uniform is unused in the shader code some GPUs will remove this as an optimization.`
            );
        }
    }
  }
  _loadImageSource(t) {
    const e = t.image, i = e.getAttribute(z.Filtering), s = i ? ei(i) : void 0, n = Wt(e.getAttribute(z.WrappingX)), o = Wt(e.getAttribute(z.WrappingY)), a = e.getAttribute("forceUpload") === "true", h = this._textureLoader.load(
      e,
      {
        filtering: s,
        wrapping: { x: n, y: o }
      },
      a
    );
    return e.removeAttribute("forceUpload"), this._textures.has(t) || this._textures.set(t, h), h;
  }
  _setImages(t = !1) {
    const e = this._gl;
    let i = this._startingTextureSlot;
    for (const [s, n] of Object.entries(this.images)) {
      if (!n.isLoaded()) {
        t || this._logger.warnOnce(
          `Image named ${s} in not loaded, nothing will be uploaded to the shader. Did you forget to add this to a loader? https://excaliburjs.com/docs/loaders/`
        );
        continue;
      }
      const o = this._loadImageSource(n);
      o || t || this._logger.warnOnce(`Image ${s} (${n.image.src}) could not be loaded for some reason in shader ${this.name}`), e.activeTexture(e.TEXTURE0 + i), e.bindTexture(e.TEXTURE_2D, o), this.trySetUniformInt(s, i), i++;
    }
  }
  /**
   * Compile the current shader against a webgl context
   */
  compile() {
    if (this._compiled)
      return this.program;
    const t = this._gl, e = this._compileShader(t, this.vertexSource, t.VERTEX_SHADER), i = this._compileShader(t, this.fragmentSource, t.FRAGMENT_SHADER);
    this.program = this._createProgram(t, e, i);
    const s = this.getAttributeDefinitions();
    for (const o of s)
      this.attributes[o.name] = o;
    const n = this.getUniformDefinitions();
    for (const o of n)
      this._uniforms[o.name] = o;
    return this._compiled = !0, this._onPostCompile && this._onPostCompile(this), t.useProgram(this.program), He._ACTIVE_SHADER_INSTANCE = this, this._dirtyUniforms && (this._setUniforms(), this._dirtyUniforms = !1), this._setImages(!0), this.unuse(), this.program;
  }
  /**
   * Get's the uniform definitons
   */
  getUniformDefinitions() {
    const t = this._gl, e = t.getProgramParameter(this.program, t.ACTIVE_UNIFORMS), i = [];
    for (let s = 0; s < e; s++) {
      const n = t.getActiveUniform(this.program, s), o = t.getUniformLocation(this.program, n.name);
      i.push({
        name: n.name,
        glType: n.type,
        location: o
      });
    }
    return i;
  }
  getAttributeDefinitions() {
    const t = this._gl, e = t.getProgramParameter(this.program, t.ACTIVE_ATTRIBUTES), i = [];
    for (let s = 0; s < e; s++) {
      const n = t.getActiveAttrib(this.program, s), o = t.getAttribLocation(this.program, n.name);
      i.push({
        name: n.name,
        glType: Tr(t, n.type),
        size: Cr(t, n.type),
        location: o,
        normalized: !1
      });
    }
    return i;
  }
  addImageSource(t, e) {
    Object.keys(this.images).length < this._maxTextureSlots ? this.images[t] = e : this._logger.warn(
      `Max number texture slots ${this._maxTextureSlots} have been reached for material "${this.name}", no more textures will be uploaded due to hardware constraints.`
    );
  }
  removeImageSource(t) {
    const e = this.images[t];
    e && (this._textureLoader.delete(e.image), delete this.images[t]);
  }
  /**
   * Set a texture in a gpu texture slot
   * @param slotNumber
   * @param texture
   */
  setTexture(t, e) {
    const i = this._gl;
    i.activeTexture(i.TEXTURE0 + t), i.bindTexture(i.TEXTURE_2D, e);
  }
  /**
   * Set a uniform buffer block with a Float32Array
   * @param name The of the binding block
   * @param data Float32Array
   * @param [bindingPoint]
   */
  setUniformBuffer(t, e, i = 0) {
    const s = this._gl, n = s.getUniformBlockIndex(this.program, t);
    n === s.INVALID_INDEX && this._logger.warnOnce(`Invalid block name ${t}`);
    let o;
    this._uniformBuffers[t] ? (o = this._uniformBuffers[t], o.bufferData.set(e), o.upload()) : (o = new Vo({
      gl: s,
      data: e
    }), this._uniformBuffers[t] = o), s.uniformBlockBinding(this.program, n, i), s.bindBufferBase(s.UNIFORM_BUFFER, i, o.buffer);
  }
  trySetUniformBuffer(t, e, i = 0) {
    return this._compiled ? this.isCurrentlyBound() ? this._gl.getUniformBlockIndex(this.program, t) ? (this.setUniformBuffer(t, e, i), !0) : !1 : (this._logger.warn(
      "Currently accessed shader instance is not the current active shader in WebGL, must call `shader.use()` before setting uniforms"
    ), !1) : (this._logger.warn(`Must compile shader before setting a uniform block ${t} at binding point ${i}`), !1);
  }
  /**
   * Set an integer uniform for the current shader
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  setUniformInt(t, e) {
    this.setUniform("uniform1i", t, ~~e);
  }
  /**
   * Set an integer uniform for the current shader, WILL NOT THROW on error.
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  trySetUniformInt(t, e) {
    return this.trySetUniform("uniform1i", t, ~~e);
  }
  /**
   * Set an integer array uniform for the current shader
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  setUniformIntArray(t, e) {
    this.setUniform("uniform1iv", t, e);
  }
  /**
   * Set an integer array uniform for the current shader, WILL NOT THROW on error.
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  trySetUniformIntArray(t, e) {
    return this.trySetUniform("uniform1iv", t, e);
  }
  /**
   * Set a boolean uniform for the current shader
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  setUniformBoolean(t, e) {
    this.setUniform("uniform1i", t, e ? 1 : 0);
  }
  /**
   * Set a boolean uniform for the current shader, WILL NOT THROW on error.
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  trySetUniformBoolean(t, e) {
    return this.trySetUniform("uniform1i", t, e ? 1 : 0);
  }
  /**
   * Set a float uniform for the current shader
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  setUniformFloat(t, e) {
    this.setUniform("uniform1f", t, e);
  }
  /**
   * Set a float uniform for the current shader, WILL NOT THROW on error.
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  trySetUniformFloat(t, e) {
    return this.trySetUniform("uniform1f", t, e);
  }
  /**
   * Set a float array uniform for the current shader
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  setUniformFloatArray(t, e) {
    this.setUniform("uniform1fv", t, e);
  }
  /**
   * Set a float array uniform for the current shader, WILL NOT THROW on error.
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  trySetUniformFloatArray(t, e) {
    return this.trySetUniform("uniform1fv", t, e);
  }
  /**
   * Set a {@apilink Vector} uniform for the current shader
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  setUniformFloatVector(t, e) {
    this.setUniform("uniform2f", t, e.x, e.y);
  }
  /**
   * Set a {@apilink Vector} uniform for the current shader, WILL NOT THROW on error.
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  trySetUniformFloatVector(t, e) {
    return this.trySetUniform("uniform2f", t, e.x, e.y);
  }
  /**
   * Set a {@apilink Color} uniform for the current shader
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  setUniformFloatColor(t, e) {
    this.setUniform("uniform4f", t, e.r / 255, e.g / 255, e.b / 255, e.a);
  }
  /**
   * Set a {@apilink Color} uniform for the current shader, WILL NOT THROW on error.
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  trySetUniformFloatColor(t, e) {
    return this.trySetUniform("uniform4f", t, e.r / 255, e.g / 255, e.b / 255, e.a);
  }
  /**
   * Set an {@apilink Matrix} uniform for the current shader
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  setUniformMatrix(t, e) {
    this.setUniform("uniformMatrix4fv", t, !1, e.data);
  }
  setUniformAffineMatrix(t, e) {
    this.setUniform("uniformMatrix4fv", t, !1, [
      e.data[0],
      e.data[1],
      0,
      0,
      e.data[2],
      e.data[3],
      0,
      0,
      0,
      0,
      1,
      0,
      e.data[4],
      e.data[5],
      0,
      1
    ]);
  }
  /**
   * Set an {@apilink Matrix} uniform for the current shader, WILL NOT THROW on error.
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  trySetUniformMatrix(t, e) {
    return this.trySetUniform("uniformMatrix4fv", t, !1, e.data);
  }
  /**
   * Set any available uniform type in webgl
   *
   * For example setUniform('uniformMatrix2fv', 'u_my2x2_mat`, ...);
   */
  setUniform(t, e, ...i) {
    if (!this._compiled)
      throw Error(`Must compile shader before setting a uniform ${t}:${e}`);
    if (!this.isCurrentlyBound())
      throw Error(
        "Currently accessed shader instance is not the current active shader in WebGL, must call `shader.use()` before setting uniforms"
      );
    const n = this._gl.getUniformLocation(this.program, e);
    if (n) {
      const o = [n, ...i];
      this._gl[t].apply(this._gl, o);
    } else
      throw Error(
        `Uniform ${t}:${e} doesn't exist or is not used in the shader source code, unused uniforms are optimized away by most browsers`
      );
  }
  /**
   * Set any available uniform type in webgl. Will try to set the uniform, will return false if the uniform didn't exist,
   * true if it was set.
   *
   * WILL NOT THROW on error
   *
   * For example setUniform('uniformMatrix2fv', 'u_my2x2_mat`, ...);
   *
   */
  trySetUniform(t, e, ...i) {
    if (!this._compiled)
      return this._logger.warn(`Must compile shader before setting a uniform ${t}:${e}`), !1;
    if (!this.isCurrentlyBound())
      return this._logger.warn(
        "Currently accessed shader instance is not the current active shader in WebGL, must call `shader.use()` before setting uniforms"
      ), !1;
    const n = this._gl.getUniformLocation(this.program, e);
    if (n) {
      const o = [n, ...i];
      this._gl[t].apply(this._gl, o);
    } else
      return !1;
    return !0;
  }
  _createProgram(t, e, i) {
    const s = t.createProgram();
    if (s === null)
      throw Error("Could not create graphics shader program");
    if (t.attachShader(s, e), t.attachShader(s, i), this._onPreLink && this._onPreLink(s), t.linkProgram(s), !t.getProgramParameter(s, t.LINK_STATUS))
      throw Error(`Could not link the program: [${t.getProgramInfoLog(s)}]`);
    return s;
  }
  _compileShader(t, e, i) {
    const s = t.VERTEX_SHADER === i ? "vertex" : "fragment", n = t.createShader(i);
    if (n === null)
      throw Error(`Could not build shader: [${e}]`);
    if (t.shaderSource(n, e), t.compileShader(n), !t.getShaderParameter(n, t.COMPILE_STATUS)) {
      const a = t.getShaderInfoLog(n);
      throw Error(`Could not compile ${s} shader:

${a}${this._processSourceForError(e, a)}`);
    }
    return n;
  }
  _processSourceForError(t, e) {
    if (!t)
      return e;
    const i = t.split(`
`), s = e.search(/\d:\d/), n = e.indexOf(" ", s), [o, a] = e.slice(s, n).split(":").map((h) => Number(h));
    for (let h = 0; h < i.length; h++)
      i[h] = `${h + 1}: ${i[h]}${a === h + 1 ? " <----- ERROR!" : ""}`;
    return `

Source:
` + i.join(`
`);
  }
};
Sr._ACTIVE_SHADER_INSTANCE = null;
let Lt = Sr;
const qo = `#version 300 es
precision mediump float;

uniform float deltaMs;
uniform float maxLifeMs;
uniform vec2 gravity;
uniform vec2 focus;
uniform float focusAccel;
uniform mat4 u_matrix;
uniform mat4 u_transform;
uniform float startSize;
uniform float endSize;
// uniform sampler2D obstacle;

layout(location=0)in vec2 position;
layout(location=1)in vec2 velocity;
layout(location=2)in float rotation;
layout(location=3)in float angularVelocity;
layout(location=4)in float lifeMs;

// TODO z index to handle buffer wrapping?

// DO NOT RE-ORDER
out vec2 finalPosition;
out vec2 finalVelocity;
out float finalRotation;
out float finalAngularVelocity;
out float finalLifeMs;
void main(){
  // Evolve particle
  float seconds = deltaMs / 1000.;
  // euler integration
  // Weird artifact of re-using the same buffer layout for update/draw
  // we need differently named variables
  vec2 finalGravity = gravity + normalize(focus - position) * focusAccel;
  finalVelocity = velocity + finalGravity * seconds;
  finalPosition = position + velocity * seconds + finalGravity * .5 * seconds * seconds;
  finalRotation = rotation + angularVelocity * seconds;
  finalAngularVelocity = angularVelocity;
  finalLifeMs = clamp(lifeMs - deltaMs, 0., maxLifeMs);

  // Collision mask sampling
  // vec2 samplePoint = finalPosition / vec2(width, height);
  // vec4 collides = texture(obstacle, samplePoint);
  // if (distance(collides,vec4(0.)) > .01) {
  //   // non opaque means we collide! recalc final pos/vel
  //   vec2 newVelocity = velocity * -.1;// lose energy
  //   finalVelocity = newVelocity + gravity * seconds;
  //   finalPosition = position + newVelocity * seconds + gravity * .5 * seconds * seconds;
  // }

  float lifePercent = finalLifeMs / maxLifeMs;
  vec2 transformedPos = (u_matrix * u_transform * vec4(finalPosition,0.,1.)).xy;
  float scale = sqrt(u_transform[0][0] * u_transform[0][0] + u_transform[1][1] * u_transform[1][1]);
  gl_Position = vec4(transformedPos, 1.0 - lifePercent, 1.); // use life percent to sort z
  gl_PointSize = mix(startSize, endSize, 1.0 - lifePercent) * scale;
}`, Xo = `#version 300 es
precision mediump float;

uniform sampler2D graphic;
uniform bool useTexture;
uniform float maxLifeMs;

uniform vec4 beginColor;
uniform vec4 endColor;
uniform bool fade;
uniform float startOpacity;

in float finalRotation;
in float finalLifeMs;
out vec4 fragColor;

void main(){

  float lifePct = finalLifeMs / maxLifeMs;

  if (useTexture) {
    /** Draw texture */
    if (lifePct <= 0.) discard;
    float mid = .5;
    float cosine = cos(finalRotation);
    float sine = sin(finalRotation);
    vec2 rotated = vec2(cosine * (gl_PointCoord.x - mid) + sine * (gl_PointCoord.y - mid) + mid,
                        cosine * (gl_PointCoord.y - mid) - sine * (gl_PointCoord.x - mid) + mid);
    vec4 color = texture(graphic, rotated);
    fragColor = color * (fade ? lifePct : 1.0);
  } else {
    /** Draw circle */
    if (lifePct <= 0.) discard;
    vec2 uv = gl_PointCoord.xy * 2.0 - 1.0;
    float dist = 1.0 - length(uv);
    float edge = fwidth(dot(uv, uv));
    float circle = smoothstep(-edge/2.0, edge/2.0, dist);
    vec3 color = mix(beginColor.rgb, endColor.rgb, 1.0 - lifePct);
    fragColor.rgb = color;
    fragColor.a = startOpacity * circle * (fade ? lifePct : 1.0);// * mix(beginColor.a, endColor.a, 1.0 - lifePct);
    fragColor.rgb *= fragColor.a;
  }
}`, ve = class ee {
  static integrate(t, e, i, s) {
    const n = s / 1e3;
    e.vel.addEqual(i.scale(n, ee._ACC)), e.vel.setTo(D(e.vel.x, -e.maxVel.x, e.maxVel.x), D(e.vel.y, -e.maxVel.y, e.maxVel.y)), t.pos.add(e.vel.scale(n, ee._VEL), ee._POS).addEqual(i.scale(0.5 * n * n, ee._VEL_ACC)), e.angularVelocity += e.torque * (1 / e.inertia) * n;
    const o = t.rotation + e.angularVelocity * n;
    t.scale.add(e.scaleFactor.scale(n, this._SCALE_FACTOR), ee._SCALE), t.get().setTransform(ee._POS, o, ee._SCALE);
  }
};
ve._POS = new v(0, 0);
ve._SCALE = new v(1, 1);
ve._ACC = new v(0, 0);
ve._VEL = new v(0, 0);
ve._VEL_ACC = new v(0, 0);
ve._SCALE_FACTOR = new v(0, 0);
let Ar = ve;
class ws extends Rt {
  constructor(t) {
    super(), this.beginColor = T.White, this.endColor = T.White, this.life = 300, this.fade = !1, this._rRate = 1, this._gRate = 1, this._bRate = 1, this._aRate = 0, this._currentColor = T.White, this.size = 5, this.sizeRate = 0, this.visible = !0, this.isOffscreen = !1, this.particleTransform = "global", this.name = `Particle#${this.id}`, this.addComponent(this.transform = new P()), this.addComponent(this.motion = new N()), this.addComponent(this.graphics = new tt()), this.configure(t);
  }
  registerEmitter(t) {
    if (this._emitter = t, this.particleTransform === "global") {
      const e = this._emitter.transform.globalPos;
      this.transform.pos = this.transform.pos.add(e), this.motion.vel = this.motion.vel.rotate(this._emitter.transform.globalRotation);
    }
  }
  configure(t) {
    var e, i, s, n, o, a, h, l, c, d, u, _, p, g, x;
    this.particleTransform = (e = t.transform) != null ? e : this.particleTransform, this.life = (i = t.life) != null ? i : this.life, this.fade = (s = t.fade) != null ? s : this.fade, this.size = (n = t.size) != null ? n : this.size, this.endColor = (o = t.endColor) != null ? o : this.endColor.clone(), this.beginColor = (a = t.beginColor) != null ? a : this.beginColor.clone(), this._currentColor = this.beginColor.clone(), this.graphic = t.graphic, this.graphics.opacity = (h = t.opacity) != null ? h : this.graphics.opacity, this.transform.pos = (l = t.pos) != null ? l : this.transform.pos, this.transform.rotation = (c = t.rotation) != null ? c : 0, this.transform.scale = w(1, 1), this.transform.z = (d = t.z) != null ? d : 0, this.motion.vel = (u = t.vel) != null ? u : this.motion.vel, this.motion.angularVelocity = (_ = t.angularVelocity) != null ? _ : 0, this.motion.acc = (p = t.acc) != null ? p : this.motion.acc, this._rRate = (this.endColor.r - this.beginColor.r) / this.life, this._gRate = (this.endColor.g - this.beginColor.g) / this.life, this._bRate = (this.endColor.b - this.beginColor.b) / this.life, this._aRate = this.graphics.opacity / this.life, this.startSize = (g = t.startSize) != null ? g : 0, this.endSize = (x = t.endSize) != null ? x : 0, this.endSize > 0 && this.startSize > 0 && (this.sizeRate = (this.endSize - this.startSize) / this.life, this.size = this.startSize), this.graphic ? (this.graphics.use(this.graphic), this.graphics.onPostDraw = void 0) : (this.graphics.localBounds = F.fromDimension(this.size, this.size, v.Half), this.graphics.onPostDraw = (m) => {
      m.save(), m.debug.drawPoint(w(0, 0), { color: this._currentColor, size: this.size }), m.restore();
    });
  }
  kill() {
    var t;
    (t = this._emitter) != null && t.isActive ? this._emitter.removeParticle(this) : super.kill();
  }
  update(t, e) {
    this.life = this.life - e, this.life < 0 && this.kill(), this.fade && (this.graphics.opacity = D(this._aRate * this.life, 1e-4, 1)), this.startSize && this.endSize && this.startSize > 0 && this.endSize > 0 && (this.size = D(
      this.sizeRate * e + this.size,
      Math.min(this.startSize, this.endSize),
      Math.max(this.startSize, this.endSize)
    )), this._currentColor.r = D(this._currentColor.r + this._rRate * e, 0, 255), this._currentColor.g = D(this._currentColor.g + this._gRate * e, 0, 255), this._currentColor.b = D(this._currentColor.b + this._bRate * e, 0, 255), this._currentColor.a = this.graphics.opacity;
    let i = this.motion.acc;
    this.focus && (i = this.focus.sub(this.transform.pos).normalize().scale(this.focusAccel || 0).scale(e / 1e3)), Ar.integrate(this.transform, this.motion, i, e);
  }
}
ws.DefaultConfig = {
  beginColor: T.White,
  endColor: T.White,
  life: 300,
  fade: !1,
  size: 5,
  graphic: void 0,
  startSize: void 0,
  endSize: void 0
};
var jt = /* @__PURE__ */ ((r) => (r.Global = "global", r.Local = "local", r))(jt || {});
class $o {
  constructor() {
    this.type = "ex.particle", this.priority = 0;
  }
  initialize(t, e) {
    this._gl = t, this._context = e, this._shader = new Lt({
      graphicsContext: e,
      vertexSource: qo,
      fragmentSource: Xo,
      onPreLink: (i) => {
        t.transformFeedbackVaryings(
          i,
          ["finalPosition", "finalVelocity", "finalRotation", "finalAngularVelocity", "finalLifeMs"],
          t.INTERLEAVED_ATTRIBS
        );
      }
    }), this._shader.compile(), this._shader.use(), this._shader.setUniformMatrix("u_matrix", this._context.ortho);
  }
  _getTexture(t) {
    const e = t.getAttribute(z.Filtering), i = e ? ei(e) : void 0, s = Wt(t.getAttribute(z.WrappingX)), n = Wt(t.getAttribute(z.WrappingY)), o = t.getAttribute("forceUpload") === "true", a = this._context.textureLoader.load(
      t,
      {
        filtering: i,
        wrapping: { x: s, y: n }
      },
      o
    );
    return t.removeAttribute("forceUpload"), a;
  }
  draw(t, e) {
    var i, s, n, o, a, h, l, c, d;
    const u = this._gl;
    this._shader.use(), this._shader.setUniformMatrix("u_matrix", this._context.ortho);
    const _ = t.particle.transform === jt.Local ? this._context.getTransform() : this._context.getTransform().multiply(t.emitter.transform.get().inverse);
    this._shader.setUniformAffineMatrix("u_transform", _), this._shader.setUniformBoolean("fade", !!t.particle.fade), this._shader.setUniformBoolean("useTexture", !!t.particle.graphic), this._shader.setUniformFloat("maxLifeMs", (i = t.particle.life) != null ? i : 2e3), this._shader.setUniformFloat("deltaMs", e), this._shader.setUniformFloatVector("gravity", (s = t.particle.acc) != null ? s : w(0, 0)), this._shader.setUniformFloatColor("beginColor", (n = t.particle.beginColor) != null ? n : T.Transparent), this._shader.setUniformFloatColor("endColor", (o = t.particle.endColor) != null ? o : T.Transparent);
    let p = (a = t.particle.startSize) != null ? a : 0, g = (h = t.particle.endSize) != null ? h : 0;
    const x = (l = t.particle.size) != null ? l : 0;
    if (x > 0 && (p = x, g = x), this._shader.setUniformFloat("startSize", p != null ? p : 10), this._shader.setUniformFloat("endSize", g != null ? g : 10), this._shader.setUniformFloat("startOpacity", (c = t.particle.opacity) != null ? c : 1), t.particle.focus && (this._shader.setUniformFloatVector("focus", t.particle.focus), this._shader.setUniformFloat("focusAccel", (d = t.particle.focusAccel) != null ? d : 0)), t.particle.graphic) {
      const m = t.particle.graphic, f = this._getTexture(m.image.image);
      u.activeTexture(u.TEXTURE0), u.bindTexture(u.TEXTURE_2D, f), this._shader.setUniformInt("graphic", 0);
    }
    t.draw(u);
  }
  hasPendingDraws() {
    return !1;
  }
  flush() {
  }
  dispose() {
  }
}
class Vt {
  constructor(t) {
    this.type = "dynamic";
    const { gl: e, size: i, type: s, data: n } = t;
    if (this._gl = e, this.buffer = this._gl.createBuffer(), !n && !i)
      throw Error("Must either provide data or a size to the VertexBuffer");
    n ? this.bufferData = n : this.bufferData = new Float32Array(i), this.type = s != null ? s : this.type, e.bindBuffer(e.ARRAY_BUFFER, this.buffer), e.bufferData(e.ARRAY_BUFFER, this.bufferData, this.type === "static" ? e.STATIC_DRAW : e.DYNAMIC_DRAW);
  }
  /**
   * Bind this vertex buffer
   */
  bind() {
    const t = this._gl;
    t.bindBuffer(t.ARRAY_BUFFER, this.buffer);
  }
  unbind() {
    const t = this._gl;
    t.bindBuffer(t.ARRAY_BUFFER, null);
  }
  /**
   * Upload vertex buffer geometry to the GPU
   */
  upload(t) {
    const e = this._gl;
    e.bindBuffer(e.ARRAY_BUFFER, this.buffer), t ? e.bufferSubData(e.ARRAY_BUFFER, 0, this.bufferData, 0, t) : e.bufferData(e.ARRAY_BUFFER, this.bufferData, this.type === "static" ? e.STATIC_DRAW : e.DYNAMIC_DRAW);
  }
  dispose() {
    this._gl.deleteBuffer(this.buffer), this._gl = null;
  }
}
class te {
  constructor(t) {
    this._logger = R.getInstance(), this._suppressWarnings = !1, this._layout = [], this._attributes = [], this._vertexTotalSizeBytes = 0, this._initialized = !1;
    const { gl: e, shader: i, vertexBuffer: s, attributes: n, suppressWarnings: o } = t;
    this._gl = e, this._vertexBuffer = s, this._attributes = n, this._shader = i, this._suppressWarnings = o, i && this.initialize();
  }
  get vertexBuffer() {
    return this._vertexBuffer;
  }
  get attributes() {
    return this._attributes;
  }
  /**
   * Total number of bytes that the vertex will take up
   */
  get totalVertexSizeBytes() {
    return this._vertexTotalSizeBytes;
  }
  set shader(t) {
    t && this._shader !== t && (this._shader = t, this.initialize());
  }
  get shader() {
    return this._shader;
  }
  /**
   * Layouts need shader locations and must be bound to a shader
   */
  initialize() {
    if (this._initialized || !this._shader)
      return;
    if (!this._shader.compiled)
      throw Error("Shader not compiled, shader must be compiled before defining a vertex layout");
    this._vertexTotalSizeBytes = 0, this._layout.length = 0;
    const t = this._shader.attributes;
    for (const n of this._attributes) {
      const o = t[n[0]];
      if (!o) {
        if (!br(this._shader.vertexSource, n[0]))
          throw Error(
            `The attribute named: ${n[0]} size ${n[1]} not found in the shader source code:
 ${this._shader.vertexSource}`
          );
        this._suppressWarnings || this._logger.warn(
          `The attribute named: ${n[0]} size ${n[1]} not found in the compiled shader. This is possibly a bug:
 1. Not a bug, but should remove unused code - attribute "${n[0]}" is unused in vertex/fragment and has been automatically removed by glsl compiler.
 2. Definitely a bug, attribute "${n[0]}" in layout has been mistyped or is missing in shader, check vertex/fragment source.`
        );
        const a = yr(this._gl, this._shader.vertexSource, n[0]);
        this._layout.push({
          name: n[0],
          glType: a,
          size: n[1],
          location: -1,
          normalized: !1
        });
      }
      if (o) {
        if (o.size !== n[1])
          throw Error(
            `VertexLayout size definition for attribute: [${n[0]}, ${n[1]}], doesn't match shader source size ${o.size}:
 ${this._shader.vertexSource}`
          );
        this._layout.push(o);
      }
    }
    let e = 0;
    for (const n of this._layout) {
      const o = rs(this._gl, n.glType);
      this._vertexTotalSizeBytes += o * n.size, e += n.size;
    }
    this._vertexBuffer.bufferData.length % e !== 0 && this._logger.warn(
      `The vertex component size (${e})  does NOT divide evenly into the specified vertex buffer (${this._vertexBuffer.bufferData.length})`
    );
    const i = this._gl;
    this._vao = i.createVertexArray(), i.bindVertexArray(this._vao), this._vertexBuffer.bind();
    let s = 0;
    for (const n of this._layout)
      n.location !== -1 && (n.glType === i.INT ? i.vertexAttribIPointer(n.location, n.size, n.glType, this.totalVertexSizeBytes, s) : i.vertexAttribPointer(n.location, n.size, n.glType, n.normalized, this.totalVertexSizeBytes, s), i.enableVertexAttribArray(n.location)), s += rs(i, n.glType) * n.size;
    i.bindVertexArray(null), this._vertexBuffer.unbind(), this._initialized = !0;
  }
  /**
   * Bind this layout with it's associated vertex buffer
   * @param uploadBuffer Optionally indicate you wish to upload the buffer to the GPU associated with this layout
   */
  use(t = !1, e) {
    if (!this._shader)
      throw Error("No shader is associated with this vertex layout, a shader must be set");
    const i = this._gl;
    if (!this._shader.isCurrentlyBound())
      throw Error("Shader associated with this vertex layout is not active! Call shader.use() before layout.use()");
    this._vertexBuffer.bind(), t && this._vertexBuffer.upload(e), i.bindVertexArray(this._vao);
  }
}
class Yo {
  constructor(t, e) {
    e.includes("v_texcoord") && R.getInstance().warn(
      `ScreenShader: "v_texcoord" is deprecated in postprocessing fragment shaders will be removed in v1.0, use "v_uv" instead. Source [${e}]`
    );
    const i = t.__gl;
    this._shader = new Lt({
      graphicsContext: t,
      vertexSource: `#version 300 es
      in vec2 a_position;
      in vec2 a_uv;
      out vec2 v_texcoord;
      out vec2 v_uv;

      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
        // Pass the texcoord to the fragment shader.
        v_texcoord = a_uv;
        v_uv = a_uv;
      }`,
      fragmentSource: e
    }), this._shader.compile(), this._buffer = new Vt({
      gl: i,
      type: "static",
      // clip space quad + uv since we don't need a camera
      data: new Float32Array([
        -1,
        -1,
        0,
        0,
        -1,
        1,
        0,
        1,
        1,
        -1,
        1,
        0,
        1,
        -1,
        1,
        0,
        -1,
        1,
        0,
        1,
        1,
        1,
        1,
        1
      ])
    }), this._layout = new te({
      gl: i,
      shader: this._shader,
      vertexBuffer: this._buffer,
      attributes: [
        ["a_position", 2],
        ["a_uv", 2]
      ]
    }), this._buffer.upload();
  }
  getShader() {
    return this._shader;
  }
  getLayout() {
    return this._layout;
  }
}
var qe = /* @__PURE__ */ ((r) => (r.Protanope = "Protanope", r.Deuteranope = "Deuteranope", r.Tritanope = "Tritanope", r))(qe || {});
const Zo = `#version 300 es
precision mediump float;
// our texture
uniform sampler2D u_image;
// the texCoords passed in from the vertex shader.
in vec2 v_texcoord;

// color blind type
uniform int u_type;

// simulation?
uniform bool u_simulate;

out vec4 fragColor;

void main() {
  vec4 o =  texture(u_image, v_texcoord);
  // RGB to LMS matrix conversion
  float L = (17.8824 * o.r) + (43.5161 * o.g) + (4.11935 * o.b);
  float M = (3.45565 * o.r) + (27.1554 * o.g) + (3.86714 * o.b);
  float S = (0.0299566 * o.r) + (0.184309 * o.g) + (1.46709 * o.b);
  // Simulate color blindness
  float l;
  float m;
  float s;
  //MODE CODE//
  if (u_type == 0) {
    // Protanope
    l = 0.0 * L + 2.02344 * M + -2.52581 * S;
    m = 0.0 * L + 1.0 * M + 0.0 * S;
    s = 0.0 * L + 0.0 * M + 1.0 * S;;
  } else if (u_type == 1) {
    // Deuteranope
    l = 1.0 * L + 0.0 * M + 0.0 * S;
    m = 0.494207 * L + 0.0 * M + 1.24827 * S;
    s = 0.0 * L + 0.0 * M + 1.0 * S;
  } else if (u_type == 2) {
    // Tritanope
    l = 1.0 * L + 0.0 * M + 0.0 * S;
    m = 0.0 * L + 1.0 * M + 0.0 * S;
    s = -0.395913 * L + 0.801109 * M + 0.0 * S;
  }

  // LMS to RGB matrix conversion
  vec4 error; // simulate the colors
  error.r = (0.0809444479 * l) + (-0.130504409 * m) + (0.116721066 * s);
  error.g = (-0.0102485335 * l) + (0.0540193266 * m) + (-0.113614708 * s);
  error.b = (-0.000365296938 * l) + (-0.00412161469 * m) + (0.693511405 * s);
  error.a = 1.0;
  vec4 diff = o - error;
  vec4 correction; // correct the colors
  correction.r = 0.0;
  correction.g =  (diff.r * 0.7) + (diff.g * 1.0);
  correction.b =  (diff.r * 0.7) + (diff.b * 1.0);
  correction = o + correction;
  correction.a = o.a;
  //SIMULATE//

  // sim 
  if (u_simulate) {
    fragColor = error.rgba;
  } else {
    fragColor = correction.rgba;
  }
}`;
class jo {
  constructor(t, e = !1) {
    this._colorBlindnessMode = t, this._simulate = !1, this._simulate = e;
  }
  initialize(t) {
    this._shader = new Yo(t, Zo), this.simulate = this._simulate, this.colorBlindnessMode = this._colorBlindnessMode;
  }
  getShader() {
    return this._shader.getShader();
  }
  getLayout() {
    return this._shader.getLayout();
  }
  set colorBlindnessMode(t) {
    if (this._colorBlindnessMode = t, this._shader) {
      const e = this._shader.getShader();
      e.use(), this._colorBlindnessMode === qe.Protanope ? e.setUniformInt("u_type", 0) : this._colorBlindnessMode === qe.Deuteranope ? e.setUniformInt("u_type", 1) : this._colorBlindnessMode === qe.Tritanope && e.setUniformInt("u_type", 2);
    }
  }
  get colorBlindnessMode() {
    return this._colorBlindnessMode;
  }
  set simulate(t) {
    if (this._simulate = t, this._shader) {
      const e = this._shader.getShader();
      e.use(), e.setUniformBoolean("u_simulate", t);
    }
  }
  get simulate() {
    return this._simulate;
  }
}
class ni {
  /**
   * @param gl WebGL2RenderingContext this layout will be attached to, these cannot be reused across contexts.
   * @param numberOfQuads Specify the max number of quads you want to draw
   * @param useUint16 Optionally force a uint16 buffer
   */
  constructor(t, e, i) {
    this._logger = R.getInstance(), this._gl = t, this.buffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.buffer);
    const s = e * 6;
    if (!i)
      this.bufferData = new Uint32Array(s);
    else {
      const a = Math.floor(16383.5);
      this.bufferGlType = t.UNSIGNED_SHORT, this.bufferData = new Uint16Array(s), e > a && this._logger.warn(
        `Total quads exceeds hardware index buffer limit (uint16), max(${a}) requested quads(${e})`
      );
    }
    let n = 0;
    for (let o = 0; o < s; o += 6)
      this.bufferData[o + 0] = n + 0, this.bufferData[o + 1] = n + 1, this.bufferData[o + 2] = n + 2, this.bufferData[o + 3] = n + 2, this.bufferData[o + 4] = n + 1, this.bufferData[o + 5] = n + 3, n += 4;
    t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.bufferData, t.STATIC_DRAW);
  }
  get size() {
    return this.bufferData.length;
  }
  /**
   * Upload data to the GPU
   */
  upload() {
    const t = this._gl;
    t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.buffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.bufferData, t.STATIC_DRAW);
  }
  /**
   * Bind this index buffer
   */
  bind() {
    const t = this._gl;
    t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.buffer);
  }
  dispose() {
    this._gl.deleteBuffer(this.buffer), this._gl = null;
  }
}
const Qo = `#version 300 es
in vec2 a_position;

in vec2 a_uv;
out vec2 v_uv;

in vec2 a_screenuv;
out vec2 v_screenuv;

uniform mat4 u_matrix;
uniform mat4 u_transform;

void main() {
  // Set the vertex position using the ortho & transform matrix
  gl_Position = u_matrix * u_transform * vec4(a_position, 0.0, 1.0);

  // Pass through the UV coord to the fragment shader
  v_uv = a_uv;
  v_screenuv = a_screenuv;
}
`, Pr = class Er {
  constructor(t) {
    this._logger = R.getInstance(), this._color = T.Transparent, this._initialized = !1, this._images = {}, this._uniforms = {};
    const { color: e, name: i, vertexSource: s, fragmentSource: n, graphicsContext: o, images: a, uniforms: h } = t;
    if (this._name = i != null ? i : "anonymous material", this._vertexSource = s != null ? s : Qo, this._fragmentSource = n, this._color = e != null ? e : this._color, this._uniforms = h != null ? h : this._uniforms, this._images = a != null ? a : this._images, !o)
      throw Error(`Material ${i} must be provided an excalibur webgl graphics context`);
    o instanceof Qt ? this._initialize(o) : this._logger.warn(`Material ${i} was created in 2D Canvas mode, currently only WebGL is supported`);
    {
      this.images.u_graphic && this._logger.warn(
        `Material named "${this.name}" is overriding built in image u_graphic, is this on purpose? If so ignore this warning.`
      ), this.images.u_screen_texture && this._logger.warn(
        `Material named "${this.name}" is overriding built in image u_screen_texture, is this on purpose? If so ignore this warning.`
      );
      for (const l of Object.keys(this._uniforms))
        Er.BuiltInUniforms.includes(l) && this._logger.warn(
          `Material named "${this.name}" is overriding built in uniform ${l}, is this on purpose? If so ignore this warning.`
        );
    }
  }
  _initialize(t) {
    this._initialized || (this._shader = t.createShader({
      name: this._name,
      vertexSource: this._vertexSource,
      fragmentSource: this._fragmentSource,
      uniforms: this._uniforms,
      images: this._images,
      // max texture slots
      // - 2 for the graphic texture and screen texture
      // - 1 if just graphic
      startingTextureSlot: this.isUsingScreenTexture ? 2 : 1
    }), this._initialized = !0);
  }
  get uniforms() {
    return this._shader.uniforms;
  }
  get images() {
    return this._shader.images;
  }
  get color() {
    return this._color;
  }
  set color(t) {
    this._color = t;
  }
  get name() {
    return this._name;
  }
  get isUsingScreenTexture() {
    return this._fragmentSource.includes("u_screen_texture");
  }
  get isOverridingGraphic() {
    return !!this._images.u_graphic;
  }
  update(t) {
    this._shader && (this._shader.use(), t(this._shader));
  }
  getShader() {
    return this._shader;
  }
  addImageSource(t, e) {
    this._shader.addImageSource(t, e), this.images.u_graphic && this._logger.warn(
      `Material named "${this.name}" is overriding built in image u_graphic, is this on purpose? If so ignore this warning.`
    ), this.images.u_screen_texture && this._logger.warn(
      `Material named "${this.name}" is overriding built in image u_screen_texture, is this on purpose? If so ignore this warning.`
    );
  }
  removeImageSource(t) {
    this._shader.removeImageSource(t);
  }
  use() {
    if (this._initialized)
      this._shader.use(), this._shader.trySetUniformFloatColor("u_color", this._color);
    else
      throw Error(`Material ${this.name} not yet initialized, use the ExcaliburGraphicsContext.createMaterial() to work around this.`);
  }
};
Pr.BuiltInUniforms = [
  "u_time_ms",
  "u_opacity",
  "u_resolution",
  "u_graphic_resolution",
  "u_size",
  "u_matrix",
  "u_transform",
  "u_graphic",
  "u_screen_texture"
];
let Jo = Pr;
class Ko {
  constructor() {
    this.type = "ex.debug-line", this.priority = 0, this._maxLines = 10922, this._vertexIndex = 0, this._lineCount = 0, this._startScratch = w(0, 0), this._endScratch = w(0, 0), this._lengthSoFar = 0, this._currentlyDashed = !1;
  }
  initialize(t, e) {
    this._gl = t, this._context = e, this._shader = new Lt({
      graphicsContext: e,
      vertexSource: Lo,
      fragmentSource: Uo
    }), this._shader.compile(), this._shader.use(), this._shader.setUniformMatrix("u_matrix", this._context.ortho), this._vertexBuffer = new Vt({
      gl: t,
      size: 42 * this._maxLines,
      // 7 floats per vert, 6 verts per line
      type: "dynamic"
    }), this._layout = new te({
      gl: t,
      vertexBuffer: this._vertexBuffer,
      shader: this._shader,
      attributes: [
        ["a_position", 2],
        ["a_color", 4],
        ["a_lengthSoFar", 1]
      ]
    });
  }
  dispose() {
    this._vertexBuffer.dispose(), this._shader.dispose(), this._context = null, this._gl = null;
  }
  draw(t, e, i, s = 2, n = !1) {
    (this._isFull() || this._currentlyDashed !== n) && (this._currentlyDashed = n, this.flush()), this._lineCount++;
    const o = this._context.getTransform(), a = o.multiply(t, this._startScratch), h = o.multiply(e, this._endScratch), l = h.sub(a), c = a.distance(h), d = l.normal(), u = s / 2, _ = this._vertexBuffer.bufferData;
    _[this._vertexIndex++] = a.x - d.x * u, _[this._vertexIndex++] = a.y - d.y * u, _[this._vertexIndex++] = i.r / 255, _[this._vertexIndex++] = i.g / 255, _[this._vertexIndex++] = i.b / 255, _[this._vertexIndex++] = i.a, _[this._vertexIndex++] = this._lengthSoFar, _[this._vertexIndex++] = a.x + d.x * u, _[this._vertexIndex++] = a.y + d.y * u, _[this._vertexIndex++] = i.r / 255, _[this._vertexIndex++] = i.g / 255, _[this._vertexIndex++] = i.b / 255, _[this._vertexIndex++] = i.a, _[this._vertexIndex++] = this._lengthSoFar, _[this._vertexIndex++] = h.x - d.x * u, _[this._vertexIndex++] = h.y - d.y * u, _[this._vertexIndex++] = i.r / 255, _[this._vertexIndex++] = i.g / 255, _[this._vertexIndex++] = i.b / 255, _[this._vertexIndex++] = i.a, _[this._vertexIndex++] = this._lengthSoFar + c, _[this._vertexIndex++] = h.x - d.x * u, _[this._vertexIndex++] = h.y - d.y * u, _[this._vertexIndex++] = i.r / 255, _[this._vertexIndex++] = i.g / 255, _[this._vertexIndex++] = i.b / 255, _[this._vertexIndex++] = i.a, _[this._vertexIndex++] = this._lengthSoFar + c, _[this._vertexIndex++] = a.x + d.x * u, _[this._vertexIndex++] = a.y + d.y * u, _[this._vertexIndex++] = i.r / 255, _[this._vertexIndex++] = i.g / 255, _[this._vertexIndex++] = i.b / 255, _[this._vertexIndex++] = i.a, _[this._vertexIndex++] = this._lengthSoFar, _[this._vertexIndex++] = h.x + d.x * u, _[this._vertexIndex++] = h.y + d.y * u, _[this._vertexIndex++] = i.r / 255, _[this._vertexIndex++] = i.g / 255, _[this._vertexIndex++] = i.b / 255, _[this._vertexIndex++] = i.a, _[this._vertexIndex++] = this._lengthSoFar + c;
  }
  _isFull() {
    return this._lineCount >= this._maxLines;
  }
  hasPendingDraws() {
    return this._lineCount !== 0;
  }
  flush() {
    if (this._lineCount === 0)
      return;
    const t = this._gl;
    this._shader.use(), this._layout.use(!0), this._shader.setUniformMatrix("u_matrix", this._context.ortho), this._shader.setUniformBoolean("u_dashed", this._currentlyDashed), t.drawArrays(t.TRIANGLES, 0, this._lineCount * 6), Z.DrawnImagesCount += this._lineCount, Z.DrawCallCount++, this._vertexIndex = 0, this._lineCount = 0, this._lengthSoFar = 0;
  }
}
const ta = `#version 300 es
in vec2 a_position;
in vec4 a_color;
in float a_size;
out lowp vec4 v_color;
uniform mat4 u_matrix;

void main() {
  gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);
  gl_PointSize = a_size * 2.0;
  v_color = a_color;
}`, ea = `#version 300 es

precision mediump float;
in lowp vec4 v_color;

out vec4 fragColor;

void main() {
  float r = 0.0, delta = 0.0, alpha = 1.0;
  vec2 cxy = 2.0 * gl_PointCoord - 1.0;
  r = dot(cxy, cxy);

  delta = fwidth(r);
  alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
  // "premultiply" the color by alpha
  vec4 color = v_color;
  color.a = color.a * alpha;
  color.rgb = color.rgb * color.a;
  fragColor = color;
}`;
class ia {
  constructor() {
    this.type = "ex.debug-point", this.priority = 0, this._maxPoints = 10922, this._pointCount = 0, this._vertexIndex = 0;
  }
  initialize(t, e) {
    this._gl = t, this._context = e, this._shader = new Lt({
      graphicsContext: e,
      vertexSource: ta,
      fragmentSource: ea
    }), this._shader.compile(), this._shader.use(), this._shader.setUniformMatrix("u_matrix", this._context.ortho), this._buffer = new Vt({
      gl: t,
      size: 7 * this._maxPoints,
      type: "dynamic"
    }), this._layout = new te({
      gl: t,
      shader: this._shader,
      vertexBuffer: this._buffer,
      attributes: [
        ["a_position", 2],
        ["a_color", 4],
        ["a_size", 1]
      ]
    });
  }
  dispose() {
    this._buffer.dispose(), this._shader.dispose(), this._context = null, this._gl = null;
  }
  draw(t, e, i) {
    this._isFull() && this.flush(), this._pointCount++;
    const s = this._context.getTransform(), n = this._context.opacity, o = this._context.snapToPixel, a = s.multiply(t);
    o && (a.x = ~~(a.x + M), a.y = ~~(a.y + M));
    const h = this._buffer.bufferData;
    h[this._vertexIndex++] = a.x, h[this._vertexIndex++] = a.y, h[this._vertexIndex++] = e.r / 255, h[this._vertexIndex++] = e.g / 255, h[this._vertexIndex++] = e.b / 255, h[this._vertexIndex++] = e.a * n, h[this._vertexIndex++] = i;
  }
  _isFull() {
    return this._pointCount >= this._maxPoints;
  }
  hasPendingDraws() {
    return this._pointCount !== 0;
  }
  flush() {
    if (this._pointCount === 0)
      return;
    const t = this._gl;
    this._shader.use(), this._layout.use(!0), this._shader.setUniformMatrix("u_matrix", this._context.ortho), t.drawArrays(t.POINTS, 0, this._pointCount), Z.DrawnImagesCount += this._pointCount, Z.DrawCallCount++, this._pointCount = 0, this._vertexIndex = 0;
  }
}
const sa = `#version 300 es
precision highp float;

// UV coord
in vec2 v_uv;

// Color coord to blend with image
in lowp vec4 v_color;

// Stroke color if used
in lowp vec4 v_strokeColor;

// Stroke thickness if used
in lowp float v_strokeThickness;

in float v_radius;

// Opacity
in float v_opacity;

out vec4 fragColor;

void main() {
  // make (0, 0) the center the uv 
  vec2 uv = v_uv * 2.0 - 1.0;

  vec4 color = v_color;
  vec4 strokeColor = v_strokeColor;

  float dist = 1.0 - length(uv);
  float radius = dist * v_radius; // 0 is the edge

  // Fade based on fwidth
  float fade = fwidth(dot(uv, uv)) / 2.0;

  float fill = smoothstep(-fade, fade, radius);

  float stroke = 
    smoothstep(0.0, fade, radius) -
    smoothstep(v_strokeThickness, v_strokeThickness + fade, radius);

  strokeColor.a = stroke;
  strokeColor.rgb *= strokeColor.a;

  // vec4 finalColor = strokeColor;

  color.a *= fill * (1.0 - stroke);
  color.rgb *= color.a;

  vec4 finalColor = mix(vec4(0.0), (color + strokeColor), fill);
  finalColor.rgb = finalColor.rgb * v_opacity;
  finalColor.a = finalColor.a * v_opacity;

  fragColor = finalColor;
}
`, na = `#version 300 es
in vec2 a_position;

// UV coordinate
in vec2 a_uv;
out vec2 v_uv;

// Opacity 
in float a_opacity;
out float v_opacity;

in vec4 a_color;
out vec4 v_color;

in vec4 a_strokeColor;
out vec4 v_strokeColor;

in float a_strokeThickness;
out float v_strokeThickness;

in float a_radius;
out float v_radius;

uniform mat4 u_matrix;


void main() {
   // Set the vertex position using the ortho transform matrix
   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);

   // Pass through UV coords
   v_uv = a_uv;
   // Pass through the Opacity to the fragment shader
   v_opacity = a_opacity;
   // Pass through the color to the fragment shader
   v_color = a_color;
   // Pass through the stroke color to the fragment shader
   v_strokeColor = a_strokeColor;
   // Pass through the stroke thickenss to the fragment shader
   v_strokeThickness = a_strokeThickness;
   v_radius = a_radius;
}
`;
class ra {
  constructor() {
    this.type = "ex.debug-circle", this.priority = 0, this._maxCircles = 10922, this._circleCount = 0, this._vertexIndex = 0;
  }
  initialize(t, e) {
    this._gl = t, this._context = e, this._shader = new Lt({
      graphicsContext: e,
      fragmentSource: sa,
      vertexSource: na
    }), this._shader.compile(), this._shader.use(), this._shader.setUniformMatrix("u_matrix", e.ortho), this._buffer = new Vt({
      gl: t,
      size: 60 * this._maxCircles,
      type: "dynamic"
    }), this._layout = new te({
      gl: t,
      shader: this._shader,
      vertexBuffer: this._buffer,
      attributes: [
        ["a_position", 2],
        ["a_uv", 2],
        ["a_opacity", 1],
        ["a_color", 4],
        ["a_strokeColor", 4],
        ["a_strokeThickness", 1],
        ["a_radius", 1]
      ]
    }), this._quads = new ni(t, this._maxCircles, !0);
  }
  dispose() {
    this._buffer.dispose(), this._quads.dispose(), this._shader.dispose(), this._context = null, this._gl = null;
  }
  _isFull() {
    return this._circleCount >= this._maxCircles;
  }
  draw(t, e, i, s = T.Transparent, n = 0) {
    this._isFull() && this.flush(), this._circleCount++;
    const o = this._context.getTransform(), a = o.getScaleX(), h = this._context.opacity, l = this._context.snapToPixel, c = o.multiply(t.add(w(-e, -e))), d = o.multiply(t.add(w(e, -e))), u = o.multiply(t.add(w(e, e))), _ = o.multiply(t.add(w(-e, e)));
    l && (c.x = ~~(c.x + M), c.y = ~~(c.y + M), d.x = ~~(d.x + M), d.y = ~~(d.y + M), _.x = ~~(_.x + M), _.y = ~~(_.y + M), u.x = ~~(u.x + M), u.y = ~~(u.y + M));
    const p = 0, g = 0, x = 1, m = 1, f = this._layout.vertexBuffer.bufferData;
    f[this._vertexIndex++] = c.x, f[this._vertexIndex++] = c.y, f[this._vertexIndex++] = p, f[this._vertexIndex++] = g, f[this._vertexIndex++] = h, f[this._vertexIndex++] = i.r / 255, f[this._vertexIndex++] = i.g / 255, f[this._vertexIndex++] = i.b / 255, f[this._vertexIndex++] = i.a, f[this._vertexIndex++] = s.r / 255, f[this._vertexIndex++] = s.g / 255, f[this._vertexIndex++] = s.b / 255, f[this._vertexIndex++] = s.a, f[this._vertexIndex++] = n, f[this._vertexIndex++] = e * a, f[this._vertexIndex++] = _.x, f[this._vertexIndex++] = _.y, f[this._vertexIndex++] = p, f[this._vertexIndex++] = m, f[this._vertexIndex++] = h, f[this._vertexIndex++] = i.r / 255, f[this._vertexIndex++] = i.g / 255, f[this._vertexIndex++] = i.b / 255, f[this._vertexIndex++] = i.a, f[this._vertexIndex++] = s.r / 255, f[this._vertexIndex++] = s.g / 255, f[this._vertexIndex++] = s.b / 255, f[this._vertexIndex++] = s.a, f[this._vertexIndex++] = n, f[this._vertexIndex++] = e * a, f[this._vertexIndex++] = d.x, f[this._vertexIndex++] = d.y, f[this._vertexIndex++] = x, f[this._vertexIndex++] = g, f[this._vertexIndex++] = h, f[this._vertexIndex++] = i.r / 255, f[this._vertexIndex++] = i.g / 255, f[this._vertexIndex++] = i.b / 255, f[this._vertexIndex++] = i.a, f[this._vertexIndex++] = s.r / 255, f[this._vertexIndex++] = s.g / 255, f[this._vertexIndex++] = s.b / 255, f[this._vertexIndex++] = s.a, f[this._vertexIndex++] = n, f[this._vertexIndex++] = e * a, f[this._vertexIndex++] = u.x, f[this._vertexIndex++] = u.y, f[this._vertexIndex++] = x, f[this._vertexIndex++] = m, f[this._vertexIndex++] = h, f[this._vertexIndex++] = i.r / 255, f[this._vertexIndex++] = i.g / 255, f[this._vertexIndex++] = i.b / 255, f[this._vertexIndex++] = i.a, f[this._vertexIndex++] = s.r / 255, f[this._vertexIndex++] = s.g / 255, f[this._vertexIndex++] = s.b / 255, f[this._vertexIndex++] = s.a, f[this._vertexIndex++] = n, f[this._vertexIndex++] = e * a;
  }
  hasPendingDraws() {
    return this._circleCount !== 0;
  }
  flush() {
    if (this._circleCount === 0)
      return;
    const t = this._gl;
    this._shader.use(), this._layout.use(!0), this._shader.setUniformMatrix("u_matrix", this._context.ortho), this._quads.bind(), t.drawElements(t.TRIANGLES, this._circleCount * 6, this._quads.bufferGlType, 0), Z.DrawnImagesCount += this._circleCount, Z.DrawCallCount++, this._circleCount = 0, this._vertexIndex = 0;
  }
}
const oa = `#version 300 es
in vec2 a_position;

in vec2 a_texcoord;
out vec2 v_texcoord;

void main() {
  gl_Position = vec4(a_position, 0.0, 1.0);

  // Pass the texcoord to the fragment shader.
  v_texcoord = a_texcoord;
}`, aa = `#version 300 es
precision mediump float;

// Passed in from the vertex shader.
in vec2 v_texcoord;

// The texture.
uniform sampler2D u_texture;

out vec4 fragColor;

void main() {
   fragColor = texture(u_texture, v_texcoord);
}`;
class ha {
  constructor(t) {
    const e = t.__gl;
    this._gl = e, this._shader = new Lt({
      graphicsContext: t,
      vertexSource: oa,
      fragmentSource: aa
    }), this._shader.compile(), this._buffer = new Vt({
      gl: e,
      type: "static",
      // clip space quad + uv since we don't need a camera
      data: new Float32Array([
        -1,
        -1,
        0,
        0,
        -1,
        1,
        0,
        1,
        1,
        -1,
        1,
        0,
        1,
        -1,
        1,
        0,
        -1,
        1,
        0,
        1,
        1,
        1,
        1,
        1
      ])
    }), this._layout = new te({
      gl: e,
      shader: this._shader,
      vertexBuffer: this._buffer,
      attributes: [
        ["a_position", 2],
        ["a_texcoord", 2]
      ]
    }), this._buffer.upload();
  }
  renderWithPostProcessor(t) {
    const e = this._gl, i = t.getShader();
    i.use(), t.getLayout().use(), e.activeTexture(e.TEXTURE0), i.trySetUniformInt("u_image", 0), t.onDraw && t.onDraw(), e.drawArrays(e.TRIANGLES, 0, 6);
  }
  renderToScreen() {
    const t = this._gl;
    this._shader.use(), this._layout.use(), t.drawArrays(t.TRIANGLES, 0, 6);
  }
}
const la = `#version 300 es
precision mediump float;

// UV coord
in vec2 v_texcoord;

// Texture index
in lowp float v_textureIndex;

// Textures in the current draw
uniform sampler2D u_textures[%%count%%];

uniform bool u_pixelart;

// Opacity
in float v_opacity;

in vec4 v_tint;

in vec2 v_res;

out vec4 fragColor;

// Inigo Quilez pixel art filter https://jorenjoestar.github.io/post/pixel_art_filtering/
vec2 uv_iq(in vec2 uv, in vec2 texture_size) {
  vec2 pixel = uv * texture_size;
  
  vec2 seam=floor(pixel+.5);
  vec2 dudv=fwidth(pixel);
  pixel=seam+clamp((pixel-seam)/dudv,-.5,.5);
  
  return pixel/texture_size;
}

void main(){
  // In order to support the most efficient sprite batching, we have multiple
  // textures loaded into the gpu (usually 8) this picker logic skips over textures
  // that do not apply to a particular sprite.
  
  vec4 color=vec4(1.,0,0,1.);
  
  // GLSL is templated out to pick the right texture and set the vec4 color
  %%texture_picker%%
  
  color.rgb=color.rgb*v_opacity;
  color.a=color.a*v_opacity;
  fragColor=color*v_tint;
}`, ca = `#version 300 es
in vec2 a_position;

// Opacity
in float a_opacity;
out float v_opacity;

// UV coordinate
in vec2 a_texcoord;
out vec2 v_texcoord;

// Texture res
in vec2 a_res;
out vec2 v_res;

// Texture number
in lowp float a_textureIndex;
out lowp float v_textureIndex;

in vec4 a_tint;
out vec4 v_tint;

uniform mat4 u_matrix;

void main(){
  // Set the vertex position using the ortho transform matrix
  gl_Position=u_matrix*vec4(a_position,0.,1.);
  
  // Pass through the Opacity to the fragment shader
  v_opacity=a_opacity;
  // Pass through the UV coord to the fragment shader
  v_texcoord=a_texcoord;

  v_res = a_res;

  // Pass through the texture number to the fragment shader
  v_textureIndex=a_textureIndex;
  // Pass through the tint
  v_tint=a_tint;
}`;
class da {
  constructor(t) {
    this.type = "ex.image", this.priority = 0, this._maxImages = 10922, this._maxTextures = 0, this._imageCount = 0, this._textures = [], this._textureIndex = 0, this._textureToIndex = /* @__PURE__ */ new Map(), this._images = /* @__PURE__ */ new Set(), this._vertexIndex = 0, this._imageToWidth = /* @__PURE__ */ new Map(), this._imageToHeight = /* @__PURE__ */ new Map(), this._view = [0, 0, 0, 0], this._dest = [0, 0], this._quad = [0, 0, 0, 0, 0, 0, 0, 0], this._defaultTint = T.White, this.pixelArtSampler = t.pixelArtSampler, this.uvPadding = t.uvPadding;
  }
  initialize(t, e) {
    this._gl = t, this._context = e;
    const i = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), s = vs(t, i);
    this._maxTextures = Math.min(i, s);
    const n = this._transformFragmentSource(la, this._maxTextures);
    this._shader = new Lt({
      graphicsContext: e,
      fragmentSource: n,
      vertexSource: ca
    }), this._shader.compile(), this._shader.use(), this._shader.setUniformMatrix("u_matrix", e.ortho), this._shader.setUniformIntArray(
      "u_textures",
      [...Array(this._maxTextures)].map((o, a) => a)
    ), this._buffer = new Vt({
      gl: t,
      size: 48 * this._maxImages,
      // 12 components * 4 verts
      type: "dynamic"
    }), this._layout = new te({
      gl: t,
      shader: this._shader,
      vertexBuffer: this._buffer,
      attributes: [
        ["a_position", 2],
        ["a_opacity", 1],
        ["a_res", 2],
        ["a_texcoord", 2],
        ["a_textureIndex", 1],
        ["a_tint", 4]
      ]
    }), this._quads = new ni(t, this._maxImages, !0);
  }
  dispose() {
    this._buffer.dispose(), this._quads.dispose(), this._shader.dispose(), this._textures.length = 0, this._context = null, this._gl = null;
  }
  _transformFragmentSource(t, e) {
    let i = t.replace("%%count%%", e.toString()), s = "";
    for (let n = 0; n < e; n++)
      n === 0 ? s += `if (v_textureIndex <= ${n}.5) {
` : s += `   else if (v_textureIndex <= ${n}.5) {
`, s += `      vec2 uv = u_pixelart ? uv_iq(v_texcoord, v_res) : v_texcoord;
`, s += `      color = texture(u_textures[${n}], uv);
`, s += `   }
`;
    return i = i.replace("%%texture_picker%%", s), i;
  }
  _addImageAsTexture(t) {
    if (this._images.has(t))
      return;
    const e = t.getAttribute(z.Filtering), i = e ? ei(e) : void 0, s = Wt(t.getAttribute(z.WrappingX)), n = Wt(t.getAttribute(z.WrappingY)), o = t.getAttribute("forceUpload") === "true", a = this._context.textureLoader.load(
      t,
      {
        filtering: i,
        wrapping: { x: s, y: n }
      },
      o
    );
    t.removeAttribute("forceUpload"), this._textures.indexOf(a) === -1 && (this._textures.push(a), this._textureToIndex.set(a, this._textureIndex++), this._images.add(t));
  }
  _bindTextures(t) {
    for (let e = 0; e < this._maxTextures; e++)
      t.activeTexture(t.TEXTURE0 + e), t.bindTexture(t.TEXTURE_2D, this._textures[e] || this._textures[0]);
  }
  _getTextureIdForImage(t) {
    var e;
    if (t) {
      const i = this._context.textureLoader.get(t);
      return (e = this._textureToIndex.get(i)) != null ? e : -1;
    }
    return -1;
  }
  _isFull() {
    return this._imageCount >= this._maxImages || this._textures.length >= this._maxTextures;
  }
  _getImageWidth(t) {
    let e = this._imageToWidth.get(t);
    return e === void 0 && (e = t.width, this._imageToWidth.set(t, e)), e;
  }
  _getImageHeight(t) {
    let e = this._imageToHeight.get(t);
    return e === void 0 && (e = t.height, this._imageToHeight.set(t, e)), e;
  }
  draw(t, e, i, s, n, o, a, h, l) {
    var c, d, u, _;
    this._isFull() && this.flush(), this._imageCount++, this._addImageAsTexture(t);
    const p = this._getImageWidth(t), g = this._getImageHeight(t);
    let x = p || s || 0, m = g || n || 0;
    this._view[0] = 0, this._view[1] = 0, this._view[2] = (c = s != null ? s : p) != null ? c : 0, this._view[3] = (d = n != null ? n : g) != null ? d : 0, this._dest[0] = e != null ? e : 1, this._dest[1] = i != null ? i : 1, o !== void 0 && a !== void 0 && h !== void 0 && l !== void 0 && (this._view[0] = e != null ? e : 1, this._view[1] = i != null ? i : 1, this._view[2] = (u = s != null ? s : p) != null ? u : 0, this._view[3] = (_ = n != null ? n : g) != null ? _ : 0, this._dest[0] = o, this._dest[1] = a, x = h, m = l), e = this._view[0], i = this._view[1];
    const f = this._view[2], b = this._view[3], C = this._context.getTransform(), S = this._context.opacity, I = this._context.snapToPixel;
    this._quad[0] = this._dest[0], this._quad[1] = this._dest[1], this._quad[2] = this._dest[0] + x, this._quad[3] = this._dest[1], this._quad[4] = this._dest[0], this._quad[5] = this._dest[1] + m, this._quad[6] = this._dest[0] + x, this._quad[7] = this._dest[1] + m, C.multiplyQuadInPlace(this._quad), I && (this._quad[0] = ~~(this._quad[0] + q(this._quad[0]) * M), this._quad[1] = ~~(this._quad[1] + q(this._quad[1]) * M), this._quad[2] = ~~(this._quad[2] + q(this._quad[2]) * M), this._quad[3] = ~~(this._quad[3] + q(this._quad[3]) * M), this._quad[4] = ~~(this._quad[4] + q(this._quad[4]) * M), this._quad[5] = ~~(this._quad[5] + q(this._quad[5]) * M), this._quad[6] = ~~(this._quad[6] + q(this._quad[6]) * M), this._quad[7] = ~~(this._quad[7] + q(this._quad[7]) * M));
    const y = this._context.tint || this._defaultTint, k = this._getTextureIdForImage(t), L = p || x, O = g || m, Q = (e + this.uvPadding) / L, st = (i + this.uvPadding) / O, $ = (e + f - this.uvPadding) / L, H = (i + b - this.uvPadding) / O, rt = p, lt = g, A = this._layout.vertexBuffer.bufferData;
    A[this._vertexIndex++] = this._quad[0], A[this._vertexIndex++] = this._quad[1], A[this._vertexIndex++] = S, A[this._vertexIndex++] = rt, A[this._vertexIndex++] = lt, A[this._vertexIndex++] = Q, A[this._vertexIndex++] = st, A[this._vertexIndex++] = k, A[this._vertexIndex++] = y.r / 255, A[this._vertexIndex++] = y.g / 255, A[this._vertexIndex++] = y.b / 255, A[this._vertexIndex++] = y.a, A[this._vertexIndex++] = this._quad[4], A[this._vertexIndex++] = this._quad[5], A[this._vertexIndex++] = S, A[this._vertexIndex++] = rt, A[this._vertexIndex++] = lt, A[this._vertexIndex++] = Q, A[this._vertexIndex++] = H, A[this._vertexIndex++] = k, A[this._vertexIndex++] = y.r / 255, A[this._vertexIndex++] = y.g / 255, A[this._vertexIndex++] = y.b / 255, A[this._vertexIndex++] = y.a, A[this._vertexIndex++] = this._quad[2], A[this._vertexIndex++] = this._quad[3], A[this._vertexIndex++] = S, A[this._vertexIndex++] = rt, A[this._vertexIndex++] = lt, A[this._vertexIndex++] = $, A[this._vertexIndex++] = st, A[this._vertexIndex++] = k, A[this._vertexIndex++] = y.r / 255, A[this._vertexIndex++] = y.g / 255, A[this._vertexIndex++] = y.b / 255, A[this._vertexIndex++] = y.a, A[this._vertexIndex++] = this._quad[6], A[this._vertexIndex++] = this._quad[7], A[this._vertexIndex++] = S, A[this._vertexIndex++] = rt, A[this._vertexIndex++] = lt, A[this._vertexIndex++] = $, A[this._vertexIndex++] = H, A[this._vertexIndex++] = k, A[this._vertexIndex++] = y.r / 255, A[this._vertexIndex++] = y.g / 255, A[this._vertexIndex++] = y.b / 255, A[this._vertexIndex++] = y.a;
  }
  hasPendingDraws() {
    return this._imageCount !== 0;
  }
  flush() {
    if (this._imageCount === 0)
      return;
    const t = this._gl;
    this._shader.use(), this._layout.use(!0, 48 * this._imageCount), this._shader.setUniformMatrix("u_matrix", this._context.ortho), this._shader.setUniformBoolean("u_pixelart", this.pixelArtSampler), this._bindTextures(t), this._quads.bind(), t.drawElements(t.TRIANGLES, this._imageCount * 6, this._quads.bufferGlType, 0), Z.DrawnImagesCount += this._imageCount, Z.DrawCallCount++, this._imageCount = 0, this._vertexIndex = 0, this._textures.length = 0, this._textureIndex = 0, this._textureToIndex.clear(), this._images.clear(), this._imageToWidth.clear(), this._imageToHeight.clear();
  }
}
const ua = `#version 300 es

precision mediump float;

// UV coord
in vec2 v_uv;

in vec2 v_size; // in pixels

// Color coord to blend with image
in lowp vec4 v_color;

// Stroke color if used
in lowp vec4 v_strokeColor;

// Stroke thickness if used
in lowp float v_strokeThickness; // in pixels

// Opacity
in float v_opacity;

out vec4 fragColor;

void main() {
    // modified from https://stackoverflow.com/questions/59197671/glsl-rounded-rectangle-with-variable-border
    vec2 uv = v_uv;
    vec2 fragCoord = uv * v_size;
    float maxX = v_size.x - v_strokeThickness;
    float minX = v_strokeThickness;
    float maxY = v_size.y - v_strokeThickness;
    float minY = v_strokeThickness;

    if (fragCoord.x < maxX && fragCoord.x > minX &&
        fragCoord.y < maxY && fragCoord.y > minY) {
      fragColor = v_color;
    } else {
      fragColor = v_strokeColor;
    }
    fragColor.a *= v_opacity;
    fragColor.rgb *= fragColor.a;

    // vec2 v2CenteredPos     = abs(fragCoord - v_size.xy / 2.0);
    // vec2 v2HalfShapeSizePx = v_size.xy/2.0 - v_strokeThickness/2.0;

    // float fHalfBorderDist      = 0.0;
    // float fHalfBorderThickness = 0.0;

    // if (fragCoord.x > max(v_radius, v_strokeThickness) && 
    //     fragCoord.x < v_size.x - max(v_radius, v_strokeThickness))
    // {
    //     fHalfBorderDist      = v2CenteredPos.y - v2HalfShapeSizePx.y;
    //     fHalfBorderThickness = v_strokeThickness / 2.0;
    // }
    // else if (fragCoord.y > max(v_radius, v_strokeThickness) && 
    //          fragCoord.y < v_size.y - max(v_radius, v_strokeThickness))
    // {
    //     fHalfBorderDist      = v2CenteredPos.x - v2HalfShapeSizePx.x;
    //     fHalfBorderThickness = v_strokeThickness / 2.0;
    // }
    // else
    // {
    //     vec2 edgeVec = max(vec2(0.0), v_radius - vec2(
    //         uv.x > 0.5 ? v_size.x - fragCoord.x : fragCoord.x,
    //         uv.y > 0.5 ? v_size.y - fragCoord.y : fragCoord.y));
        
    //     float ellipse_ab    = v_radius-v_strokeThickness;
    //     vec2 ellipse_isect = (v_strokeThickness > v_radius || v_strokeThickness > v_radius) ? vec2(0.0) :
    //                             edgeVec.xy * ellipse_ab*ellipse_ab / length(ellipse_ab*edgeVec.yx); 
            
    //     fHalfBorderThickness = (v_radius - length(ellipse_isect)) / 2.0;
    //     fHalfBorderDist      = length(edgeVec) - (v_radius - fHalfBorderThickness);
    // }

    // vec4 v4FromColor = v_strokeColor;
    // v4FromColor.rgb *= v4FromColor.a;
    // vec4 v4ToColor   = vec4(0.0); // background color is transparent
    // if (fHalfBorderDist < 0.0) {
    //     v4ToColor = v_color;
    //     v4ToColor.rgb *= v4ToColor.a;
    // }

    // float mixPct = abs(fHalfBorderDist) - fHalfBorderThickness;

    // vec4 finalColor = mix(v4FromColor, v4ToColor, mixPct);
    // gl_FragColor = finalColor;
}`, _a = `#version 300 es
in vec2 a_position;

// UV coordinate
in vec2 a_uv;
out vec2 v_uv;

in vec2 a_size;
out vec2 v_size;

// Opacity 
in float a_opacity;
out float v_opacity;

in vec4 a_color;
out vec4 v_color;

in vec4 a_strokeColor;
out vec4 v_strokeColor;

in float a_strokeThickness;
out float v_strokeThickness;

uniform mat4 u_matrix;


void main() {
   // Set the vertex position using the ortho transform matrix
   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);

   // Pass through UV coords
   v_uv = a_uv;
   // Pass through size
   v_size = a_size;
   // Pass through the Opacity to the fragment shader
   v_opacity = a_opacity;
   // Pass through the color to the fragment shader
   v_color = a_color;
   // Pass through the stroke color to the fragment shader
   v_strokeColor = a_strokeColor;
   // Pass through the stroke thickenss to the fragment shader
   v_strokeThickness = a_strokeThickness;
}`;
class fa {
  constructor() {
    this.type = "ex.rectangle", this.priority = 0, this._maxRectangles = 10922, this._rectangleCount = 0, this._vertexIndex = 0, this._transparent = T.Transparent, this._scratch1 = w(0, 0), this._scratch2 = w(0, 0), this._scratch3 = w(0, 0), this._scratch4 = w(0, 0);
  }
  initialize(t, e) {
    this._gl = t, this._context = e, this._shader = new Lt({
      graphicsContext: e,
      fragmentSource: ua,
      vertexSource: _a
    }), this._shader.compile(), this._shader.use(), this._shader.setUniformMatrix("u_matrix", e.ortho), this._buffer = new Vt({
      gl: t,
      size: 64 * this._maxRectangles,
      type: "dynamic"
    }), this._layout = new te({
      gl: t,
      shader: this._shader,
      vertexBuffer: this._buffer,
      attributes: [
        ["a_position", 2],
        ["a_uv", 2],
        ["a_size", 2],
        ["a_opacity", 1],
        ["a_color", 4],
        ["a_strokeColor", 4],
        ["a_strokeThickness", 1]
      ]
    }), this._quads = new ni(t, this._maxRectangles, !0);
  }
  dispose() {
    this._buffer.dispose(), this._quads.dispose(), this._shader.dispose(), this._context = null, this._gl = null;
  }
  _isFull() {
    return this._rectangleCount >= this._maxRectangles;
  }
  draw(...t) {
    t[0] instanceof v && t[1] instanceof v ? this.drawLine.apply(this, t) : this.drawRectangle.apply(this, t);
  }
  drawLine(t, e, i, s = 1) {
    this._isFull() && this.flush(), this._rectangleCount++;
    const n = this._context.getTransform(), o = this._context.opacity, a = this._context.snapToPixel, h = e.sub(t), l = h.magnitude, c = h.normalize().perpendicular(), d = s / 2, u = n.multiply(c.scale(d, this._scratch1).add(t, this._scratch1), this._scratch1), _ = n.multiply(c.scale(-d, this._scratch2).add(t, this._scratch2), this._scratch2), p = n.multiply(c.scale(d, this._scratch3).add(e, this._scratch3), this._scratch3), g = n.multiply(c.scale(-d, this._scratch4).add(e, this._scratch4), this._scratch4);
    a && (u.x = ~~(u.x + M), u.y = ~~(u.y + M), p.x = ~~(p.x + M), p.y = ~~(p.y + M), _.x = ~~(_.x + M), _.y = ~~(_.y + M), g.x = ~~(g.x + M), g.y = ~~(g.y + M));
    const x = 0, m = 0, f = 1, b = 1, C = this._transparent, S = 0, I = 1, y = this._layout.vertexBuffer.bufferData;
    y[this._vertexIndex++] = u.x, y[this._vertexIndex++] = u.y, y[this._vertexIndex++] = x, y[this._vertexIndex++] = m, y[this._vertexIndex++] = l, y[this._vertexIndex++] = s, y[this._vertexIndex++] = o, y[this._vertexIndex++] = i.r / 255, y[this._vertexIndex++] = i.g / 255, y[this._vertexIndex++] = i.b / 255, y[this._vertexIndex++] = i.a, y[this._vertexIndex++] = C.r / 255, y[this._vertexIndex++] = C.g / 255, y[this._vertexIndex++] = C.b / 255, y[this._vertexIndex++] = C.a, y[this._vertexIndex++] = S / I, y[this._vertexIndex++] = _.x, y[this._vertexIndex++] = _.y, y[this._vertexIndex++] = x, y[this._vertexIndex++] = b, y[this._vertexIndex++] = l, y[this._vertexIndex++] = s, y[this._vertexIndex++] = o, y[this._vertexIndex++] = i.r / 255, y[this._vertexIndex++] = i.g / 255, y[this._vertexIndex++] = i.b / 255, y[this._vertexIndex++] = i.a, y[this._vertexIndex++] = C.r / 255, y[this._vertexIndex++] = C.g / 255, y[this._vertexIndex++] = C.b / 255, y[this._vertexIndex++] = C.a, y[this._vertexIndex++] = S / I, y[this._vertexIndex++] = p.x, y[this._vertexIndex++] = p.y, y[this._vertexIndex++] = f, y[this._vertexIndex++] = m, y[this._vertexIndex++] = l, y[this._vertexIndex++] = s, y[this._vertexIndex++] = o, y[this._vertexIndex++] = i.r / 255, y[this._vertexIndex++] = i.g / 255, y[this._vertexIndex++] = i.b / 255, y[this._vertexIndex++] = i.a, y[this._vertexIndex++] = C.r / 255, y[this._vertexIndex++] = C.g / 255, y[this._vertexIndex++] = C.b / 255, y[this._vertexIndex++] = C.a, y[this._vertexIndex++] = S / I, y[this._vertexIndex++] = g.x, y[this._vertexIndex++] = g.y, y[this._vertexIndex++] = f, y[this._vertexIndex++] = b, y[this._vertexIndex++] = l, y[this._vertexIndex++] = s, y[this._vertexIndex++] = o, y[this._vertexIndex++] = i.r / 255, y[this._vertexIndex++] = i.g / 255, y[this._vertexIndex++] = i.b / 255, y[this._vertexIndex++] = i.a, y[this._vertexIndex++] = C.r / 255, y[this._vertexIndex++] = C.g / 255, y[this._vertexIndex++] = C.b / 255, y[this._vertexIndex++] = C.a, y[this._vertexIndex++] = S / I;
  }
  drawRectangle(t, e, i, s, n = T.Transparent, o = 0) {
    this._isFull() && this.flush(), this._rectangleCount++;
    const a = this._context.getTransform(), h = this._context.opacity, l = this._context.snapToPixel, c = a.multiply(t.add(w(0, 0))), d = a.multiply(t.add(w(e, 0))), u = a.multiply(t.add(w(e, i))), _ = a.multiply(t.add(w(0, i)));
    l && (c.x = ~~(c.x + M), c.y = ~~(c.y + M), d.x = ~~(d.x + M), d.y = ~~(d.y + M), _.x = ~~(_.x + M), _.y = ~~(_.y + M), u.x = ~~(u.x + M), u.y = ~~(u.y + M));
    const p = 0, g = 0, x = 1, m = 1, f = this._layout.vertexBuffer.bufferData;
    f[this._vertexIndex++] = c.x, f[this._vertexIndex++] = c.y, f[this._vertexIndex++] = p, f[this._vertexIndex++] = g, f[this._vertexIndex++] = e, f[this._vertexIndex++] = i, f[this._vertexIndex++] = h, f[this._vertexIndex++] = s.r / 255, f[this._vertexIndex++] = s.g / 255, f[this._vertexIndex++] = s.b / 255, f[this._vertexIndex++] = s.a, f[this._vertexIndex++] = n.r / 255, f[this._vertexIndex++] = n.g / 255, f[this._vertexIndex++] = n.b / 255, f[this._vertexIndex++] = n.a, f[this._vertexIndex++] = o, f[this._vertexIndex++] = _.x, f[this._vertexIndex++] = _.y, f[this._vertexIndex++] = p, f[this._vertexIndex++] = m, f[this._vertexIndex++] = e, f[this._vertexIndex++] = i, f[this._vertexIndex++] = h, f[this._vertexIndex++] = s.r / 255, f[this._vertexIndex++] = s.g / 255, f[this._vertexIndex++] = s.b / 255, f[this._vertexIndex++] = s.a, f[this._vertexIndex++] = n.r / 255, f[this._vertexIndex++] = n.g / 255, f[this._vertexIndex++] = n.b / 255, f[this._vertexIndex++] = n.a, f[this._vertexIndex++] = o, f[this._vertexIndex++] = d.x, f[this._vertexIndex++] = d.y, f[this._vertexIndex++] = x, f[this._vertexIndex++] = g, f[this._vertexIndex++] = e, f[this._vertexIndex++] = i, f[this._vertexIndex++] = h, f[this._vertexIndex++] = s.r / 255, f[this._vertexIndex++] = s.g / 255, f[this._vertexIndex++] = s.b / 255, f[this._vertexIndex++] = s.a, f[this._vertexIndex++] = n.r / 255, f[this._vertexIndex++] = n.g / 255, f[this._vertexIndex++] = n.b / 255, f[this._vertexIndex++] = n.a, f[this._vertexIndex++] = o, f[this._vertexIndex++] = u.x, f[this._vertexIndex++] = u.y, f[this._vertexIndex++] = x, f[this._vertexIndex++] = m, f[this._vertexIndex++] = e, f[this._vertexIndex++] = i, f[this._vertexIndex++] = h, f[this._vertexIndex++] = s.r / 255, f[this._vertexIndex++] = s.g / 255, f[this._vertexIndex++] = s.b / 255, f[this._vertexIndex++] = s.a, f[this._vertexIndex++] = n.r / 255, f[this._vertexIndex++] = n.g / 255, f[this._vertexIndex++] = n.b / 255, f[this._vertexIndex++] = n.a, f[this._vertexIndex++] = o;
  }
  hasPendingDraws() {
    return this._rectangleCount !== 0;
  }
  flush() {
    if (this._rectangleCount === 0)
      return;
    const t = this._gl;
    this._shader.use(), this._layout.use(!0), this._shader.setUniformMatrix("u_matrix", this._context.ortho), this._quads.bind(), t.drawElements(t.TRIANGLES, this._rectangleCount * 6, this._quads.bufferGlType, 0), Z.DrawnImagesCount += this._rectangleCount, Z.DrawCallCount++, this._rectangleCount = 0, this._vertexIndex = 0;
  }
}
const ga = `#version 300 es
precision highp float;

// UV coord
in vec2 v_uv;

// Color coord to blend with image
in lowp vec4 v_color;

// Stroke color if used
in lowp vec4 v_strokeColor;

// Stroke thickness if used
in lowp float v_strokeThickness;

// Opacity
in float v_opacity;

out vec4 fragColor;

void main() {
  // make (0, 0) the center the uv 
  vec2 uv = v_uv * 2.0 - 1.0;

  vec4 color = v_color;
  vec4 strokeColor = v_strokeColor;

  // circle border is at radius 1.0 
  // dist is > 0 when inside the circle 
  float d = length(uv);
  float dist = 1.0 - length(uv);

  // Fade based on fwidth
  float fade = fwidth(dot(uv, uv));

  // if dist is greater than 0 step to 1;
  // when we cross this 0 threshold add a smooth fade
  float fill = smoothstep(-fade/2.0, fade/2.0, dist);

  // if dist is greater than the stroke thickness step to 1
  float stroke = 1.0 - smoothstep(v_strokeThickness, v_strokeThickness + fade, dist);

  strokeColor.a *= fill * stroke;
  strokeColor.rgb *= strokeColor.a;

  color.a *= fill * (1.0 - stroke);
  color.rgb *= color.a;

  vec4 finalColor = mix(vec4(0.0), (color + strokeColor), fill);
  finalColor.rgb = finalColor.rgb * v_opacity;
  finalColor.a = finalColor.a * v_opacity;
  fragColor = finalColor;
}`, pa = `#version 300 es
in vec2 a_position;

// UV coordinate
in vec2 a_uv;
out vec2 v_uv;

// Opacity 
in float a_opacity;
out float v_opacity;

in vec4 a_color;
out vec4 v_color;

in vec4 a_strokeColor;
out vec4 v_strokeColor;

in float a_strokeThickness;
out float v_strokeThickness;

uniform mat4 u_matrix;


void main() {
   // Set the vertex position using the ortho transform matrix
   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);

   // Pass through UV coords
   v_uv = a_uv;
   // Pass through the Opacity to the fragment shader
   v_opacity = a_opacity;
   // Pass through the color to the fragment shader
   v_color = a_color;
   // Pass through the stroke color to the fragment shader
   v_strokeColor = a_strokeColor;
   // Pass through the stroke thickenss to the fragment shader
   v_strokeThickness = a_strokeThickness;
}`;
class ma {
  constructor() {
    this.type = "ex.circle", this.priority = 0, this._maxCircles = 10922, this._circleCount = 0, this._vertexIndex = 0;
  }
  initialize(t, e) {
    this._gl = t, this._context = e, this._shader = new Lt({
      graphicsContext: e,
      fragmentSource: ga,
      vertexSource: pa
    }), this._shader.compile(), this._shader.use(), this._shader.setUniformMatrix("u_matrix", e.ortho), this._buffer = new Vt({
      gl: t,
      size: 56 * this._maxCircles,
      type: "dynamic"
    }), this._layout = new te({
      gl: t,
      shader: this._shader,
      vertexBuffer: this._buffer,
      attributes: [
        ["a_position", 2],
        ["a_uv", 2],
        ["a_opacity", 1],
        ["a_color", 4],
        ["a_strokeColor", 4],
        ["a_strokeThickness", 1]
      ]
    }), this._quads = new ni(t, this._maxCircles, !0);
  }
  dispose() {
    this._buffer.dispose(), this._quads.dispose(), this._shader.dispose(), this._context = null, this._gl = null;
  }
  _isFull() {
    return this._circleCount >= this._maxCircles;
  }
  draw(t, e, i, s = T.Transparent, n = 0) {
    this._isFull() && this.flush(), this._circleCount++;
    const o = this._context.getTransform(), a = this._context.opacity, h = this._context.snapToPixel, l = o.multiply(t.add(w(-e, -e))), c = o.multiply(t.add(w(e, -e))), d = o.multiply(t.add(w(e, e))), u = o.multiply(t.add(w(-e, e)));
    h && (l.x = ~~(l.x + M), l.y = ~~(l.y + M), c.x = ~~(c.x + M), c.y = ~~(c.y + M), u.x = ~~(u.x + M), u.y = ~~(u.y + M), d.x = ~~(d.x + M), d.y = ~~(d.y + M));
    const _ = 0, p = 0, g = 1, x = 1, m = this._layout.vertexBuffer.bufferData;
    m[this._vertexIndex++] = l.x, m[this._vertexIndex++] = l.y, m[this._vertexIndex++] = _, m[this._vertexIndex++] = p, m[this._vertexIndex++] = a, m[this._vertexIndex++] = i.r / 255, m[this._vertexIndex++] = i.g / 255, m[this._vertexIndex++] = i.b / 255, m[this._vertexIndex++] = i.a, m[this._vertexIndex++] = s.r / 255, m[this._vertexIndex++] = s.g / 255, m[this._vertexIndex++] = s.b / 255, m[this._vertexIndex++] = s.a, m[this._vertexIndex++] = n / e, m[this._vertexIndex++] = u.x, m[this._vertexIndex++] = u.y, m[this._vertexIndex++] = _, m[this._vertexIndex++] = x, m[this._vertexIndex++] = a, m[this._vertexIndex++] = i.r / 255, m[this._vertexIndex++] = i.g / 255, m[this._vertexIndex++] = i.b / 255, m[this._vertexIndex++] = i.a, m[this._vertexIndex++] = s.r / 255, m[this._vertexIndex++] = s.g / 255, m[this._vertexIndex++] = s.b / 255, m[this._vertexIndex++] = s.a, m[this._vertexIndex++] = n / e, m[this._vertexIndex++] = c.x, m[this._vertexIndex++] = c.y, m[this._vertexIndex++] = g, m[this._vertexIndex++] = p, m[this._vertexIndex++] = a, m[this._vertexIndex++] = i.r / 255, m[this._vertexIndex++] = i.g / 255, m[this._vertexIndex++] = i.b / 255, m[this._vertexIndex++] = i.a, m[this._vertexIndex++] = s.r / 255, m[this._vertexIndex++] = s.g / 255, m[this._vertexIndex++] = s.b / 255, m[this._vertexIndex++] = s.a, m[this._vertexIndex++] = n / e, m[this._vertexIndex++] = d.x, m[this._vertexIndex++] = d.y, m[this._vertexIndex++] = g, m[this._vertexIndex++] = x, m[this._vertexIndex++] = a, m[this._vertexIndex++] = i.r / 255, m[this._vertexIndex++] = i.g / 255, m[this._vertexIndex++] = i.b / 255, m[this._vertexIndex++] = i.a, m[this._vertexIndex++] = s.r / 255, m[this._vertexIndex++] = s.g / 255, m[this._vertexIndex++] = s.b / 255, m[this._vertexIndex++] = s.a, m[this._vertexIndex++] = n / e;
  }
  hasPendingDraws() {
    return this._circleCount !== 0;
  }
  flush() {
    if (this._circleCount === 0)
      return;
    const t = this._gl;
    this._shader.use(), this._layout.use(!0), this._shader.setUniformMatrix("u_matrix", this._context.ortho), this._quads.bind(), t.drawElements(t.TRIANGLES, this._circleCount * 6, this._quads.bufferGlType, 0), Z.DrawnImagesCount += this._circleCount, Z.DrawCallCount++, this._circleCount = 0, this._vertexIndex = 0;
  }
}
class xa {
  constructor() {
    this.z = 0, this.priority = 0, this.renderer = "", this.transform = j.identity(), this.state = {
      z: 0,
      opacity: 1,
      tint: T.White,
      material: null
    }, this.args = new Array(10);
  }
}
class Ns {
  constructor() {
    this.type = "ex.material", this.priority = 0, this._textures = [];
  }
  initialize(t, e) {
    this._gl = t, this._context = e, this._buffer = new Vt({
      gl: t,
      size: 24,
      // 6 components * 4 verts
      type: "dynamic"
    }), this._layout = new te({
      gl: t,
      vertexBuffer: this._buffer,
      attributes: [
        ["a_position", 2],
        ["a_uv", 2],
        ["a_screenuv", 2]
      ],
      suppressWarnings: !0
    }), this._quads = new ni(t, 1, !0);
  }
  dispose() {
    this._buffer.dispose(), this._quads.dispose(), this._textures.length = 0, this._context = null, this._gl = null;
  }
  draw(t, e, i, s, n, o, a, h, l) {
    var c, d, u, _, p;
    const g = this._gl, x = this._context.material;
    if (!x)
      return;
    const m = this._context.getTransform(), f = this._context.opacity, b = x.getShader(), C = this._layout.vertexBuffer.bufferData;
    let S = 0, I = (t == null ? void 0 : t.width) || s || 0, y = (t == null ? void 0 : t.height) || n || 0, k = [0, 0, (c = s != null ? s : t == null ? void 0 : t.width) != null ? c : 0, (d = n != null ? n : t == null ? void 0 : t.height) != null ? d : 0], L = [e != null ? e : 1, i != null ? i : 1];
    o !== void 0 && a !== void 0 && h !== void 0 && l !== void 0 && (k = [e != null ? e : 1, i != null ? i : 1, (u = s != null ? s : t == null ? void 0 : t.width) != null ? u : 0, (_ = n != null ? n : t == null ? void 0 : t.height) != null ? _ : 0], L = [o, a], I = h, y = l), e = k[0], i = k[1];
    const O = k[2], Q = k[3], st = w(L[0], L[1]), $ = w(L[0] + I, L[1]), H = w(L[0], L[1] + y), rt = w(L[0] + I, L[1] + y), lt = t.width || I, A = t.height || y, oe = e / lt, ae = i / A, he = (e + O - 0.01) / lt, Ue = (i + Q - 0.01) / A, Ui = m.getPosition(), Ms = Ui.add(rt), Fs = Ui.x / this._context.width, Ds = Ui.y / this._context.height, Bs = Ms.x / this._context.width, ks = Ms.y / this._context.height;
    C[S++] = st.x, C[S++] = st.y, C[S++] = oe, C[S++] = ae, C[S++] = Fs, C[S++] = Ds, C[S++] = H.x, C[S++] = H.y, C[S++] = oe, C[S++] = Ue, C[S++] = Fs, C[S++] = ks, C[S++] = $.x, C[S++] = $.y, C[S++] = he, C[S++] = ae, C[S++] = Bs, C[S++] = Ds, C[S++] = rt.x, C[S++] = rt.y, C[S++] = he, C[S++] = Ue, C[S++] = Bs, C[S++] = ks;
    let Ls = this._addImageAsTexture(t);
    x.use(), this._layout.shader = b, this._layout.use(!0), b.trySetUniformFloat("u_time_ms", performance.now()), b.trySetUniformFloat("u_opacity", f), b.trySetUniformFloatVector("u_resolution", w(this._context.width, this._context.height)), b.trySetUniformFloatVector("u_graphic_resolution", w(lt, A)), b.trySetUniformFloatVector("u_size", w(O, Q)), b.trySetUniformMatrix("u_matrix", this._context.ortho), b.trySetUniformMatrix("u_transform", m.to4x4()), x.isOverridingGraphic && (p = x.images.u_graphic) != null && p.image && (Ls = this._addImageAsTexture(x.images.u_graphic.image)), g.activeTexture(g.TEXTURE0 + 0), g.bindTexture(g.TEXTURE_2D, Ls), b.trySetUniformInt("u_graphic", 0), x.isUsingScreenTexture && (g.activeTexture(g.TEXTURE0 + 1), g.bindTexture(g.TEXTURE_2D, this._context.materialScreenTexture), b.trySetUniformInt("u_screen_texture", 1)), this._quads.bind(), g.drawElements(g.TRIANGLES, 6, this._quads.bufferGlType, 0), Z.DrawnImagesCount++, Z.DrawCallCount++;
  }
  _addImageAsTexture(t) {
    const e = t.getAttribute(z.Filtering), i = e ? ei(e) : void 0, s = Wt(t.getAttribute(z.WrappingX)), n = Wt(t.getAttribute(z.WrappingY)), o = t.getAttribute("forceUpload") === "true", a = this._context.textureLoader.load(
      t,
      {
        filtering: i,
        wrapping: { x: s, y: n }
      },
      o
    );
    return t.removeAttribute("forceUpload"), this._textures.indexOf(a) === -1 && this._textures.push(a), a;
  }
  hasPendingDraws() {
    return !1;
  }
  flush() {
  }
}
const va = `#version 300 es
precision mediump float;

// UV coord
in vec2 v_texcoord;

// Textures in the current draw
uniform sampler2D u_textures[%%count%%];

uniform bool u_pixelart;

in float v_texture_index;

in float v_opacity;

in vec4 v_tint;

// texture resolution
in vec2 v_res;

in vec2 v_size;

in vec2 v_uv_min;
in vec2 v_uv_max;

out vec4 fragColor;

// Inigo Quilez pixel art filter https://jorenjoestar.github.io/post/pixel_art_filtering/
vec2 uv_iq(in vec2 uv, in vec2 texture_size) {
  vec2 pixel = uv * texture_size;

  vec2 seam=floor(pixel+.5);
  vec2 dudv=fwidth(pixel);
  pixel=seam+clamp((pixel-seam)/dudv,-.5,.5);

  return pixel/texture_size;
}

float lerp(float from, float to, float rel){
  return ((1. - rel) * from) + (rel * to);
}

float invLerp(float from, float to, float value){
  return (value - from) / (to - from);
}

float remap(float origFrom, float origTo, float targetFrom, float targetTo, float value){
  float rel = invLerp(origFrom, origTo, value);
  return lerp(targetFrom, targetTo, rel);
}

void main(){
  // In order to support the most efficient sprite batching, we have multiple
  // textures loaded into the gpu (usually 8) this picker logic skips over textures
  // that do not apply to a particular sprite.

  vec4 color=vec4(1.,0,0,1.);
  vec2 remapped_uv = v_texcoord;
  remapped_uv.x = remap(0.,1., v_uv_min.x, v_uv_max.x, v_texcoord.x);
  remapped_uv.y = remap(0.,1., v_uv_min.y, v_uv_max.y, v_texcoord.y);
  vec2 uv = u_pixelart ? uv_iq(remapped_uv, v_size) : remapped_uv;

  // GLSL is templated out to pick the right texture and set the vec4 color
  %%texture_picker%%

  color.rgb = color.rgb * v_opacity;
  color.a = color.a * v_opacity;
  fragColor = color * v_tint;
}`, wa = `#version 300 es
layout(location=0) in vec2 pos;
layout(location=1) in vec2 a_texcoord;
out vec2 v_texcoord;

layout(location=2) in vec2 a_offset;
layout(location=3) in vec2 a_mat_column1;
layout(location=4) in vec2 a_mat_column2;
layout(location=5) in vec2 a_mat_column3;

layout(location=6) in float a_opacity;
out float v_opacity;

// Texture resolution (could be bigger than a_size)
layout(location=7) in vec2 a_res;
out vec2 v_res;

// Final size of graphic
layout(location=8) in vec2 a_size;
out vec2 v_size;

layout(location=9) in lowp float a_texture_index;
out lowp float v_texture_index;

layout(location=10) in vec2 a_uv_min;
out vec2 v_uv_min;

layout(location=11) in vec2 a_uv_max;
out vec2 v_uv_max;

layout(location=12) in vec4 a_tint;
out vec4 v_tint;

uniform mat4 u_matrix;

void main(){
  mat4 world_mat = mat4(
    a_mat_column1.x, a_mat_column1.y, 0., 0.,
    a_mat_column2.x, a_mat_column2.y, 0., 0.,
    0.             , 0.             , 1., 0.,
    a_mat_column3.x, a_mat_column3.y, 0., 1.
  );

  vec2 newPos = vec2(pos.x * a_res.x, pos.y * a_res.y);
  gl_Position = u_matrix * world_mat * vec4(newPos + a_offset, 0., 1.);

  v_opacity = a_opacity;
  v_texcoord = a_texcoord;
  v_uv_min = a_uv_min;
  v_uv_max = a_uv_max;
  v_res = a_res;
  v_size = a_size;
  v_texture_index = a_texture_index;
  v_tint = a_tint;
}`;
class ba {
  constructor(t) {
    this.type = "ex.image-v2", this.priority = 0, this._maxImages = 2e4, this._maxTextures = 0, this._components = 22, this._imageCount = 0, this._textures = [], this._textureIndex = 0, this._textureToIndex = /* @__PURE__ */ new Map(), this._images = /* @__PURE__ */ new Set(), this._vertexIndex = 0, this._imageToWidth = /* @__PURE__ */ new Map(), this._imageToHeight = /* @__PURE__ */ new Map(), this._view = [0, 0, 0, 0], this._dest = [0, 0], this._defaultTint = T.White, this.pixelArtSampler = t.pixelArtSampler, this.uvPadding = t.uvPadding;
  }
  initialize(t, e) {
    this._gl = t, this._context = e;
    const i = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), s = vs(t, i);
    this._maxTextures = Math.min(i, s);
    const n = this._transformFragmentSource(va, this._maxTextures);
    this._shader = new Lt({
      graphicsContext: e,
      fragmentSource: n,
      vertexSource: wa
    }), this._shader.compile(), this._shader.use(), this._shader.setUniformMatrix("u_matrix", e.ortho), this._shader.setUniformIntArray(
      "u_textures",
      [...Array(this._maxTextures)].map((d, u) => u)
    ), this._vao = t.createVertexArray(), t.bindVertexArray(this._vao), this._quadMesh = new Float32Array([
      // pos       uv
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1
    ]), this._meshBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._meshBuffer), t.bufferData(t.ARRAY_BUFFER, this._quadMesh, t.STATIC_DRAW), t.vertexAttribPointer(0, 2, t.FLOAT, !1, 16, 0), t.enableVertexAttribArray(0), t.vertexAttribPointer(1, 2, t.FLOAT, !1, 16, 8), t.enableVertexAttribArray(1), t.bindBuffer(t.ARRAY_BUFFER, null);
    const o = this._components;
    this._transformData = new Vt({
      gl: t,
      size: o * this._maxImages,
      // components * images
      type: "dynamic"
    }), this._transformData.bind();
    let a = 0, h = 2;
    const l = 4, c = o * 4;
    t.vertexAttribPointer(h++, 2, t.FLOAT, !1, c, a), t.enableVertexAttribArray(2), a += 2 * l, t.vertexAttribPointer(h++, 2, t.FLOAT, !1, c, a), t.enableVertexAttribArray(3), a += 2 * l, t.vertexAttribPointer(h++, 2, t.FLOAT, !1, c, a), t.enableVertexAttribArray(4), a += 2 * l, t.vertexAttribPointer(h++, 2, t.FLOAT, !1, c, a), t.enableVertexAttribArray(5), a += 2 * l, t.vertexAttribPointer(h++, 1, t.FLOAT, !1, c, a), t.enableVertexAttribArray(6), a += 1 * l, t.vertexAttribPointer(h++, 2, t.FLOAT, !1, c, a), t.enableVertexAttribArray(7), a += 2 * l, t.vertexAttribPointer(h++, 2, t.FLOAT, !1, c, a), t.enableVertexAttribArray(8), a += 2 * l, t.vertexAttribPointer(h++, 1, t.FLOAT, !1, c, a), t.enableVertexAttribArray(9), a += 1 * l, t.vertexAttribPointer(h++, 2, t.FLOAT, !1, c, a), t.enableVertexAttribArray(10), a += 2 * l, t.vertexAttribPointer(h++, 2, t.FLOAT, !1, c, a), t.enableVertexAttribArray(11), a += 2 * l, t.vertexAttribPointer(h++, 4, t.FLOAT, !1, c, a), t.enableVertexAttribArray(12), a += 4 * l, t.vertexAttribDivisor(2, 1), t.vertexAttribDivisor(3, 1), t.vertexAttribDivisor(4, 1), t.vertexAttribDivisor(5, 1), t.vertexAttribDivisor(6, 1), t.vertexAttribDivisor(7, 1), t.vertexAttribDivisor(8, 1), t.vertexAttribDivisor(9, 1), t.vertexAttribDivisor(10, 1), t.vertexAttribDivisor(11, 1), t.vertexAttribDivisor(12, 1), t.bindVertexArray(null);
  }
  _bindData(t) {
    const e = this._components;
    this._transformData.bind(), this._transformData.upload(e * this._imageCount), t.bindVertexArray(this._vao);
  }
  dispose() {
    this._transformData.dispose(), this._shader.dispose(), this._textures.length = 0, this._context = null, this._gl = null;
  }
  _transformFragmentSource(t, e) {
    let i = t.replace("%%count%%", e.toString()), s = "";
    for (let n = 0; n < e; n++)
      n === 0 ? s += `if (v_texture_index <= ${n}.5) {
` : s += `   else if (v_texture_index <= ${n}.5) {
`, s += `      color = texture(u_textures[${n}], uv);
`, s += `   }
`;
    return i = i.replace("%%texture_picker%%", s), i;
  }
  _addImageAsTexture(t) {
    if (this._images.has(t))
      return;
    const e = t.getAttribute(z.Filtering), i = e ? ei(e) : void 0, s = Wt(t.getAttribute(z.WrappingX)), n = Wt(t.getAttribute(z.WrappingY)), o = t.getAttribute("forceUpload") === "true", a = this._context.textureLoader.load(
      t,
      {
        filtering: i,
        wrapping: { x: s, y: n }
      },
      o
    );
    t.removeAttribute("forceUpload"), this._textures.indexOf(a) === -1 && (this._textures.push(a), this._textureToIndex.set(a, this._textureIndex++), this._images.add(t));
  }
  _bindTextures(t) {
    const e = Math.min(this._textureIndex, this._maxTextures);
    for (let i = 0; i < e; i++)
      t.activeTexture(t.TEXTURE0 + i), t.bindTexture(t.TEXTURE_2D, this._textures[i] || this._textures[0]);
  }
  _getTextureIdForImage(t) {
    var e;
    if (t) {
      const i = this._context.textureLoader.get(t);
      return (e = this._textureToIndex.get(i)) != null ? e : -1;
    }
    return -1;
  }
  _isFull() {
    return this._imageCount >= this._maxImages || this._textures.length >= this._maxTextures;
  }
  _getImageWidth(t) {
    let e = this._imageToWidth.get(t);
    return e === void 0 && (e = t.width, this._imageToWidth.set(t, e)), e;
  }
  _getImageHeight(t) {
    let e = this._imageToHeight.get(t);
    return e === void 0 && (e = t.height, this._imageToHeight.set(t, e)), e;
  }
  draw(t, e, i, s, n, o, a, h, l) {
    var c, d, u, _;
    this._isFull() && this.flush(), this._imageCount++, this._addImageAsTexture(t);
    const p = this._getImageWidth(t), g = this._getImageHeight(t);
    let x = p || s || 0, m = g || n || 0;
    this._view[0] = 0, this._view[1] = 0, this._view[2] = (c = s != null ? s : p) != null ? c : 0, this._view[3] = (d = n != null ? n : g) != null ? d : 0, this._dest[0] = e != null ? e : 1, this._dest[1] = i != null ? i : 1, o !== void 0 && a !== void 0 && h !== void 0 && l !== void 0 && (this._view[0] = e != null ? e : 1, this._view[1] = i != null ? i : 1, this._view[2] = (u = s != null ? s : p) != null ? u : 0, this._view[3] = (_ = n != null ? n : g) != null ? _ : 0, this._dest[0] = o, this._dest[1] = a, x = h, m = l), e = this._view[0], i = this._view[1];
    const f = this._view[2], b = this._view[3], C = this._context.getTransform(), S = this._context.opacity;
    this._context.snapToPixel && (this._dest[0] = ~~(this._dest[0] + M), this._dest[1] = ~~(this._dest[1] + M));
    const y = this._context.tint || this._defaultTint, k = this._getTextureIdForImage(t), L = p || x, O = g || m, Q = (e + this.uvPadding) / L, st = (i + this.uvPadding) / O, $ = (e + f - this.uvPadding) / L, H = (i + b - this.uvPadding) / O, rt = p, lt = g, A = this._transformData.bufferData;
    A[this._vertexIndex++] = this._dest[0], A[this._vertexIndex++] = this._dest[1], A[this._vertexIndex++] = C.data[0], A[this._vertexIndex++] = C.data[1], A[this._vertexIndex++] = C.data[2], A[this._vertexIndex++] = C.data[3], A[this._vertexIndex++] = C.data[4], A[this._vertexIndex++] = C.data[5], A[this._vertexIndex++] = S, A[this._vertexIndex++] = x, A[this._vertexIndex++] = m, A[this._vertexIndex++] = rt, A[this._vertexIndex++] = lt, A[this._vertexIndex++] = k, A[this._vertexIndex++] = Q, A[this._vertexIndex++] = st, A[this._vertexIndex++] = $, A[this._vertexIndex++] = H, A[this._vertexIndex++] = y.r / 255, A[this._vertexIndex++] = y.g / 255, A[this._vertexIndex++] = y.b / 255, A[this._vertexIndex++] = y.a;
  }
  hasPendingDraws() {
    return this._imageCount !== 0;
  }
  flush() {
    if (this._imageCount === 0)
      return;
    const t = this._gl;
    this._shader.use(), this._bindData(t), this._shader.setUniformMatrix("u_matrix", this._context.ortho), this._shader.setUniformBoolean("u_pixelart", this.pixelArtSampler), this._bindTextures(t), t.drawArraysInstanced(t.TRIANGLES, 0, 6, this._imageCount), Z.DrawnImagesCount += this._imageCount, Z.DrawCallCount++, t.bindVertexArray(null), this._imageCount = 0, this._vertexIndex = 0, this._textures.length = 0, this._textureIndex = 0, this._textureToIndex.clear(), this._images.clear(), this._imageToWidth.clear(), this._imageToHeight.clear();
  }
}
const M = 1e-4;
class ya {
  constructor(t) {
    this._webglCtx = t, this._debugText = new fr();
  }
  /**
   * Draw a debugging rectangle to the graphics context
   *
   * Debugging draws are independent of scale/zoom
   * @param x
   * @param y
   * @param width
   * @param height
   */
  drawRect(t, e, i, s, n = { color: T.Black }) {
    this.drawLine(w(t, e), w(t + i, e), { ...n }), this.drawLine(w(t + i, e), w(t + i, e + s), { ...n }), this.drawLine(w(t + i, e + s), w(t, e + s), { ...n }), this.drawLine(w(t, e + s), w(t, e), { ...n });
  }
  /**
   * Draw a debugging line to the graphics context
   *
   * Debugging draws are independent of scale/zoom
   * @param start
   * @param end
   * @param lineOptions
   */
  drawLine(t, e, i) {
    var s;
    this._webglCtx.save(), this._webglCtx.z = i != null && i.dashed ? St.config.settings.z.dashed : St.config.settings.z.solid, this._webglCtx.draw(
      "ex.debug-line",
      t,
      e,
      (s = i == null ? void 0 : i.color) != null ? s : T.Black,
      i == null ? void 0 : i.lineWidth,
      i == null ? void 0 : i.dashed
    ), this._webglCtx.restore();
  }
  /**
   * Draw a debugging point to the graphics context
   *
   * Debugging draws are independent of scale/zoom
   * @param point
   * @param pointOptions
   */
  drawPoint(t, e = { color: T.Black, size: 5 }) {
    this._webglCtx.save(), this._webglCtx.z = St.config.settings.z.point, this._webglCtx.draw("ex.debug-point", t, e.color, e.size), this._webglCtx.restore();
  }
  /**
   * Draw a debugging circle to the graphics context
   *
   * Debugging draws are independent of scale/zoom
   */
  drawCircle(t, e, i, s, n) {
    this._webglCtx.save(), this._webglCtx.z = St.config.settings.z.solid, this._webglCtx.draw("ex.debug-circle", t, e, i, s, n), this._webglCtx.restore();
  }
  /**
   * Draw some debugging text to the graphics context
   *
   * Debugging draws are independent of scale/zoom
   */
  drawText(t, e) {
    this._webglCtx.save(), this._webglCtx.z = St.config.settings.z.text, this._debugText.write(this._webglCtx, t, e), this._webglCtx.restore();
  }
}
class Qt {
  constructor(t) {
    this._logger = R.getInstance(), this._renderers = /* @__PURE__ */ new Map(), this._lazyRenderersFactory = /* @__PURE__ */ new Map(), this.imageRenderer = We.isEnabled("use-legacy-image-renderer") ? "ex.image" : "ex.image-v2", this._isDrawLifecycle = !1, this.useDrawSorting = !0, this._drawCallPool = new us(() => new xa(), void 0, 4e3), this._drawCallIndex = 0, this._drawCalls = new Array(4e3).fill(null), this._postProcessTargets = [], this._postprocessors = [], this._transform = new Fo(), this._state = new _r(), this.snapToPixel = !1, this.smoothing = !1, this.pixelArtSampler = !1, this.uvPadding = 0.01, this.backgroundColor = T.ExcaliburBlue, this.multiSampleAntialiasing = !0, this.transparency = !0, this._isContextLost = !1, this._disposed = !1, this._imageToWidth = /* @__PURE__ */ new Map(), this._imageToHeight = /* @__PURE__ */ new Map(), this._totalPostProcessorTime = 0;
    const {
      canvasElement: e,
      context: i,
      enableTransparency: s,
      antialiasing: n,
      uvPadding: o,
      multiSampleAntialiasing: a,
      pixelArtSampler: h,
      powerPreference: l,
      snapToPixel: c,
      backgroundColor: d,
      useDrawSorting: u,
      garbageCollector: _,
      handleContextLost: p,
      handleContextRestored: g
    } = t;
    if (this.__gl = i != null ? i : e.getContext("webgl2", {
      antialias: n != null ? n : this.smoothing,
      premultipliedAlpha: !1,
      alpha: s != null ? s : this.transparency,
      depth: !1,
      powerPreference: l != null ? l : "high-performance"
    }), !this.__gl)
      throw Error("Failed to retrieve webgl context from browser");
    p && this.__gl.canvas.addEventListener("webglcontextlost", p, !1), g && this.__gl.canvas.addEventListener("webglcontextrestored", g, !1), this.__gl.canvas.addEventListener("webglcontextlost", () => {
      this._isContextLost = !0;
    }), this.__gl.canvas.addEventListener("webglcontextrestored", () => {
      this._isContextLost = !1;
    }), this.textureLoader = new Ge(this.__gl, _), this.snapToPixel = c != null ? c : this.snapToPixel, this.smoothing = n != null ? n : this.smoothing, this.transparency = s != null ? s : this.transparency, this.pixelArtSampler = h != null ? h : this.pixelArtSampler, this.uvPadding = o != null ? o : this.uvPadding, this.multiSampleAntialiasing = typeof a == "boolean" ? a : this.multiSampleAntialiasing, this.samples = typeof a == "object" ? a.samples : void 0, this.backgroundColor = d != null ? d : this.backgroundColor, this.useDrawSorting = u != null ? u : this.useDrawSorting, this._drawCallPool.disableWarnings = !0, this._drawCallPool.preallocate(), this._init();
  }
  get z() {
    return this._state.current.z;
  }
  set z(t) {
    this._state.current.z = t;
  }
  get opacity() {
    return this._state.current.opacity;
  }
  set opacity(t) {
    this._state.current.opacity = t;
  }
  get tint() {
    return this._state.current.tint;
  }
  set tint(t) {
    this._state.current.tint = t;
  }
  get width() {
    return this.__gl.canvas.width;
  }
  get height() {
    return this.__gl.canvas.height;
  }
  get ortho() {
    return this._ortho;
  }
  /**
   * Checks the underlying webgl implementation if the requested internal resolution is supported
   * @param dim
   */
  checkIfResolutionSupported(t) {
    let e = !0;
    return (t.width > 4096 || t.height > 4096) && (e = !1), e;
  }
  dispose() {
    if (!this._disposed) {
      this._disposed = !0, this.textureLoader.dispose();
      for (const t of this._renderers.values())
        t.dispose();
      this._renderers.clear(), this._drawCallPool.dispose(), this._drawCalls.length = 0, this.__gl = null;
    }
  }
  _init() {
    const t = this.__gl;
    if (this._ortho = Tt.ortho(0, t.canvas.width, t.canvas.height, 0, 400, -400), t.viewport(0, 0, t.canvas.width, t.canvas.height), t.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a), t.clear(t.COLOR_BUFFER_BIT), t.enable(t.BLEND), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ONE, t.ONE_MINUS_SRC_ALPHA), t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA), t.depthMask(!1), this.register(
      new da({
        uvPadding: this.uvPadding,
        pixelArtSampler: this.pixelArtSampler
      })
    ), this.register(new Ns()), this.register(new fa()), this.register(new ma()), this.lazyRegister("ex.debug-circle", () => new ra()), this.lazyRegister("ex.debug-point", () => new ia()), this.lazyRegister("ex.debug-line", () => new Ko()), this.lazyRegister("ex.particle", () => new $o()), this.register(
      new ba({
        uvPadding: this.uvPadding,
        pixelArtSampler: this.pixelArtSampler
      })
    ), this.materialScreenTexture = t.createTexture(), !this.materialScreenTexture)
      throw new Error("Could not create screen texture!");
    t.bindTexture(t.TEXTURE_2D, this.materialScreenTexture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, this.width, this.height, 0, t.RGBA, t.UNSIGNED_BYTE, null), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.REPEAT), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.REPEAT), t.bindTexture(t.TEXTURE_2D, null), this._screenRenderer = new ha(this), this._renderTarget = new ri({
      gl: t,
      transparency: this.transparency,
      width: t.canvas.width,
      height: t.canvas.height
    }), this._postProcessTargets = [
      new ri({
        gl: t,
        transparency: this.transparency,
        width: t.canvas.width,
        height: t.canvas.height
      }),
      new ri({
        gl: t,
        transparency: this.transparency,
        width: t.canvas.width,
        height: t.canvas.height
      })
    ], this._msaaTarget = new ri({
      gl: t,
      transparency: this.transparency,
      width: t.canvas.width,
      height: t.canvas.height,
      antialias: this.multiSampleAntialiasing,
      samples: this.samples
    }), this.debug = new ya(this);
  }
  register(t) {
    this._renderers.set(t.type, t), t.initialize(this.__gl, this);
  }
  lazyRegister(t, e) {
    this._lazyRenderersFactory.set(t, e);
  }
  get(t) {
    let e = this._renderers.get(t);
    if (!e) {
      const i = this._lazyRenderersFactory.get(t);
      i && (this._logger.debug("lazy init renderer:", t), e = i(), this.register(e));
    }
    return e;
  }
  _isCurrentRenderer(t) {
    return !this._currentRenderer || this._currentRenderer === t;
  }
  beginDrawLifecycle() {
    this._isDrawLifecycle = !0;
  }
  endDrawLifecycle() {
    this._isDrawLifecycle = !1;
  }
  draw(t, ...e) {
    if (e.length > 9)
      throw new Error("Only 10 or less renderer arguments are supported!;");
    if (this._isDrawLifecycle || this._logger.warnOnce(
      `Attempting to draw outside the the drawing lifecycle (preDraw/postDraw) is not supported and is a source of bugs/errors.
If you want to do custom drawing, use Actor.graphics, or any onPreDraw or onPostDraw handler.`
    ), this._isContextLost) {
      this._logger.errorOnce(`Unable to draw ${t}, the webgl context is lost`);
      return;
    }
    const i = this.get(t);
    if (i)
      if (this.useDrawSorting) {
        const s = this._drawCallPool.get();
        s.z = this._state.current.z, s.priority = i.priority, s.renderer = t, this.getTransform().clone(s.transform), s.state.z = this._state.current.z, s.state.opacity = this._state.current.opacity, s.state.tint = this._state.current.tint, s.state.material = this._state.current.material, s.args[0] = e[0], s.args[1] = e[1], s.args[2] = e[2], s.args[3] = e[3], s.args[4] = e[4], s.args[5] = e[5], s.args[6] = e[6], s.args[7] = e[7], s.args[8] = e[8], s.args[9] = e[9], this._drawCalls[this._drawCallIndex++] = s;
      } else
        this._currentRenderer || (this._currentRenderer = i), this._isCurrentRenderer(i) || this._currentRenderer.flush(), i.draw(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9]), this._currentRenderer = i;
    else
      throw Error(`No renderer with name ${t} has been registered`);
  }
  resetTransform() {
    this._transform.reset();
  }
  updateViewport(t) {
    const e = this.__gl;
    this._ortho = this._ortho = Tt.ortho(0, t.width, t.height, 0, 400, -400), this._renderTarget.setResolution(e.canvas.width, e.canvas.height), this._msaaTarget.setResolution(e.canvas.width, e.canvas.height), this._postProcessTargets[0].setResolution(e.canvas.width, e.canvas.height), this._postProcessTargets[1].setResolution(e.canvas.width, e.canvas.height);
  }
  _getImageWidth(t) {
    let e = this._imageToWidth.get(t);
    return e === void 0 && (e = t.width, this._imageToWidth.set(t, e)), e;
  }
  _getImageHeight(t) {
    let e = this._imageToHeight.get(t);
    return e === void 0 && (e = t.height, this._imageToHeight.set(t, e)), e;
  }
  drawImage(t, e, i, s, n, o, a, h, l) {
    if (!(s === 0 || n === 0)) {
      {
        if (h === 0 || l === 0)
          return;
        if (this._getImageWidth(t) === 0 || this._getImageHeight(t) === 0)
          return;
      }
      if (!t) {
        R.getInstance().warn("Cannot draw a null or undefined image"), console.trace && console.trace();
        return;
      }
      this._state.current.material ? this.draw("ex.material", t, e, i, s, n, o, a, h, l) : this.imageRenderer === "ex.image" ? this.draw(this.imageRenderer, t, e, i, s, n, o, a, h, l) : this.draw(this.imageRenderer, t, e, i, s, n, o, a, h, l);
    }
  }
  drawLine(t, e, i, s = 1) {
    this.draw("ex.rectangle", t, e, i, s);
  }
  drawRectangle(t, e, i, s, n, o) {
    this.draw("ex.rectangle", t, e, i, s, n, o);
  }
  drawCircle(t, e, i, s, n) {
    this.draw("ex.circle", t, e, i, s, n);
  }
  save() {
    this._transform.save(), this._state.save();
  }
  restore() {
    this._transform.restore(), this._state.restore();
  }
  translate(t, e) {
    this._transform.translate(this.snapToPixel ? ~~(t + M) : t, this.snapToPixel ? ~~(e + M) : e);
  }
  rotate(t) {
    this._transform.rotate(t);
  }
  scale(t, e) {
    this._transform.scale(t, e);
  }
  transform(t) {
    this._transform.current = t;
  }
  getTransform() {
    return this._transform.current;
  }
  multiply(t) {
    this._transform.current.multiply(t, this._transform.current);
  }
  addPostProcessor(t) {
    this._postprocessors.push(t), t.initialize(this);
  }
  removePostProcessor(t) {
    const e = this._postprocessors.indexOf(t);
    e !== -1 && this._postprocessors.splice(e, 1);
  }
  clearPostProcessors() {
    this._postprocessors.length = 0;
  }
  updatePostProcessors(t) {
    for (const e of this._postprocessors) {
      const i = e.getShader();
      i.use();
      const s = i.getUniformDefinitions();
      this._totalPostProcessorTime += t, s.find((n) => n.name === "u_time_ms") && i.setUniformFloat("u_time_ms", this._totalPostProcessorTime), s.find((n) => n.name === "u_elapsed_ms") && i.setUniformFloat("u_elapsed_ms", t), s.find((n) => n.name === "u_resolution") && i.setUniformFloatVector("u_resolution", w(this.width, this.height)), e.onUpdate && e.onUpdate(t);
    }
  }
  set material(t) {
    this._state.current.material = t;
  }
  get material() {
    return this._state.current.material;
  }
  /**
   * Creates and initializes the material which compiles the internal shader
   * @param options
   * @returns Material
   */
  createMaterial(t) {
    return new Jo({ ...t, graphicsContext: this });
  }
  createShader(t) {
    const { name: e, vertexSource: i, fragmentSource: s, uniforms: n, images: o, startingTextureSlot: a } = t, h = new Lt({
      name: e,
      graphicsContext: this,
      vertexSource: i,
      fragmentSource: s,
      uniforms: n,
      images: o,
      startingTextureSlot: a
    });
    return h.compile(), h;
  }
  clear() {
    const t = this.__gl;
    (this.multiSampleAntialiasing ? this._msaaTarget : this._renderTarget).use(), t.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a), t.clear(t.COLOR_BUFFER_BIT);
  }
  /**
   * Flushes all batched rendering to the screen
   */
  flush() {
    var t;
    if (this._isContextLost) {
      this._logger.errorOnce("Unable to flush the webgl context is lost");
      return;
    }
    let e = this.multiSampleAntialiasing ? this._msaaTarget : this._renderTarget;
    if (e.use(), this.useDrawSorting) {
      for (let o = this._drawCallIndex; o < this._drawCalls.length; o++)
        this._drawCalls[o] = null;
      const i = /* @__PURE__ */ new Map();
      for (const [o] of this._renderers) {
        let a = 0;
        for (a = 0; a < this._drawCallIndex && this._drawCalls[a].renderer !== o; a++)
          ;
        i.set(o, a);
      }
      this._drawCalls.sort((o, a) => {
        if (o === null || a === null)
          return 0;
        const h = o.z - a.z, l = i.get(o.renderer) - i.get(a.renderer), c = o.priority - a.priority;
        return h === 0 ? c === 0 ? l : c : h;
      });
      const s = this._transform.current, n = this._state.current;
      if (this._drawCalls.length && this._drawCallIndex) {
        let o = this._drawCalls[0].renderer, a = this.get(o);
        for (let h = 0; h < this._drawCallIndex; h++)
          this._transform.current = this._drawCalls[h].transform, this._state.current = this._drawCalls[h].state, this._drawCalls[h].renderer !== o && (a.flush(), o = this._drawCalls[h].renderer, a = this.get(o), Z.RendererSwaps++), a instanceof Ns && ((t = this.material) != null && t.isUsingScreenTexture) && (e.copyToTexture(this.materialScreenTexture), e.use()), a.draw(...this._drawCalls[h].args);
        a.hasPendingDraws() && a.flush();
      }
      this._transform.current = s, this._state.current = n, this._drawCallPool.done(), this._drawCallIndex = 0, this._imageToHeight.clear(), this._imageToWidth.clear();
    } else
      for (const i of this._renderers.values())
        i.hasPendingDraws() && i.flush();
    e.disable(), this._postprocessors.length > 0 && e.toRenderSource().use();
    for (let i = 0; i < this._postprocessors.length; i++)
      e = this._postProcessTargets[i % 2], this._postProcessTargets[i % 2].use(), this._screenRenderer.renderWithPostProcessor(this._postprocessors[i]), this._postProcessTargets[i % 2].toRenderSource().use();
    e.blitToScreen();
  }
}
class Se {
  constructor(t, e, i, s) {
    this.font = t, this.text = e, this.color = i, this.maxWidth = s, this._textFragments = [], this.disposed = !1, this._dirty = !0, this.canvas = document.createElement("canvas");
    const n = this.canvas.getContext("2d");
    if (!n)
      throw new Error("Unable to create FontTextInstance, internal canvas failed to create");
    this.ctx = n, this.dimensions = this.measureText(e), this._setDimension(this.dimensions, this.ctx), this._lastHashCode = this.getHashCode();
  }
  measureText(t, e) {
    if (this.disposed)
      throw Error("Accessing disposed text instance! " + this.text);
    let i = null;
    e != null ? i = this._getLinesFromText(t, e) : i = t.split(`
`);
    const s = i.reduce((u, _) => u.length > _.length ? u : _);
    this._applyFont(this.ctx);
    const n = this.ctx.measureText(s);
    let o = Math.abs(n.actualBoundingBoxAscent) + Math.abs(n.actualBoundingBoxDescent);
    const a = o * i.length;
    o = a;
    const h = a - Math.abs(n.actualBoundingBoxAscent), l = 0, c = 0;
    return new F({
      left: l - Math.abs(n.actualBoundingBoxLeft) - this.font.padding,
      top: c - Math.abs(n.actualBoundingBoxAscent) - this.font.padding,
      bottom: c + h + this.font.padding,
      right: l + Math.abs(n.actualBoundingBoxRight) + this.font.padding
    });
  }
  _setDimension(t, e) {
    let i = 1;
    this.font.lineHeight && (i = this.font.lineHeight / this.font.size), e.canvas.width = (t.width + this.font.padding * 2) * 2 * this.font.quality, e.canvas.height = (t.height + this.font.padding * 2) * 2 * this.font.quality * i;
  }
  static getHashCode(t, e, i) {
    var s;
    return e + "__hashcode__" + t.fontString + t.showDebug + t.textAlign + t.baseAlign + t.direction + t.lineHeight + JSON.stringify(t.shadow) + (t.padding.toString() + t.smoothing.toString() + t.lineWidth.toString() + t.lineDash.toString() + ((s = t.strokeColor) == null ? void 0 : s.toString()) + (i ? i.toString() : t.color.toString()));
  }
  getHashCode(t = !0) {
    return Se.getHashCode(this.font, this.text, t ? this.color : void 0);
  }
  _applyRasterProperties(t) {
    var e, i, s;
    t.translate(this.font.padding, this.font.padding), t.imageSmoothingEnabled = this.font.smoothing, t.lineWidth = this.font.lineWidth, t.setLineDash((e = this.font.lineDash) != null ? e : t.getLineDash()), t.strokeStyle = (s = (i = this.font.strokeColor) == null ? void 0 : i.toString()) != null ? s : "", t.fillStyle = this.color.toString();
  }
  _applyFont(t) {
    t.resetTransform(), t.translate(this.font.padding + t.canvas.width / 2, this.font.padding + t.canvas.height / 2), t.scale(this.font.quality, this.font.quality), t.textAlign = this.font.textAlign, t.textBaseline = this.font.baseAlign, t.font = this.font.fontString, t.direction = this.font.direction, this.font.shadow && (this.font.shadow.color && (t.shadowColor = this.font.shadow.color.toString()), this.font.shadow.blur && (t.shadowBlur = this.font.shadow.blur), this.font.shadow.offset && (t.shadowOffsetX = this.font.shadow.offset.x, t.shadowOffsetY = this.font.shadow.offset.y));
  }
  _drawText(t, e, i) {
    this._applyRasterProperties(t), this._applyFont(t);
    for (let s = 0; s < e.length; s++) {
      const n = e[s];
      this.color && t.fillText(n, 0, s * i), this.font.strokeColor && t.strokeText(n, 0, s * i);
    }
    this.font.showDebug && (es(t, T.Green, -t.canvas.width / 2, 0, t.canvas.width / 2, 0, 2), es(t, T.Red, 0, -t.canvas.height / 2, 0, t.canvas.height / 2, 2));
  }
  _splitTextBitmap(t) {
    const e = [];
    let i = 0, s = 0;
    const n = Math.min(4096, t.canvas.width), o = Math.min(4096, t.canvas.height);
    for (; i < t.canvas.width; ) {
      for (; s < t.canvas.height; ) {
        const a = document.createElement("canvas");
        a.width = n, a.height = o;
        const h = a.getContext("2d");
        if (!h)
          throw new Error("Unable to split internal FontTextInstance bitmap, failed to create internal canvas");
        h.drawImage(t.canvas, i, s, n, o, 0, 0, n, o), e.push({ x: i, y: s, canvas: a }), s += o;
      }
      i += n, s = 0;
    }
    return e;
  }
  flagDirty() {
    this._dirty = !0;
  }
  render(t, e, i, s) {
    var n;
    if (this.disposed)
      throw Error("Accessing disposed text instance! " + this.text);
    this._ex = t;
    const o = this.getHashCode();
    if (this._lastHashCode !== o && (this._dirty = !0), this._dirty) {
      this.dimensions = this.measureText(this.text, s), this._setDimension(this.dimensions, this.ctx);
      const a = this._getLinesFromText(this.text, s), h = (n = this.font.lineHeight) != null ? n : this.dimensions.height / a.length;
      if (this._drawText(this.ctx, a, h), t instanceof Qt)
        for (const l of this._textFragments)
          t.textureLoader.delete(l.canvas);
      if (this._textFragments = this._splitTextBitmap(this.ctx), t instanceof Qt)
        for (const l of this._textFragments)
          t.textureLoader.load(l.canvas, { filtering: this.font.filtering }, !0);
      this._lastHashCode = o, this._dirty = !1;
    }
    for (const a of this._textFragments)
      t.drawImage(
        a.canvas,
        0,
        0,
        a.canvas.width,
        a.canvas.height,
        a.x / this.font.quality + e - this.ctx.canvas.width / this.font.quality / 2,
        a.y / this.font.quality + i - this.ctx.canvas.height / this.font.quality / 2,
        a.canvas.width / this.font.quality,
        a.canvas.height / this.font.quality
      );
  }
  dispose() {
    if (this.disposed = !0, this.dimensions = void 0, this.canvas = void 0, this.ctx = void 0, this._ex instanceof Qt)
      for (const t of this._textFragments)
        this._ex.textureLoader.delete(t.canvas);
    this._textFragments.length = 0;
  }
  _getLinesFromText(t, e) {
    var i;
    if (this._cachedText === t && this._cachedRenderWidth === e && ((i = this._cachedLines) != null && i.length))
      return this._cachedLines;
    const s = t.split(`
`);
    if (e == null)
      return s;
    for (let n = 0; n < s.length; n++) {
      let o = s[n], a = "";
      if (this.measureText(o).width > e) {
        for (; this.measureText(o).width > e; )
          a = o[o.length - 1] + a, o = o.slice(0, -1);
        s[n] = o, s[n + 1] = a;
      }
    }
    return this._cachedText = t, this._cachedLines = s, this._cachedRenderWidth = e, s;
  }
}
class Me extends nt {
  constructor(t = {}) {
    var e, i, s, n, o, a, h, l, c, d, u, _, p, g, x, m, f, b, C, S;
    super(t), this.filtering = wt.Blended, this.quality = 2, this.padding = 2, this.smoothing = !1, this.lineWidth = 1, this.lineDash = [], this.color = T.Black, this.family = "sans-serif", this.style = dr.Normal, this.bold = !1, this.unit = hr.Px, this.textAlign = lr.Left, this.baseAlign = cr.Top, this.direction = ur.LeftToRight, this.lineHeight = void 0, this.size = 10, this._textBounds = new F(), this.smoothing = (e = t == null ? void 0 : t.smoothing) != null ? e : this.smoothing, this.padding = (i = t == null ? void 0 : t.padding) != null ? i : this.padding, this.color = (s = t == null ? void 0 : t.color) != null ? s : this.color, this.strokeColor = (n = t == null ? void 0 : t.strokeColor) != null ? n : this.strokeColor, this.lineDash = (o = t == null ? void 0 : t.lineDash) != null ? o : this.lineDash, this.lineWidth = (a = t == null ? void 0 : t.lineWidth) != null ? a : this.lineWidth, this.filtering = (h = t == null ? void 0 : t.filtering) != null ? h : this.filtering, this.family = (l = t == null ? void 0 : t.family) != null ? l : this.family, this.style = (c = t == null ? void 0 : t.style) != null ? c : this.style, this.bold = (d = t == null ? void 0 : t.bold) != null ? d : this.bold, this.size = (u = t == null ? void 0 : t.size) != null ? u : this.size, this.unit = (_ = t == null ? void 0 : t.unit) != null ? _ : this.unit, this.textAlign = (p = t == null ? void 0 : t.textAlign) != null ? p : this.textAlign, this.baseAlign = (g = t == null ? void 0 : t.baseAlign) != null ? g : this.baseAlign, this.direction = (x = t == null ? void 0 : t.direction) != null ? x : this.direction, this.lineHeight = (m = t == null ? void 0 : t.lineHeight) != null ? m : this.lineHeight, this.quality = (f = t == null ? void 0 : t.quality) != null ? f : this.quality, t != null && t.shadow && (this.shadow = {}, this.shadow.blur = (b = t.shadow.blur) != null ? b : this.shadow.blur, this.shadow.offset = (C = t.shadow.offset) != null ? C : this.shadow.offset, this.shadow.color = (S = t.shadow.color) != null ? S : this.shadow.color), this._textMeasurement = new Se(this, "", T.Black);
  }
  clone() {
    return new Me({
      ...this.cloneGraphicOptions(),
      size: this.size,
      unit: this.unit,
      family: this.family,
      style: this.style,
      bold: this.bold,
      textAlign: this.textAlign,
      baseAlign: this.baseAlign,
      direction: this.direction,
      shadow: this.shadow ? {
        blur: this.shadow.blur,
        offset: this.shadow.offset,
        color: this.shadow.color
      } : void 0
    });
  }
  get fontString() {
    return `${this.style} ${this.bold ? "bold" : ""} ${this.size}${this.unit} ${this.family}`;
  }
  get localBounds() {
    return this._textBounds;
  }
  _drawImage(t, e, i) {
  }
  _rotate(t) {
    var e;
    const i = (e = this.origin) != null ? e : this._textBounds.center;
    t.translate(i.x, i.y), t.rotate(this.rotation), t.translate(-i.x, -i.y);
  }
  _flip(t) {
    this.flipHorizontal && (t.translate(this._textBounds.width / this.scale.x, 0), t.scale(-1, 1)), this.flipVertical && (t.translate(0, -this._textBounds.height / 2 / this.scale.y), t.scale(1, -1));
  }
  measureTextWithoutCache(t, e) {
    return this._textMeasurement.measureText(t, e);
  }
  /**
   * Returns a BoundingBox that is the total size of the text including multiple lines
   *
   * Does not include any padding or adjustment
   * @param text
   * @returns BoundingBox
   */
  measureText(t, e) {
    return ss.measureText(t, this, e);
  }
  _postDraw(t) {
    t.restore();
  }
  render(t, e, i, s, n, o) {
    const a = ss.getTextInstance(e, this, i);
    this._textBounds = a.dimensions, this._preDraw(t, s, n), a.render(t, s, n, o), this._postDraw(t);
  }
}
class Bi extends nt {
  constructor(t) {
    var e, i;
    super(t), this._text = "", this._textWidth = 0, this._textHeight = 0, this.font = (e = t.font) != null ? e : new Me(), this.color = (i = t.color) != null ? i : this.color, this.text = t.text, this.maxWidth = t.maxWidth;
  }
  clone() {
    var t, e;
    return new Bi({
      text: this.text.slice(),
      color: (e = (t = this.color) == null ? void 0 : t.clone()) != null ? e : T.Black,
      font: this.font.clone(),
      maxWidth: this.maxWidth
    });
  }
  get text() {
    return this._text;
  }
  set text(t) {
    this._text = t, this._calculateDimension();
  }
  get font() {
    return this._font;
  }
  set font(t) {
    this._font = t;
  }
  get width() {
    return this._textWidth === 0 && this._calculateDimension(), this._textWidth * this.scale.x;
  }
  get height() {
    return this._textHeight === 0 && this._calculateDimension(), this._textHeight * this.scale.y;
  }
  _calculateDimension() {
    const { width: t, height: e } = this.font.measureText(this._text, this.maxWidth);
    this._textWidth = t, this._textHeight = e;
  }
  get localBounds() {
    return this.font.measureText(this._text, this.maxWidth).scale(this.scale);
  }
  _rotate(t) {
  }
  _flip(t) {
  }
  _preDraw(t, e, i) {
    (this.isStale() || this.font.isStale()) && (this.font.flipHorizontal = this.flipHorizontal, this.font.flipVertical = this.flipVertical, this.font.rotation = this.rotation, this.font.origin = this.origin, this.font.opacity = this.opacity), this.font.tint = this.tint, super._preDraw(t, e, i);
  }
  _drawImage(t, e, i) {
    var s;
    let n = T.Black;
    this.font instanceof Me && (n = (s = this.color) != null ? s : this.font.color);
    const { width: o, height: a } = this.font.measureText(this._text, this.maxWidth);
    this._textWidth = o, this._textHeight = a, this.font.render(t, this._text, n, e, i, this.maxWidth), this.font.showDebug && (t.debug.drawRect(e - o, i - a, o * 2, a * 2), this.maxWidth != null && t.debug.drawRect(e, i, this.maxWidth, this.height, {
      color: T.Yellow
    }));
  }
}
function Ir(r) {
  return !!r.tick;
}
class tt extends kt {
  constructor(t) {
    super(), this._logger = R.getInstance(), this._current = "default", this._graphics = {}, this._options = {}, this.material = null, this.isVisible = !0, this.forceOnScreen = !1, this.opacity = 1, this._offset = new se(v.Zero, () => this.recalculateBounds()), this._anchor = new se(v.Half, () => this.recalculateBounds()), this.flipHorizontal = !1, this.flipVertical = !1, this.copyGraphics = !1, t = {
      visible: this.isVisible,
      graphics: {},
      ...t
    };
    const {
      current: e,
      anchor: i,
      color: s,
      opacity: n,
      visible: o,
      graphics: a,
      offset: h,
      copyGraphics: l,
      onPreDraw: c,
      onPostDraw: d,
      onPreTransformDraw: u,
      onPostTransformDraw: _
    } = t;
    for (const [p, g] of Object.entries(a))
      g instanceof nt ? this._graphics[p] = g : (this._graphics[p] = g.graphic, this._options[p] = g.options);
    this.offset = h != null ? h : this.offset, this.opacity = n != null ? n : this.opacity, this.anchor = i != null ? i : this.anchor, this.color = s != null ? s : this.color, this.copyGraphics = l != null ? l : this.copyGraphics, this.onPreDraw = c != null ? c : this.onPreDraw, this.onPostDraw = d != null ? d : this.onPostDraw, this.onPreDraw = u != null ? u : this.onPreTransformDraw, this.onPostTransformDraw = _ != null ? _ : this.onPostTransformDraw, this.isVisible = !!o, this._current = e != null ? e : this._current, e && this._graphics[e] && this.use(e);
  }
  /**
   * Sets or gets wether any drawing should be visible in this component
   * @deprecated use isVisible
   */
  get visible() {
    return this.isVisible;
  }
  /**
   * Sets or gets wether any drawing should be visible in this component
   * @deprecated use isVisible
   */
  set visible(t) {
    this.isVisible = t;
  }
  /**
   * Offset to apply to graphics by default
   */
  get offset() {
    return this._offset;
  }
  set offset(t) {
    this._offset = new se(t, () => this.recalculateBounds()), this.recalculateBounds();
  }
  /**
   * Anchor to apply to graphics by default
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(t) {
    this._anchor = new se(t, () => this.recalculateBounds()), this.recalculateBounds();
  }
  /**
   * Sets the color of the actor's current graphic
   */
  get color() {
    return this._color;
  }
  set color(t) {
    if (t) {
      this._color = t.clone();
      const e = this.current;
      (e instanceof ti || e instanceof Bi) && (e.color = this._color);
    }
  }
  getGraphic(t) {
    return this._graphics[t];
  }
  getOptions(t) {
    return this._options[t];
  }
  /**
   * Get registered graphics names
   */
  getNames() {
    return Object.keys(this._graphics);
  }
  /**
   * Returns the currently displayed graphic
   */
  get current() {
    return this._graphics[this._current];
  }
  /**
   * Returns the currently displayed graphic offsets
   */
  get currentOptions() {
    return this._options[this._current];
  }
  /**
   * Returns all graphics associated with this component
   */
  get graphics() {
    return this._graphics;
  }
  /**
   * Returns all graphics options associated with this component
   */
  get options() {
    return this._options;
  }
  add(t, e, i) {
    let s = "default", n = null, o;
    if (typeof t == "string" && e instanceof nt && (s = t, n = e, o = i), t instanceof nt && !(e instanceof nt) && (n = t, o = e), !n)
      throw new Error("Need to provide a graphic or valid graphic string");
    return this._graphics[s] = this.copyGraphics ? n.clone() : n, this._options[s] = this.copyGraphics ? { ...o } : o, s === "default" && this.use("default"), n;
  }
  /**
   * Removes a registered graphic, if the removed graphic is the current it will switch to the default
   * @param name
   */
  remove(t) {
    delete this._graphics[t], delete this._options[t], this._current === t && (this._current = "default", this.recalculateBounds());
  }
  /**
   * Use a graphic only, will set the default graphic. Returns the new {@apilink Graphic}
   *
   * Optionally override the stored options
   * @param nameOrGraphic
   * @param options
   */
  use(t, e) {
    var i;
    if (t instanceof nt) {
      let s = t;
      this.copyGraphics && (s = t.clone()), this._current = "default", this._graphics[this._current] = s, this._options[this._current] = e;
    } else
      this._current = t, this._options[this._current] = e, this._current in this._graphics || this._logger.warn(
        `Graphic ${this._current} is not registered with the graphics component owned by ${(i = this.owner) == null ? void 0 : i.name}. Nothing will be drawn.`
      );
    return this.recalculateBounds(), this.current;
  }
  /**
   * Hide currently shown graphic
   */
  hide() {
    this._current = "ex.none";
  }
  set localBounds(t) {
    this._localBounds = t;
  }
  recalculateBounds() {
    let t = new F();
    const e = this._graphics[this._current], i = this._options[this._current];
    if (!e) {
      this._localBounds = t;
      return;
    }
    let s = this.anchor, n = this.offset;
    i != null && i.anchor && (s = i.anchor), i != null && i.offset && (n = i.offset);
    const o = e.localBounds, a = -o.width * s.x + n.x, h = -o.height * s.y + n.y;
    e instanceof Ze && !e.useAnchor ? t = e == null ? void 0 : e.localBounds.combine(t) : t = e == null ? void 0 : e.localBounds.translate(w(a, h)).combine(t), this._localBounds = t;
  }
  /**
   * Get local bounds of graphics component
   */
  get localBounds() {
    return (!this._localBounds || this._localBounds.hasZeroDimensions()) && this.recalculateBounds(), this._localBounds;
  }
  /**
   * Get world bounds of graphics component
   */
  get bounds() {
    let t = this.localBounds;
    if (this.owner) {
      const e = this.owner.get(P);
      e && (t = t.transform(e.get().matrix));
    }
    return t;
  }
  /**
   * Update underlying graphics if necessary, called internally
   * @param elapsed
   * @internal
   */
  update(t, e = 0) {
    const i = this.current;
    i && Ir(i) && i.tick(t, e);
  }
  clone() {
    const t = new tt();
    return t._graphics = { ...this._graphics }, t._options = { ...this._options }, t.offset = this.offset.clone(), this.color && (t.color = this.color.clone()), t.opacity = this.opacity, t.anchor = this.anchor.clone(), t.copyGraphics = this.copyGraphics, t.onPreDraw = this.onPreDraw, t.onPostDraw = this.onPostDraw, t.isVisible = this.isVisible, t;
  }
}
class fe extends kt {
  constructor(t) {
    var e, i;
    super(), this.useColliderShape = !0, this.useGraphicsBounds = !0, this.useColliderShape = (e = t == null ? void 0 : t.useColliderShape) != null ? e : this.useColliderShape, this.useGraphicsBounds = (i = t == null ? void 0 : t.useGraphicsBounds) != null ? i : this.useGraphicsBounds, this.localBounds = t == null ? void 0 : t.localBounds;
  }
}
function Fe(r) {
  return !!r && r.length === 4;
}
const bt = class {
  /**
   * @deprecated
   */
  static CreateReversibleEasingFunction(t) {
    return (e, i, s, n) => s < i ? i - (t(e, s, i, n) - s) : t(e, i, s, n);
  }
  /**
   * @deprecated
   */
  static CreateVectorEasingFunction(t) {
    return (e, i, s, n) => new v(t(e, i.x, s.x, n), t(e, i.y, s.y, n));
  }
};
bt.Linear = bt.CreateReversibleEasingFunction(
  (r, t, e, i) => (e = e - t, e * r / i + t)
);
bt.EaseInQuad = bt.CreateReversibleEasingFunction(
  (r, t, e, i) => (e = e - t, r /= i, e * r * r + t)
);
bt.EaseOutQuad = bt.CreateReversibleEasingFunction(
  (r, t, e, i) => (e = e - t, r /= i, -e * r * (r - 2) + t)
);
bt.EaseInOutQuad = bt.CreateReversibleEasingFunction(
  (r, t, e, i) => (e = e - t, r /= i / 2, r < 1 ? e / 2 * r * r + t : (r--, -e / 2 * (r * (r - 2) - 1) + t))
);
bt.EaseInCubic = bt.CreateReversibleEasingFunction(
  (r, t, e, i) => (e = e - t, r /= i, e * r * r * r + t)
);
bt.EaseOutCubic = bt.CreateReversibleEasingFunction(
  (r, t, e, i) => (e = e - t, r /= i, r--, e * (r * r * r + 1) + t)
);
bt.EaseInOutCubic = bt.CreateReversibleEasingFunction(
  (r, t, e, i) => (e = e - t, r /= i / 2, r < 1 ? e / 2 * r * r * r + t : (r -= 2, e / 2 * (r * r * r + 2) + t))
);
let It = bt;
class Ca {
  constructor(t) {
    this._actions = [], this._currentAction = null, this._completedActions = [], this._entity = t;
  }
  /**
   * Add an action to the sequence
   * @param action
   */
  add(t) {
    this._actions.push(t);
  }
  /**
   * Remove an action by reference from the sequence
   * @param action
   */
  remove(t) {
    const e = this._actions.indexOf(t);
    this._actions.splice(e, 1);
  }
  /**
   * Removes all actions from this sequence
   */
  clearActions() {
    this._actions.length = 0, this._completedActions.length = 0, this._currentAction && this._currentAction.stop();
  }
  /**
   *
   * @returns The total list of actions in this sequence complete or not
   */
  getActions() {
    return this._actions.concat(this._completedActions);
  }
  getIncompleteActions() {
    return this._actions;
  }
  getCurrentAction() {
    return this._currentAction;
  }
  /**
   *
   * @returns `true` if there are more actions to process in the sequence
   */
  hasNext() {
    return this._actions.length > 0;
  }
  /**
   * @returns `true` if the current sequence of actions is done
   */
  isComplete() {
    return this._actions.length === 0;
  }
  /**
   * Resets the sequence of actions, this is used to restart a sequence from the beginning
   */
  reset() {
    this._actions = this.getActions();
    const t = this._actions.length;
    for (let e = 0; e < t; e++)
      this._actions[e].reset();
    this._completedActions = [];
  }
  /**
   * Update the queue which updates actions and handles completing actions
   * @param elapsed
   */
  update(t) {
    if (this._actions.length > 0 && (this._currentAction !== this._actions[0] && (this._currentAction = this._actions[0], this._entity.emit("actionstart", new Nn(this._currentAction, this._entity))), this._currentAction.update(t), this._currentAction.isComplete(this._entity))) {
      this._entity.emit("actioncomplete", new Wn(this._currentAction, this._entity));
      const e = this._actions.shift();
      e && this._completedActions.push(e);
    }
  }
}
let Ta = 0;
function W() {
  return Ta++;
}
class Sa {
  constructor(t, e, i) {
    this.id = W(), this._stopped = !1, this._repeatBuilder = e, this._repeatContext = new ki(t), this._actionQueue = this._repeatContext.getQueue(), this._repeat = i, this._originalRepeat = i, this._repeatBuilder(this._repeatContext), this._repeat--;
  }
  update(t) {
    this._actionQueue.isComplete() && (this._actionQueue.clearActions(), this._repeatBuilder(this._repeatContext), this._repeat--), this._actionQueue.update(t);
  }
  isComplete() {
    return this._stopped || this._repeat <= 0 && this._actionQueue.isComplete();
  }
  stop() {
    this._stopped = !0;
  }
  reset() {
    this._repeat = this._originalRepeat;
  }
}
class Aa {
  constructor(t, e) {
    this.id = W(), this._stopped = !1, this._repeatBuilder = e, this._repeatContext = new ki(t), this._actionQueue = this._repeatContext.getQueue(), this._repeatBuilder(this._repeatContext);
  }
  update(t) {
    this._stopped || (this._actionQueue.isComplete() && (this._actionQueue.clearActions(), this._repeatBuilder(this._repeatContext)), this._actionQueue.update(t));
  }
  isComplete() {
    return this._stopped;
  }
  stop() {
    this._stopped = !0, this._actionQueue.clearActions();
  }
  reset() {
  }
}
function Pa(r) {
  return r.offset instanceof v && typeof r.duration == "number";
}
class Ea {
  constructor(t, e) {
    this.entity = t, this.id = W(), this._started = !1, this._stopped = !1, this._legacyEasing = It.Linear, this._easing = ds, this._useLegacyEasing = !1;
    var i;
    if (this._offset = e.offset, this._easing = (i = e.easing) != null ? i : this._easing, Fe(e.easing) && (this._legacyEasing = e.easing, this._useLegacyEasing = !0), this._tx = t.get(P), this._motion = t.get(N), !this._tx)
      throw new Error(`Entity ${t.name} has no TransformComponent, can only MoveBy on Entities with TransformComponents.`);
    this._durationMs = e.duration, this._currentMs = this._durationMs;
  }
  update(t) {
    this._started || (this._start = this._tx.pos.clone(), this._end = this._start.add(this._offset), this._started = !0), this._currentMs -= t;
    const e = D(Jt(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1), i = this._tx.pos;
    let s = 0, n = 0;
    this._useLegacyEasing ? (s = this._legacyEasing(e, this._start.x, this._end.x, 1), n = this._legacyEasing(e, this._start.y, this._end.y, 1)) : (s = ot(this._start.x, this._end.x, this._easing(e)), n = ot(this._start.y, this._end.y, this._easing(e)));
    const o = t / 1e3, a = o === 0 ? 0 : (s - i.x) / o, h = o === 0 ? 0 : (n - i.y) / o;
    this._motion.vel.x = a, this._motion.vel.y = h, this.isComplete(this.entity) && (this._tx.pos = w(this._end.x, this._end.y), this._motion.vel = w(0, 0));
  }
  isComplete(t) {
    return this._stopped || this._currentMs < 0;
  }
  stop() {
    this._motion.vel = w(0, 0), this._stopped = !0, this._currentMs = 0;
  }
  reset() {
    this._currentMs = this._durationMs, this._started = !1, this._stopped = !1;
  }
}
class Ws {
  constructor(t, e, i, s) {
    if (this.id = W(), this._started = !1, this._stopped = !1, this._entity = t, this._tx = t.get(P), this._motion = t.get(N), this._speed = s, this._offset = new v(e, i), s <= 0)
      throw R.getInstance().error("Attempted to moveBy with speed less than or equal to zero : " + s), new Error("Speed must be greater than 0 pixels per second");
  }
  update(t) {
    this._started || (this._started = !0, this._start = new v(this._tx.pos.x, this._tx.pos.y), this._end = this._start.add(this._offset), this._distance = this._offset.magnitude, this._dir = this._end.sub(this._start).normalize()), this.isComplete(this._entity) ? (this._tx.pos = w(this._end.x, this._end.y), this._motion.vel = w(0, 0)) : this._motion.vel = this._dir.scale(this._speed);
  }
  isComplete(t) {
    const e = t.get(P);
    return this._stopped || e.pos.distance(this._start) >= this._distance;
  }
  stop() {
    this._motion.vel = w(0, 0), this._stopped = !0;
  }
  reset() {
    this._started = !1, this._stopped = !1;
  }
}
function Ia(r) {
  return r.pos instanceof v && typeof r.duration == "number";
}
class Ra {
  constructor(t, e) {
    this.entity = t, this.id = W(), this._started = !1, this._stopped = !1, this._easing = ds, this._legacyEasing = It.Linear, this._useLegacyEasing = !1;
    var i;
    if (this._end = e.pos, this._easing = (i = e.easing) != null ? i : this._easing, Fe(e.easing) && (this._legacyEasing = e.easing, this._useLegacyEasing = !0), this._tx = t.get(P), this._motion = t.get(N), !this._tx)
      throw new Error(`Entity ${t.name} has no TransformComponent, can only moveTo on Entities with TransformComponents.`);
    this._durationMs = e.duration, this._currentMs = this._durationMs;
  }
  update(t) {
    this._started || (this._start = this._tx.pos.clone(), this._started = !0), this._currentMs -= t;
    const e = D(Jt(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1), i = this._tx.pos;
    let s = 0, n = 0;
    this._useLegacyEasing ? (s = this._legacyEasing(e, this._start.x, this._end.x, 1), n = this._legacyEasing(e, this._start.y, this._end.y, 1)) : (s = ot(this._start.x, this._end.x, this._easing(e)), n = ot(this._start.y, this._end.y, this._easing(e)));
    const o = t / 1e3, a = o === 0 ? 0 : (s - i.x) / o, h = o === 0 ? 0 : (n - i.y) / o;
    this._motion.vel.x = a, this._motion.vel.y = h, this.isComplete(this.entity) && (this._tx.pos = w(this._end.x, this._end.y), this._motion.vel = w(0, 0));
  }
  isComplete(t) {
    return this._stopped || this._currentMs < 0;
  }
  stop() {
    this._motion.vel = w(0, 0), this._stopped = !0, this._currentMs = 0;
  }
  reset() {
    this._currentMs = this._durationMs, this._started = !1, this._stopped = !1;
  }
}
class Vs {
  constructor(t, e, i, s) {
    this.entity = t, this.id = W(), this._started = !1, this._stopped = !1, this._tx = t.get(P), this._motion = t.get(N), this._end = new v(e, i), this._speed = s;
  }
  update(t) {
    this._started || (this._started = !0, this._start = new v(this._tx.pos.x, this._tx.pos.y), this._distance = this._start.distance(this._end), this._dir = this._end.sub(this._start).normalize());
    const e = this._dir.scale(this._speed);
    this._motion.vel = w(e.x, e.y), this.isComplete(this.entity) && (this._tx.pos = w(this._end.x, this._end.y), this._motion.vel = w(0, 0));
  }
  isComplete(t) {
    const e = t.get(P);
    return this._stopped || new v(e.pos.x, e.pos.y).distance(this._start) >= this._distance;
  }
  stop() {
    this._motion.vel = w(0, 0), this._stopped = !0;
  }
  reset() {
    this._started = !1, this._stopped = !1;
  }
}
function Nl(r) {
  return typeof r.angle == "number" && typeof r.duration == "number";
}
class Ma {
  constructor(t, e) {
    this.entity = t, this.id = W(), this._started = !1, this._stopped = !1, this._endAngle = 0, this._startAngle = 0;
    var i;
    if (this._endAngle = e.angle, this._tx = t.get(P), this._motion = t.get(N), !this._tx)
      throw new Error(`Entity ${t.name} has no TransformComponent, can only RotateTo on Entities with TransformComponents.`);
    this._durationMs = e.duration, this._rotationType = (i = e.rotationType) != null ? i : J.ShortestPath, this._currentMs = this._durationMs;
  }
  update(t) {
    this._started || (this._startAngle = this._tx.rotation, this._started = !0), this._currentMs -= t;
    const e = D(Jt(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1), i = cn(this._startAngle, this._endAngle, this._rotationType, e), s = this._tx.rotation, n = t / 1e3, o = n === 0 ? 0 : (i - s) / n;
    this._motion.angularVelocity = o, this.isComplete(this.entity) && (this._tx.rotation = this._endAngle, this._motion.angularVelocity = 0);
  }
  isComplete(t) {
    return this._stopped || this._currentMs < 0;
  }
  stop() {
    this._motion.angularVelocity = 0, this._stopped = !0, this._currentMs = 0;
  }
  reset() {
    this._currentMs = this._durationMs, this._started = !1, this._stopped = !1;
  }
}
class Fa {
  constructor(t, e, i, s) {
    this.id = W(), this._started = !1, this._stopped = !1, this._tx = t.get(P), this._motion = t.get(N), this._end = e, this._speed = i, this._rotationType = s || J.ShortestPath;
  }
  update(t) {
    if (!this._started) {
      this._started = !0, this._start = this._tx.rotation, this._currentNonCannonAngle = this._tx.rotation;
      const e = Math.abs(this._end - this._start), i = vt - e;
      switch (e > i ? (this._shortDistance = i, this._longDistance = e) : (this._shortDistance = e, this._longDistance = i), this._shortestPathIsPositive = (this._start - this._end + vt) % vt >= Math.PI, this._rotationType) {
        case J.ShortestPath:
          this._distance = this._shortDistance, this._shortestPathIsPositive ? this._direction = 1 : this._direction = -1;
          break;
        case J.LongestPath:
          this._distance = this._longDistance, this._shortestPathIsPositive ? this._direction = -1 : this._direction = 1;
          break;
        case J.Clockwise:
          this._direction = 1, this._shortestPathIsPositive ? this._distance = this._shortDistance : this._distance = this._longDistance;
          break;
        case J.CounterClockwise:
          this._direction = -1, this._shortestPathIsPositive ? this._distance = this._longDistance : this._distance = this._shortDistance;
          break;
      }
    }
    this._motion.angularVelocity = this._direction * this._speed, this._currentNonCannonAngle += this._direction * this._speed * (t / 1e3), this.isComplete() && (this._tx.rotation = this._end, this._motion.angularVelocity = 0, this._stopped = !0);
  }
  isComplete() {
    const t = Math.abs(this._currentNonCannonAngle - this._start);
    return this._stopped || t >= Math.abs(this._distance);
  }
  stop() {
    this._motion.angularVelocity = 0, this._stopped = !0;
  }
  reset() {
    this._started = !1, this._stopped = !1;
  }
}
function Wl(r) {
  return typeof r.angleRadiansOffset == "number" && typeof r.duration == "number";
}
class Da {
  constructor(t, e) {
    this.entity = t, this.id = W(), this._started = !1, this._stopped = !1, this._offset = 0, this._startAngle = 0, this._endAngle = 0;
    var i;
    if (this._offset = e.angleRadiansOffset, this._tx = t.get(P), this._motion = t.get(N), !this._tx)
      throw new Error(`Entity ${t.name} has no TransformComponent, can only RotateBy on Entities with TransformComponents.`);
    this._durationMs = e.duration, this._rotationType = (i = e.rotationType) != null ? i : J.ShortestPath, this._currentMs = this._durationMs;
  }
  update(t) {
    this._started || (this._startAngle = this._tx.rotation, this._endAngle = Ht(this._startAngle + this._offset), this._started = !0), this._currentMs -= t;
    const e = D(Jt(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1), i = cn(this._startAngle, this._endAngle, this._rotationType, e), s = this._tx.rotation, n = t / 1e3, o = n === 0 ? 0 : (i - s) / n;
    this._motion.angularVelocity = o, this.isComplete() && (this._tx.rotation = this._endAngle, this._motion.angularVelocity = 0);
  }
  isComplete() {
    return this._stopped || this._currentMs < 0;
  }
  stop() {
    this._motion.angularVelocity = 0, this._stopped = !0, this._currentMs = 0;
  }
  reset() {
    this._currentMs = this._durationMs, this._started = !1, this._stopped = !1;
  }
}
class Ba {
  constructor(t, e, i, s) {
    this.id = W(), this._started = !1, this._stopped = !1, this._tx = t.get(P), this._motion = t.get(N), this._speed = i, this._offset = e, this._rotationType = s || J.ShortestPath;
  }
  update(t) {
    if (!this._started) {
      this._started = !0, this._start = this._tx.rotation, this._currentNonCannonAngle = this._tx.rotation, this._end = this._start + this._offset;
      const e = Math.abs(this._end - this._start), i = vt - e;
      switch (e > i ? (this._shortDistance = i, this._longDistance = e) : (this._shortDistance = e, this._longDistance = i), this._shortestPathIsPositive = (this._start - this._end + vt) % vt >= Math.PI, this._rotationType) {
        case J.ShortestPath:
          this._distance = this._shortDistance, this._shortestPathIsPositive ? this._direction = 1 : this._direction = -1;
          break;
        case J.LongestPath:
          this._distance = this._longDistance, this._shortestPathIsPositive ? this._direction = -1 : this._direction = 1;
          break;
        case J.Clockwise:
          this._direction = 1, this._shortDistance >= 0 ? this._distance = this._shortDistance : this._distance = this._longDistance;
          break;
        case J.CounterClockwise:
          this._direction = -1, this._shortDistance <= 0 ? this._distance = this._shortDistance : this._distance = this._longDistance;
          break;
      }
    }
    this._motion.angularVelocity = this._direction * this._speed, this._currentNonCannonAngle += this._direction * this._speed * (t / 1e3), this.isComplete() && (this._tx.rotation = this._end, this._motion.angularVelocity = 0, this._stopped = !0);
  }
  isComplete() {
    const t = Math.abs(this._currentNonCannonAngle - this._start);
    return this._stopped || t >= Math.abs(this._distance);
  }
  stop() {
    this._motion.angularVelocity = 0, this._stopped = !0;
  }
  reset() {
    this._started = !1, this._stopped = !1, this._start = void 0, this._currentNonCannonAngle = void 0, this._distance = void 0;
  }
}
function ka(r) {
  return typeof r.scale == "object" && typeof r.duration == "number";
}
class La {
  constructor(t, e) {
    if (this.entity = t, this.id = W(), this._started = !1, this._stopped = !1, this._endScale = w(1, 1), this._startScale = w(1, 1), this._endScale = e.scale, this._tx = t.get(P), this._motion = t.get(N), !this._tx)
      throw new Error(`Entity ${t.name} has no TransformComponent, can only ScaleTo on Entities with TransformComponents.`);
    this._durationMs = e.duration, this._currentMs = this._durationMs;
  }
  update(t) {
    this._started || (this._startScale = this._tx.scale, this._started = !0), this._currentMs -= t;
    const e = D(Jt(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1), i = Ai(this._startScale, this._endScale, e), s = this._tx.scale, n = t / 1e3, o = i.sub(s).scale(n === 0 ? 0 : 1 / n);
    this._motion.scaleFactor = o, this.isComplete() && (this._tx.scale = this._endScale, this._motion.angularVelocity = 0);
  }
  isComplete() {
    return this._stopped || this._currentMs < 0;
  }
  stop() {
    this._motion.scaleFactor = v.Zero, this._stopped = !0, this._currentMs = 0;
  }
  reset() {
    this._currentMs = this._durationMs, this._started = !1, this._stopped = !1;
  }
}
class Ua {
  constructor(t, e, i, s, n) {
    this.id = W(), this._started = !1, this._stopped = !1, this._tx = t.get(P), this._motion = t.get(N), this._endX = e, this._endY = i, this._speedX = s, this._speedY = n;
  }
  update(t) {
    if (this._started || (this._started = !0, this._startX = this._tx.scale.x, this._startY = this._tx.scale.y, this._distanceX = Math.abs(this._endX - this._startX), this._distanceY = Math.abs(this._endY - this._startY)), Math.abs(this._tx.scale.x - this._startX) >= this._distanceX)
      this._motion.scaleFactor.x = 0;
    else {
      const e = this._endY < this._startY ? -1 : 1;
      this._motion.scaleFactor.x = this._speedX * e;
    }
    if (Math.abs(this._tx.scale.y - this._startY) >= this._distanceY)
      this._motion.scaleFactor.y = 0;
    else {
      const e = this._endY < this._startY ? -1 : 1;
      this._motion.scaleFactor.y = this._speedY * e;
    }
    this.isComplete() && (this._tx.scale = w(this._endX, this._endY), this._motion.scaleFactor.x = 0, this._motion.scaleFactor.y = 0);
  }
  isComplete() {
    return this._stopped || Math.abs(this._tx.scale.x - this._startX) >= this._distanceX - 0.01 && Math.abs(this._tx.scale.y - this._startY) >= this._distanceY - 0.01;
  }
  stop() {
    this._motion.scaleFactor.x = 0, this._motion.scaleFactor.y = 0, this._stopped = !0;
  }
  reset() {
    this._started = !1, this._stopped = !1;
  }
}
function za(r) {
  return typeof r.scaleOffset == "object" && typeof r.duration == "number";
}
class Ha {
  constructor(t, e) {
    if (this.entity = t, this.id = W(), this._started = !1, this._stopped = !1, this._endScale = w(1, 1), this._scaleOffset = w(0, 0), this._startScale = w(1, 1), this._scaleOffset = e.scaleOffset, this._tx = t.get(P), this._motion = t.get(N), !this._tx)
      throw new Error(`Entity ${t.name} has no TransformComponent, can only ScaleBy on Entities with TransformComponents.`);
    this._durationMs = e.duration, this._currentMs = this._durationMs;
  }
  update(t) {
    this._started || (this._startScale = this._tx.scale, this._endScale = this._startScale.add(this._scaleOffset), this._started = !0), this._currentMs -= t;
    const e = D(Jt(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1), i = Ai(this._startScale, this._endScale, e), s = this._tx.scale, n = t / 1e3, o = i.sub(s).scale(n === 0 ? 0 : 1 / n);
    this._motion.scaleFactor = o, this.isComplete() && (this._tx.scale = this._endScale, this._motion.angularVelocity = 0);
  }
  isComplete() {
    return this._stopped || this._currentMs < 0;
  }
  stop() {
    this._motion.scaleFactor = v.Zero, this._stopped = !0, this._currentMs = 0;
  }
  reset() {
    this._currentMs = this._durationMs, this._started = !1, this._stopped = !1;
  }
}
class Oa {
  constructor(t, e, i, s) {
    this.id = W(), this._started = !1, this._stopped = !1, this._tx = t.get(P), this._motion = t.get(N), this._offset = new v(e, i), this._speedX = this._speedY = s;
  }
  update(t) {
    this._started || (this._started = !0, this._startScale = this._tx.scale.clone(), this._endScale = this._startScale.add(this._offset), this._distanceX = Math.abs(this._endScale.x - this._startScale.x), this._distanceY = Math.abs(this._endScale.y - this._startScale.y), this._directionX = this._endScale.x < this._startScale.x ? -1 : 1, this._directionY = this._endScale.y < this._startScale.y ? -1 : 1), this._motion.scaleFactor.x = this._speedX * this._directionX, this._motion.scaleFactor.y = this._speedY * this._directionY, this.isComplete() && (this._tx.scale = this._endScale, this._motion.scaleFactor.x = 0, this._motion.scaleFactor.y = 0);
  }
  isComplete() {
    return this._stopped || Math.abs(this._tx.scale.x - this._startScale.x) >= this._distanceX - 0.01 && Math.abs(this._tx.scale.y - this._startScale.y) >= this._distanceY - 0.01;
  }
  stop() {
    this._motion.scaleFactor.x = 0, this._motion.scaleFactor.y = 0, this._stopped = !0;
  }
  reset() {
    this._started = !1, this._stopped = !1;
  }
}
class Gs {
  constructor(t) {
    this.id = W(), this._hasBeenCalled = !1, this._method = t;
  }
  update(t) {
    this._method(), this._hasBeenCalled = !0;
  }
  isComplete() {
    return this._hasBeenCalled;
  }
  reset() {
    this._hasBeenCalled = !1;
  }
  stop() {
    this._hasBeenCalled = !0;
  }
}
class Na {
  constructor(t, e, i, s, n) {
    this.easingFcn = n, this.id = W(), this._currentLerpTime = 0, this._lerpDuration = 1 * 1e3, this._lerpStart = new v(0, 0), this._lerpEnd = new v(0, 0), this._initialized = !1, this._stopped = !1, this._tx = t.get(P), this._motion = t.get(N), this._lerpDuration = s, this._lerpEnd = new v(e, i);
  }
  _initialize() {
    this._lerpStart = new v(this._tx.pos.x, this._tx.pos.y), this._currentLerpTime = 0;
  }
  update(t) {
    this._initialized || (this._initialize(), this._initialized = !0), this._currentLerpTime += t;
    let e = this._tx.pos.x, i = this._tx.pos.y;
    if (this._currentLerpTime < this._lerpDuration) {
      this._lerpEnd.x < this._lerpStart.x ? e = this._lerpStart.x - (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x) : e = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration), this._lerpEnd.y < this._lerpStart.y ? i = this._lerpStart.y - (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y) : i = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
      const s = t / 1e3;
      this._motion.vel = w(s === 0 ? 0 : (e - this._tx.pos.x) / s, s === 0 ? 0 : (i - this._tx.pos.y) / s);
    } else
      this._tx.pos = w(this._lerpEnd.x, this._lerpEnd.y), this._motion.vel = v.Zero;
  }
  isComplete() {
    return this._stopped || this._currentLerpTime >= this._lerpDuration;
  }
  reset() {
    this._initialized = !1, this._stopped = !1, this._currentLerpTime = 0;
  }
  stop() {
    this._motion.vel = w(0, 0), this._stopped = !0;
  }
}
class Wa {
  constructor(t, e, i, s, n) {
    this.easingFcn = n, this.id = W(), this._currentLerpTime = 0, this._lerpDuration = 1 * 1e3, this._lerpStart = new v(0, 0), this._lerpEnd = new v(0, 0), this._initialized = !1, this._stopped = !1, this._tx = t.get(P), this._motion = t.get(N), this._lerpDuration = s, this._offset = new v(e, i);
  }
  _initialize() {
    this._lerpStart = new v(this._tx.pos.x, this._tx.pos.y), this._currentLerpTime = 0, this._lerpEnd = this._lerpStart.add(this._offset);
  }
  update(t) {
    this._initialized || (this._initialize(), this._initialized = !0), this._currentLerpTime += t;
    let e = this._tx.pos.x, i = this._tx.pos.y;
    if (this._currentLerpTime < this._lerpDuration) {
      this._lerpEnd.x < this._lerpStart.x ? e = this._lerpStart.x - (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x) : e = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration), this._lerpEnd.y < this._lerpStart.y ? i = this._lerpStart.y - (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y) : i = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
      const s = t / 1e3;
      this._motion.vel = w(s === 0 ? 0 : (e - this._tx.pos.x) / s, s === 0 ? 0 : (i - this._tx.pos.y) / s);
    } else
      this._tx.pos = w(this._lerpEnd.x, this._lerpEnd.y), this._motion.vel = v.Zero;
  }
  isComplete() {
    return this._stopped || this._currentLerpTime >= this._lerpDuration;
  }
  reset() {
    this._initialized = !1, this._stopped = !1, this._currentLerpTime = 0;
  }
  stop() {
    this._motion.vel = w(0, 0), this._stopped = !0;
  }
}
class Va {
  constructor(t, e, i, s = 1) {
    this.id = W(), this._timeVisible = 0, this._timeNotVisible = 0, this._elapsedTime = 0, this._totalTime = 0, this._stopped = !1, this._started = !1, this._graphics = t.get(tt), this._timeVisible = e, this._timeNotVisible = i, this._duration = (e + i) * s;
  }
  update(t) {
    this._started || (this._started = !0, this._elapsedTime = 0, this._totalTime = 0), this._graphics && (this._elapsedTime += t, this._totalTime += t, this._graphics.isVisible && this._elapsedTime >= this._timeVisible && (this._graphics.isVisible = !1, this._elapsedTime = 0), !this._graphics.isVisible && this._elapsedTime >= this._timeNotVisible && (this._graphics.isVisible = !0, this._elapsedTime = 0), this.isComplete() && (this._graphics.isVisible = !0));
  }
  isComplete() {
    return this._stopped || this._totalTime >= this._duration;
  }
  stop() {
    this._graphics && (this._graphics.isVisible = !0), this._stopped = !0;
  }
  reset() {
    this._started = !1, this._stopped = !1, this._elapsedTime = 0, this._totalTime = 0;
  }
}
class Ga {
  constructor(t, e, i) {
    this.id = W(), this._multiplier = 1, this._started = !1, this._stopped = !1, this._graphics = t.get(tt), this._endOpacity = e, this._remainingTime = this._originalTime = i;
  }
  update(t) {
    this._graphics && (this._started || (this._started = !0, this._remainingTime = this._originalTime, this._endOpacity < this._graphics.opacity ? this._multiplier = -1 : this._multiplier = 1), this._remainingTime > 0 && (this._graphics.opacity += this._multiplier * (Math.abs(this._graphics.opacity - this._endOpacity) * t) / this._remainingTime), this._remainingTime -= t, this.isComplete() && (this._graphics.opacity = this._endOpacity), R.getInstance().debug("[Action fade] Actor opacity:", this._graphics.opacity));
  }
  isComplete() {
    return this._stopped || this._remainingTime <= 0;
  }
  stop() {
    this._stopped = !0;
  }
  reset() {
    this._started = !1, this._stopped = !1, this._remainingTime = this._originalTime;
  }
}
class qa {
  constructor(t) {
    this.id = W(), this._elapsedTime = 0, this._started = !1, this._stopped = !1, this._delay = t;
  }
  update(t) {
    this._started || (this._started = !0), this._elapsedTime += t;
  }
  isComplete() {
    return this._stopped || this._elapsedTime >= this._delay;
  }
  stop() {
    this._stopped = !0;
  }
  reset() {
    this._elapsedTime = 0, this._started = !1, this._stopped = !1;
  }
}
class Xa {
  constructor(t) {
    this.id = W(), this._stopped = !1, this._entity = t;
  }
  update(t) {
    this._entity.get(Xe).clearActions(), this._entity.kill(), this._stopped = !0;
  }
  isComplete() {
    return this._stopped;
  }
  stop() {
  }
  reset() {
  }
}
class qs {
  constructor(t, e, i) {
    this.id = W(), this._started = !1, this._stopped = !1, this._tx = t.get(P), this._motion = t.get(N), this._followTx = e.get(P), this._followMotion = e.get(N), this._current = new v(this._tx.pos.x, this._tx.pos.y), this._end = new v(this._followTx.pos.x, this._followTx.pos.y), this._maximumDistance = i !== void 0 ? i : this._current.distance(this._end), this._speed = 0;
  }
  update(t) {
    this._started || (this._started = !0, this._distanceBetween = this._current.distance(this._end), this._dir = this._end.sub(this._current).normalize());
    const e = Math.sqrt(Math.pow(this._followMotion.vel.x, 2) + Math.pow(this._followMotion.vel.y, 2));
    if (e !== 0 && (this._speed = e), this._current = w(this._tx.pos.x, this._tx.pos.y), this._end = w(this._followTx.pos.x, this._followTx.pos.y), this._distanceBetween = this._current.distance(this._end), this._dir = this._end.sub(this._current).normalize(), this._distanceBetween >= this._maximumDistance) {
      const i = this._dir.scale(this._speed);
      this._motion.vel = w(i.x, i.y);
    } else
      this._motion.vel = w(0, 0);
    this.isComplete() && (this._tx.pos = w(this._end.x, this._end.y), this._motion.vel = w(0, 0));
  }
  stop() {
    this._motion.vel = w(0, 0), this._stopped = !0;
  }
  isComplete() {
    return this._stopped;
  }
  reset() {
    this._started = !1, this._stopped = !1;
  }
}
class Ni {
  constructor(t, e, i, s) {
    this.id = W(), this._started = !1, this._stopped = !1, this._speedWasSpecified = !1, this._tolerance = 1, this._tx = t.get(P), this._motion = t.get(N), this._meetTx = e.get(P), this._meetMotion = e.get(N), this._current = new v(this._tx.pos.x, this._tx.pos.y), this._end = new v(this._meetTx.pos.x, this._meetTx.pos.y), this._speed = i || 0, i !== void 0 && (this._speedWasSpecified = !0), s !== void 0 && (this._tolerance = s);
  }
  update(t) {
    this._started || (this._started = !0, this._distanceBetween = this._current.distance(this._end), this._dir = this._end.sub(this._current).normalize());
    const e = Math.sqrt(Math.pow(this._meetMotion.vel.x, 2) + Math.pow(this._meetMotion.vel.y, 2));
    e !== 0 && !this._speedWasSpecified && (this._speed = e), this._current = w(this._tx.pos.x, this._tx.pos.y), this._end = w(this._meetTx.pos.x, this._meetTx.pos.y), this._distanceBetween = this._current.distance(this._end), this._dir = this._end.sub(this._current).normalize();
    const i = this._dir.scale(this._speed);
    this._motion.vel = w(i.x, i.y), this.isComplete() && (this._tx.pos = w(this._end.x, this._end.y), this._motion.vel = w(0, 0));
  }
  isComplete() {
    return this._stopped || this._distanceBetween <= this._tolerance;
  }
  stop() {
    this._motion.vel = w(0, 0), this._stopped = !0;
  }
  reset() {
    this._started = !1, this._stopped = !1, this._distanceBetween = 1 / 0;
  }
}
class $a {
  constructor(t, e, i = 1e3) {
    this.id = W(), this._stopped = !1, this._started = !1, this._total = 0, this._currentDuration = 0;
    var s;
    this._graphics = t.get(tt), this._duration = i, this._entity = t, this._material = (s = t.scene) == null ? void 0 : s.engine.graphicsContext.createMaterial({
      name: "flash-material",
      color: e,
      fragmentSource: `#version 300 es
    
        precision mediump float;
        uniform float u_blend;
        uniform sampler2D u_graphic;
        uniform vec4 u_color;
    
        in vec2 v_uv; 
        out vec4 color;
    
        void main() { 
            vec4 textureColor = texture(u_graphic, v_uv); 
            color = mix(textureColor, u_color, u_blend * textureColor.a);
            color.rgb = color.rgb * color.a;
        }`
    }), this._total = i;
  }
  update(t) {
    var e;
    this._started || (this._started = !0, this._total = this._duration, this._currentDuration = this._duration, this._entity.graphics.material = this._material), this._graphics && (this._currentDuration -= t, this._graphics && ((e = this._material) == null || e.update((i) => {
      i.trySetUniformFloat("u_blend", this._currentDuration / this._total);
    })), this.isComplete() && (this._entity.graphics.material = null));
  }
  isComplete() {
    return this._stopped || this._currentDuration <= 0;
  }
  stop() {
    this._graphics && (this._graphics.isVisible = !0), this._stopped = !0;
  }
  reset() {
    this._started = !1, this._stopped = !1;
  }
}
class Ya {
  constructor(t, e) {
    this.id = W(), this._started = !1, this._stopped = !1, this._mode = "dynamic";
    var i;
    if (this._entity = t, this._tx = this._entity.get(P), !this._tx)
      throw new Error(`Entity ${t.name} has no TransformComponent, can only curveTo on Entities with TransformComponents.`);
    this._curve = new Pi({
      controlPoints: [w(0, 0), ...e.controlPoints],
      quality: e.quality
    }), this._durationMs = e.duration, this._mode = (i = e.mode) != null ? i : this._mode, this._currentMs = this._durationMs;
  }
  update(t) {
    this._started || (this._curve.setControlPoint(0, this._tx.globalPos.clone()), this._started = !0), this._currentMs -= t;
    const e = D(Jt(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1);
    this._mode === "dynamic" ? this._tx.pos = this._curve.getPoint(e) : this._tx.pos = this._curve.getUniformPoint(e), this.isComplete(this._entity) && (this._mode === "dynamic" ? this._tx.pos = this._curve.getPoint(1) : this._tx.pos = this._curve.getUniformPoint(1));
  }
  isComplete(t) {
    return this._stopped || this._currentMs < 0;
  }
  reset() {
    this._currentMs = this._durationMs, this._started = !1, this._stopped = !1;
  }
  stop() {
    this._stopped = !0, this._currentMs = 0;
  }
}
class Za {
  constructor(t, e) {
    this.id = W(), this._started = !1, this._stopped = !1, this._mode = "dynamic";
    var i;
    if (this._entity = t, this._tx = this._entity.get(P), !this._tx)
      throw new Error(`Entity ${t.name} has no TransformComponent, can only curveTo on Entities with TransformComponents.`);
    this._curve = this._curve = new Pi({
      controlPoints: [w(0, 0), ...e.controlPoints],
      quality: e.quality
    }), this._durationMs = e.duration, this._mode = (i = e.mode) != null ? i : this._mode, this._currentMs = this._durationMs;
  }
  update(t) {
    this._started || (this._curve.setControlPoint(0, this._tx.globalPos), this._curve.setControlPoint(1, this._curve.controlPoints[1].add(this._tx.globalPos)), this._curve.setControlPoint(2, this._curve.controlPoints[2].add(this._tx.globalPos)), this._curve.setControlPoint(3, this._curve.controlPoints[3].add(this._tx.globalPos)), this._started = !0), this._currentMs -= t;
    const e = D(Jt(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1);
    this._mode === "dynamic" ? this._tx.pos = this._curve.getPoint(e) : this._tx.pos = this._curve.getUniformPoint(e), this.isComplete(this._entity) && (this._mode === "dynamic" ? this._tx.pos = this._curve.getPoint(1) : this._tx.pos = this._curve.getUniformPoint(1));
  }
  isComplete(t) {
    return this._stopped || this._currentMs < 0;
  }
  reset() {
    this._currentMs = this._durationMs, this._started = !1, this._stopped = !1;
  }
  stop() {
    this._stopped = !0;
  }
}
class ki {
  constructor(t) {
    this._entity = t, this._queue = new Ca(t);
  }
  getQueue() {
    return this._queue;
  }
  update(t) {
    this._queue.update(t);
  }
  /**
   * Clears all queued actions from the Actor
   */
  clearActions() {
    this._queue.clearActions();
  }
  runAction(t) {
    return t.reset(), this._queue.add(t), this;
  }
  /**
   * Animates an actor with a specified bezier curve by an offset to the current position, the start point is assumed
   * to be the actors current position
   * @param options
   */
  curveBy(t) {
    return this._queue.add(new Za(this._entity, t)), this;
  }
  /**
   * Animates an actor with a specified bezier curve to an absolute world space coordinate, the start point is assumed
   * to be the actors current position
   * @param options
   */
  curveTo(t) {
    return this._queue.add(new Ya(this._entity, t)), this;
  }
  easeTo(...t) {
    var e, i;
    let s = 0, n = 0, o = 0, a = It.Linear;
    return t[0] instanceof v ? (s = t[0].x, n = t[0].y, o = t[1], a = (e = t[2]) != null ? e : a) : (s = t[0], n = t[1], o = t[2], a = (i = t[3]) != null ? i : a), this._queue.add(new Na(this._entity, s, n, o, a)), this;
  }
  easeBy(...t) {
    var e, i;
    let s = 0, n = 0, o = 0, a = It.Linear;
    return t[0] instanceof v ? (s = t[0].x, n = t[0].y, o = t[1], a = (e = t[2]) != null ? e : a) : (s = t[0], n = t[1], o = t[2], a = (i = t[3]) != null ? i : a), this._queue.add(new Wa(this._entity, s, n, o, a)), this;
  }
  moveTo(t, e, i) {
    let s = 0, n = 0, o = 0;
    return t instanceof v ? (s = t.x, n = t.y, o = +(e != null ? e : 0), this._queue.add(new Vs(this._entity, s, n, o))) : typeof t == "number" && typeof e == "number" && typeof i == "number" ? (s = t, n = e, o = i, this._queue.add(new Vs(this._entity, s, n, o))) : Ia(t) && this._queue.add(new Ra(this._entity, t)), this;
  }
  moveBy(t, e, i) {
    let s = 0, n = 0, o = 0;
    return t instanceof v && typeof e == "number" ? (s = t.x, n = t.y, o = e, this._queue.add(new Ws(this._entity, s, n, o))) : typeof t == "number" && typeof e == "number" && typeof i == "number" ? (s = t, n = e, o = i, this._queue.add(new Ws(this._entity, s, n, o))) : Pa(t) && this._queue.add(new Ea(this._entity, t)), this;
  }
  rotateTo(t, e, i) {
    return typeof t == "number" && typeof e == "number" ? this._queue.add(new Fa(this._entity, t, e, i)) : typeof t == "object" && this._queue.add(new Ma(this._entity, t)), this;
  }
  rotateBy(t, e, i) {
    return typeof t == "object" ? this._queue.add(new Da(this._entity, t)) : this._queue.add(new Ba(this._entity, t, e, i)), this;
  }
  scaleTo(t, e, i, s) {
    let n = 1, o = 1, a = 0, h = 0;
    return ka(t) ? (this._queue.add(new La(this._entity, t)), this) : (t instanceof v && e instanceof v && (n = t.x, o = t.y, a = e.x, h = e.y), typeof t == "number" && typeof e == "number" && (n = t, o = e, a = i, h = s), this._queue.add(new Ua(this._entity, n, o, a, h)), this);
  }
  scaleBy(t, e, i) {
    if (za(t))
      return this._queue.add(new Ha(this._entity, t)), this;
    let s = 1, n = 1;
    return t instanceof v && (s = t.x, n = t.y, i = e), typeof t == "number" && typeof e == "number" && (s = t, n = e), this._queue.add(new Oa(this._entity, s, n, i)), this;
  }
  /**
   * This method will cause an actor to blink (become visible and not
   * visible). Optionally, you may specify the number of blinks. Specify the amount of time
   * the actor should be visible per blink, and the amount of time not visible.
   * This method is part of the actor 'Action' fluent API allowing action chaining.
   * @param timeVisible     The amount of time to stay visible per blink in milliseconds
   * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
   * @param numBlinks       The number of times to blink
   */
  blink(t, e, i = 1) {
    return this._queue.add(new Va(this._entity, t, e, i)), this;
  }
  /**
   * This method will cause an actor's opacity to change from its current value
   * to the provided value by a specified time (in milliseconds). This method is
   * part of the actor 'Action' fluent API allowing action chaining.
   * @param opacity  The ending opacity
   * @param duration     The time it should take to fade the actor (in milliseconds)
   */
  fade(t, e) {
    return this._queue.add(new Ga(this._entity, t, e)), this;
  }
  /**
   * This will cause an actor to flash a specific color for a period of time
   * @param color
   * @param duration The duration in milliseconds
   */
  flash(t, e = 1e3) {
    return this._queue.add(new $a(this._entity, t, e)), this;
  }
  /**
   * This method will delay the next action from executing for a certain
   * amount of time (in milliseconds). This method is part of the actor
   * 'Action' fluent API allowing action chaining.
   * @param duration  The amount of time to delay the next action in the queue from executing in milliseconds
   */
  delay(t) {
    return this._queue.add(new qa(t)), this;
  }
  /**
   * This method will add an action to the queue that will remove the actor from the
   * scene once it has completed its previous  Any actions on the
   * action queue after this action will not be executed.
   */
  die() {
    return this._queue.add(new Xa(this._entity)), this;
  }
  /**
   * This method allows you to call an arbitrary method as the next action in the
   * action queue. This is useful if you want to execute code in after a specific
   * action, i.e An actor arrives at a destination after traversing a path
   */
  callMethod(t) {
    return this._queue.add(new Gs(t)), this;
  }
  /**
   * This method will cause the actor to repeat all of the actions built in
   * the `repeatBuilder` callback. If the number of repeats
   * is not specified it will repeat forever. This method is part of
   * the actor 'Action' fluent API allowing action chaining
   *
   * ```typescript
   * // Move up in a zig-zag by repeated moveBy's
   * actor.actions.repeat(repeatCtx => {
   * repeatCtx.moveBy(10, 0, 10);
   * repeatCtx.moveBy(0, 10, 10);
   * }, 5);
   * ```
   * @param repeatBuilder The builder to specify the repeatable list of actions
   * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
   * will repeat forever
   */
  repeat(t, e) {
    return e ? (this._queue.add(new Sa(this._entity, t, e)), this) : (this.repeatForever(t), this);
  }
  /**
   * This method will cause the actor to repeat all of the actions built in
   * the `repeatBuilder` callback. If the number of repeats
   * is not specified it will repeat forever. This method is part of
   * the actor 'Action' fluent API allowing action chaining
   *
   * ```typescript
   * // Move up in a zig-zag by repeated moveBy's
   * actor.actions.repeat(repeatCtx => {
   * repeatCtx.moveBy(10, 0, 10);
   * repeatCtx.moveBy(0, 10, 10);
   * }, 5);
   * ```
   * @param repeatBuilder The builder to specify the repeatable list of actions
   */
  repeatForever(t) {
    return this._queue.add(new Aa(this._entity, t)), this;
  }
  /**
   * This method will cause the entity to follow another at a specified distance
   * @param entity           The entity to follow
   * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
   */
  follow(t, e) {
    return e === void 0 ? this._queue.add(new qs(this._entity, t)) : this._queue.add(new qs(this._entity, t, e)), this;
  }
  /**
   * This method will cause the entity to move towards another until they
   * collide "meet" at a specified speed.
   * @param entity  The entity to meet
   * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
   * @param tolerance  The tolerance in pixels to meet, if not specified it will be 1 pixel
   */
  meet(t, e, i) {
    return e === void 0 && i === void 0 ? this._queue.add(new Ni(this._entity, t)) : i === void 0 ? this._queue.add(new Ni(this._entity, t, e)) : this._queue.add(new Ni(this._entity, t, e, i)), this;
  }
  /**
   * Returns a promise that resolves when the current action queue up to now
   * is finished.
   */
  toPromise() {
    return new Promise((e) => {
      this._queue.add(
        new Gs(() => {
          e();
        })
      );
    });
  }
}
class Xe extends kt {
  constructor() {
    super(...arguments), this.dependencies = [P, N], this._ctx = null;
  }
  onAdd(t) {
    this._ctx = new ki(t);
  }
  onRemove() {
    this._ctx = null;
  }
  _getCtx() {
    if (!this._ctx)
      throw new Error("Actions component not attached to an entity, no context available");
    return this._ctx;
  }
  /**
   * Returns the internal action queue
   * @returns action queue
   */
  getQueue() {
    if (!this._ctx)
      throw new Error("Actions component not attached to an entity, no queue available");
    return this._ctx.getQueue();
  }
  /**
   * Runs a specific action in the action queue
   * @param action
   */
  runAction(t) {
    if (!this._ctx)
      throw new Error("Actions component not attached to an entity, cannot run action");
    return this._ctx.runAction(t);
  }
  /**
   * Updates the internal action context, performing action and moving through the internal queue
   * @param elapsed
   */
  update(t) {
    var e;
    return (e = this._ctx) == null ? void 0 : e.update(t);
  }
  /**
   * Clears all queued actions from the Actor
   */
  clearActions() {
    var t;
    (t = this._ctx) == null || t.clearActions();
  }
  /**
   * Animates an actor with a specified bezier curve by an offset to the current position, the start point is assumed
   * to be the actors current position
   * @param options
   */
  curveBy(t) {
    return this._getCtx().curveBy.apply(this._ctx, [t]);
  }
  /**
   * Animates an actor with a specified bezier curve to an absolute world space coordinate, the start point is assumed
   * to be the actors current position
   * @param options
   */
  curveTo(t) {
    return this._getCtx().curveTo.apply(this._ctx, [t]);
  }
  easeTo(...t) {
    return this._getCtx().easeTo.apply(this._ctx, t);
  }
  easeBy(...t) {
    return this._getCtx().easeBy.apply(this._ctx, t);
  }
  moveTo(t, e, i) {
    return this._getCtx().moveTo.apply(this._ctx, [t, e, i]);
  }
  moveBy(t, e, i) {
    return this._getCtx().moveBy.apply(this._ctx, [t, e, i]);
  }
  rotateTo(t, e, i) {
    return this._getCtx().rotateTo.apply(this._ctx, [t, e, i]);
  }
  rotateBy(t, e, i) {
    return this._getCtx().rotateBy.apply(this._ctx, [t, e, i]);
  }
  scaleTo(t, e, i, s) {
    return this._getCtx().scaleTo.apply(this._ctx, [t, e, i, s]);
  }
  scaleBy(t, e, i) {
    return this._getCtx().scaleBy.apply(this._ctx, [t, e, i]);
  }
  /**
   * This method will cause an actor to blink (become visible and not
   * visible). Optionally, you may specify the number of blinks. Specify the amount of time
   * the actor should be visible per blink, and the amount of time not visible.
   * This method is part of the actor 'Action' fluent API allowing action chaining.
   * @param timeVisible     The amount of time to stay visible per blink in milliseconds
   * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
   * @param numBlinks       The number of times to blink
   */
  blink(t, e, i) {
    return this._getCtx().blink(t, e, i);
  }
  /**
   * This method will cause an actor's opacity to change from its current value
   * to the provided value by a specified time (in milliseconds). This method is
   * part of the actor 'Action' fluent API allowing action chaining.
   * @param opacity  The ending opacity
   * @param duration     The time it should take to fade the actor (in milliseconds)
   */
  fade(t, e) {
    return this._getCtx().fade(t, e);
  }
  /**
   * This will cause an actor to flash a specific color for a period of time
   * @param color
   * @param duration The duration in milliseconds
   */
  flash(t, e = 1e3) {
    return this._getCtx().flash(t, e);
  }
  /**
   * This method will delay the next action from executing for a certain
   * amount of time (in milliseconds). This method is part of the actor
   * 'Action' fluent API allowing action chaining.
   * @param duration  The amount of time to delay the next action in the queue from executing in milliseconds
   */
  delay(t) {
    return this._getCtx().delay(t);
  }
  /**
   * This method will add an action to the queue that will remove the actor from the
   * scene once it has completed its previous  Any actions on the
   * action queue after this action will not be executed.
   */
  die() {
    return this._getCtx().die();
  }
  /**
   * This method allows you to call an arbitrary method as the next action in the
   * action queue. This is useful if you want to execute code in after a specific
   * action, i.e An actor arrives at a destination after traversing a path
   */
  callMethod(t) {
    return this._getCtx().callMethod(t);
  }
  /**
   * This method will cause the actor to repeat all of the actions built in
   * the `repeatBuilder` callback. If the number of repeats
   * is not specified it will repeat forever. This method is part of
   * the actor 'Action' fluent API allowing action chaining
   *
   * ```typescript
   * // Move up in a zig-zag by repeated moveBy's
   * actor.actions.repeat(repeatCtx => {
   * repeatCtx.moveBy(10, 0, 10);
   * repeatCtx.moveBy(0, 10, 10);
   * }, 5);
   * ```
   * @param repeatBuilder The builder to specify the repeatable list of actions
   * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
   * will repeat forever
   */
  repeat(t, e) {
    return this._getCtx().repeat(t, e);
  }
  /**
   * This method will cause the actor to repeat all of the actions built in
   * the `repeatBuilder` callback. If the number of repeats
   * is not specified it will repeat forever. This method is part of
   * the actor 'Action' fluent API allowing action chaining
   *
   * ```typescript
   * // Move up in a zig-zag by repeated moveBy's
   * actor.actions.repeat(repeatCtx => {
   * repeatCtx.moveBy(10, 0, 10);
   * repeatCtx.moveBy(0, 10, 10);
   * }, 5);
   * ```
   * @param repeatBuilder The builder to specify the repeatable list of actions
   */
  repeatForever(t) {
    return this._getCtx().repeatForever(t);
  }
  /**
   * This method will cause the entity to follow another at a specified distance
   * @param entity           The entity to follow
   * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
   */
  follow(t, e) {
    return this._getCtx().follow(t, e);
  }
  /**
   * This method will cause the entity to move towards another until they
   * collide "meet" at a specified speed.
   * @param entity  The entity to meet
   * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
   */
  meet(t, e) {
    return this._getCtx().meet(t, e);
  }
  /**
   * Returns a promise that resolves when the current action queue up to now
   * is finished.
   */
  toPromise() {
    return this._getCtx().toPromise();
  }
}
function Vl(r) {
  return r instanceof Dt;
}
const Gl = {
  CollisionStart: "collisionstart",
  CollisionEnd: "collisionend",
  PreCollision: "precollision",
  PostCollision: "postcollision",
  Kill: "kill",
  PreKill: "prekill",
  PostKill: "postkill",
  PreDraw: "predraw",
  PostDraw: "postdraw",
  PreTransformDraw: "pretransformdraw",
  PostTransformDraw: "posttransformdraw",
  PreDebugDraw: "predebugdraw",
  PostDebugDraw: "postdebugdraw",
  PointerUp: "pointerup",
  PointerDown: "pointerdown",
  PointerEnter: "pointerenter",
  PointerLeave: "pointerleave",
  PointerMove: "pointermove",
  PointerCancel: "pointercancel",
  Wheel: "pointerwheel",
  PointerDrag: "pointerdragstart",
  PointerDragEnd: "pointerdragend",
  PointerDragEnter: "pointerdragenter",
  PointerDragLeave: "pointerdragleave",
  PointerDragMove: "pointerdragmove",
  EnterViewPort: "enterviewport",
  ExitViewPort: "exitviewport",
  ActionStart: "actionstart",
  ActionComplete: "actioncomplete"
}, Rr = class os extends Rt {
  // #endregion
  /**
   *
   * @param config
   */
  constructor(t) {
    super(), this.events = new X(), this._anchor = Pt(v.Half, (O) => this._handleAnchorChange(O)), this._offset = Pt(v.Zero, (O) => this._handleOffsetChange(O)), this.logger = R.getInstance(), this._draggable = !1, this._dragging = !1, this._pointerDragStartHandler = () => {
      this._dragging = !0;
    }, this._pointerDragEndHandler = () => {
      this._dragging = !1;
    }, this._pointerDragMoveHandler = (O) => {
      this._dragging && (this.pos = O.worldPos);
    }, this._pointerDragLeaveHandler = (O) => {
      this._dragging && (this.pos = O.worldPos);
    };
    const {
      name: e,
      x: i,
      y: s,
      pos: n,
      coordPlane: o,
      scale: a,
      width: h,
      height: l,
      radius: c,
      collider: d,
      vel: u,
      acc: _,
      rotation: p,
      angularVelocity: g,
      z: x,
      color: m,
      visible: f,
      opacity: b,
      anchor: C,
      offset: S,
      collisionType: I,
      collisionGroup: y,
      graphic: k,
      material: L
    } = {
      ...t
    };
    this.name = e != null ? e : this.name, this.anchor = C != null ? C : os.defaults.anchor.clone(), this.offset = S != null ? S : v.Zero, this.transform = new P(), this.addComponent(this.transform), this.pos = n != null ? n : w(i != null ? i : 0, s != null ? s : 0), this.rotation = p != null ? p : 0, this.scale = a != null ? a : w(1, 1), this.z = x != null ? x : 0, this.transform.coordPlane = o != null ? o : at.World, this.pointer = new fe(), this.addComponent(this.pointer), this.graphics = new tt({
      anchor: this.anchor,
      offset: this.offset,
      opacity: b
    }), this.addComponent(this.graphics), this.motion = new N(), this.addComponent(this.motion), this.vel = u != null ? u : v.Zero, this.acc = _ != null ? _ : v.Zero, this.angularVelocity = g != null ? g : 0, this.actions = new Xe(), this.addComponent(this.actions), this.body = new U(), this.addComponent(this.body), this.body.collisionType = I != null ? I : E.Passive, y && (this.body.group = y), m && (this.color = m), d ? (this.collider = new it(d), this.addComponent(this.collider)) : c ? (this.collider = new it(_t.Circle(c)), this.addComponent(this.collider), m && this.graphics.add(
      new ms({
        color: m,
        radius: c
      })
    )) : h > 0 && l > 0 ? (this.collider = new it(_t.Box(h, l, this.anchor)), this.addComponent(this.collider), m && h && l && this.graphics.add(
      new Fi({
        color: m,
        width: h,
        height: l
      })
    )) : (this.collider = new it(), this.addComponent(this.collider)), this.graphics.isVisible = f != null ? f : !0, k && this.graphics.use(k), L && (this.graphics.material = L);
  }
  /**
   * Gets the position vector of the actor in pixels
   */
  get pos() {
    return this.transform.pos;
  }
  /**
   * Sets the position vector of the actor in pixels
   */
  set pos(t) {
    this.transform.pos = t.clone();
  }
  /**
   * Gets the position vector of the actor from the last frame
   */
  get oldPos() {
    return this.body.oldPos;
  }
  /**
   * Gets the global position vector of the actor from the last frame
   */
  get oldGlobalPos() {
    return this.body.oldGlobalPos;
  }
  /**
   * Sets the position vector of the actor in the last frame
   */
  set oldPos(t) {
    this.body.oldPos.setTo(t.x, t.y);
  }
  /**
   * Gets the velocity vector of the actor in pixels/sec
   */
  get vel() {
    return this.motion.vel;
  }
  /**
   * Sets the velocity vector of the actor in pixels/sec
   */
  set vel(t) {
    this.motion.vel = t.clone();
  }
  /**
   * Gets the velocity vector of the actor from the last frame
   */
  get oldVel() {
    return this.body.oldVel;
  }
  /**
   * Sets the velocity vector of the actor from the last frame
   */
  set oldVel(t) {
    this.body.oldVel.setTo(t.x, t.y);
  }
  /**
   * Gets the acceleration vector of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may be
   * useful to simulate a gravitational effect.
   */
  get acc() {
    return this.motion.acc;
  }
  /**
   * Sets the acceleration vector of teh actor in pixels/second/second
   */
  set acc(t) {
    this.motion.acc = t.clone();
  }
  /**
   * Sets the acceleration of the actor from the last frame. This does not include the global acc {@apilink Physics.acc}.
   */
  set oldAcc(t) {
    this.body.oldAcc.setTo(t.x, t.y);
  }
  /**
   * Gets the acceleration of the actor from the last frame. This does not include the global acc {@apilink Physics.acc}.
   */
  get oldAcc() {
    return this.body.oldAcc;
  }
  /**
   * Gets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
   */
  get rotation() {
    return this.transform.rotation;
  }
  /**
   * Sets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
   */
  set rotation(t) {
    this.transform.rotation = t;
  }
  /**
   * Gets the rotational velocity of the actor in radians/second
   */
  get angularVelocity() {
    return this.motion.angularVelocity;
  }
  /**
   * Sets the rotational velocity of the actor in radians/sec
   */
  set angularVelocity(t) {
    this.motion.angularVelocity = t;
  }
  get scale() {
    return this.get(P).scale;
  }
  set scale(t) {
    this.get(P).scale = t;
  }
  /**
   * The anchor to apply all actor related transformations like rotation,
   * translation, and scaling. By default the anchor is in the center of
   * the actor. By default it is set to the center of the actor (.5, .5)
   *
   * An anchor of (.5, .5) will ensure that drawings are centered.
   *
   * Use `anchor.setTo` to set the anchor to a different point using
   * values between 0 and 1. For example, anchoring to the top-left would be
   * `Actor.anchor.setTo(0, 0)` and top-right would be `Actor.anchor.setTo(0, 1)`.
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(t) {
    this._anchor = Pt(t, (e) => this._handleAnchorChange(e)), this._handleAnchorChange(t);
  }
  _handleAnchorChange(t) {
    this.graphics && (this.graphics.anchor = t);
  }
  /**
   * The offset in pixels to apply to all actor graphics
   *
   * Default offset of (0, 0)
   */
  get offset() {
    return this._offset;
  }
  set offset(t) {
    this._offset = Pt(t, (e) => this._handleOffsetChange(e)), this._handleOffsetChange(t);
  }
  _handleOffsetChange(t) {
    this.graphics && (this.graphics.offset = t);
  }
  /**
   * Indicates whether the actor is physically in the viewport
   */
  get isOffScreen() {
    return this.hasTag("ex.offscreen");
  }
  get draggable() {
    return this._draggable;
  }
  set draggable(t) {
    t && (t && !this._draggable ? (this.events.on("pointerdragstart", this._pointerDragStartHandler), this.events.on("pointerdragend", this._pointerDragEndHandler), this.events.on("pointerdragmove", this._pointerDragMoveHandler), this.events.on("pointerdragleave", this._pointerDragLeaveHandler)) : !t && this._draggable && (this.events.off("pointerdragstart", this._pointerDragStartHandler), this.events.off("pointerdragend", this._pointerDragEndHandler), this.events.off("pointerdragmove", this._pointerDragMoveHandler), this.events.off("pointerdragleave", this._pointerDragLeaveHandler)), this._draggable = t);
  }
  /**
   * Sets the color of the actor's current graphic
   */
  get color() {
    return this.graphics.color;
  }
  set color(t) {
    this.graphics.color = t;
  }
  clone() {
    const t = new os({
      color: this.color.clone(),
      anchor: this.anchor.clone(),
      offset: this.offset.clone()
    });
    t.clearComponents(), t.processComponentRemoval(), t.addComponent(t.transform = this.transform.clone(), !0), t.addComponent(t.pointer = this.pointer.clone(), !0), t.addComponent(t.graphics = this.graphics.clone(), !0), t.addComponent(t.motion = this.motion.clone(), !0), t.addComponent(t.actions = this.actions.clone(), !0), t.addComponent(t.body = this.body.clone(), !0), this.collider.get() && t.addComponent(t.collider = this.collider.clone(), !0);
    const e = [
      this.transform,
      this.pointer,
      this.graphics,
      this.motion,
      this.actions,
      this.body,
      this.collider
    ], i = this.getComponents();
    for (const s of i)
      e.includes(s) || t.addComponent(s.clone(), !0);
    return t;
  }
  /**
   * `onInitialize` is called before the first update of the actor. This method is meant to be
   * overridden. This is where initialization of child actors should take place.
   *
   * Synonymous with the event handler `.on('initialize', (evt) => {...})`
   */
  onInitialize(t) {
  }
  /**
   * Initializes this actor and all it's child actors, meant to be called by the Scene before first update not by users of Excalibur.
   *
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   * @internal
   */
  _initialize(t) {
    super._initialize(t);
    for (const e of this.children)
      e._initialize(t);
  }
  emit(t, e) {
    this.events.emit(t, e);
  }
  on(t, e) {
    return this.events.on(t, e);
  }
  once(t, e) {
    return this.events.once(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
  // #endregion
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _prekill handler for {@apilink onPreKill} lifecycle event
   * @internal
   */
  _prekill(t) {
    this.events.emit("prekill", new vn(this)), this.onPreKill(t);
  }
  /**
   * Safe to override onPreKill lifecycle event handler. Synonymous with `.on('prekill', (evt) =>{...})`
   *
   * `onPreKill` is called directly before an actor is killed and removed from its current {@apilink Scene}.
   */
  onPreKill(t) {
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _prekill handler for {@apilink onPostKill} lifecycle event
   * @internal
   */
  _postkill(t) {
    this.events.emit("postkill", new wn(this)), this.onPostKill(t);
  }
  /**
   * Safe to override onPostKill lifecycle event handler. Synonymous with `.on('postkill', (evt) => {...})`
   *
   * `onPostKill` is called directly after an actor is killed and remove from its current {@apilink Scene}.
   */
  onPostKill(t) {
  }
  /**
   * If the current actor is a member of the scene, this will remove
   * it from the scene graph. It will no longer be drawn or updated.
   */
  kill() {
    this.scene ? (this._prekill(this.scene), super.kill(), this._postkill(this.scene)) : this.logger.warn(`Cannot kill actor named "${this.name}", it was never added to the Scene`);
  }
  /**
   * If the current actor is killed, it will now not be killed.
   */
  unkill() {
    this.isActive = !0;
  }
  /**
   * Indicates wether the actor has been killed.
   */
  isKilled() {
    return !this.isActive;
  }
  /**
   * Gets the z-index of an actor. The z-index determines the relative order an actor is drawn in.
   * Actors with a higher z-index are drawn on top of actors with a lower z-index
   */
  get z() {
    return this.get(P).z;
  }
  /**
   * Sets the z-index of an actor and updates it in the drawing list for the scene.
   * The z-index determines the relative order an actor is drawn in.
   * Actors with a higher z-index are drawn on top of actors with a lower z-index
   * @param newZ new z-index to assign
   */
  set z(t) {
    this.get(P).z = t;
  }
  /**
   * Get the center point of an actor (global position)
   */
  get center() {
    const t = this.getGlobalPos();
    return new v(
      t.x + this.width / 2 - this.anchor.x * this.width,
      t.y + this.height / 2 - this.anchor.y * this.height
    );
  }
  /**
   * Get the local center point of an actor
   */
  get localCenter() {
    return new v(this.pos.x + this.width / 2 - this.anchor.x * this.width, this.pos.y + this.height / 2 - this.anchor.y * this.height);
  }
  get width() {
    return this.collider.localBounds.width * this.getGlobalScale().x;
  }
  get height() {
    return this.collider.localBounds.height * this.getGlobalScale().y;
  }
  /**
   * Gets this actor's rotation taking into account any parent relationships
   * @returns Rotation angle in radians
   * @deprecated Use {@apilink globalRotation} instead
   */
  getGlobalRotation() {
    return this.get(P).globalRotation;
  }
  /**
   * The actor's rotation (in radians) taking into account any parent relationships
   */
  get globalRotation() {
    return this.get(P).globalRotation;
  }
  /**
   * Gets an actor's world position taking into account parent relationships, scaling, rotation, and translation
   * @returns Position in world coordinates
   * @deprecated Use {@apilink globalPos} instead
   */
  getGlobalPos() {
    return this.get(P).globalPos;
  }
  /**
   * The actor's world position taking into account parent relationships, scaling, rotation, and translation
   */
  get globalPos() {
    return this.get(P).globalPos;
  }
  /**
   * Gets the global scale of the Actor
   * @deprecated Use {@apilink globalScale} instead
   */
  getGlobalScale() {
    return this.get(P).globalScale;
  }
  /**
   * The global scale of the Actor
   */
  get globalScale() {
    return this.get(P).globalScale;
  }
  /**
   * The global z-index of the actor
   */
  get globalZ() {
    return this.get(P).globalZ;
  }
  // #region Collision
  /**
   * Tests whether the x/y specified are contained in the actor
   * @param x  X coordinate to test (in world coordinates)
   * @param y  Y coordinate to test (in world coordinates)
   * @param recurse checks whether the x/y are contained in any child actors (if they exist).
   */
  contains(t, e, i = !1) {
    const s = w(t, e), n = this.get(it);
    n.update();
    const o = n.get();
    if (!o)
      return !1;
    const a = o.contains(s);
    return i ? a || this.children.some((h) => h.contains(t, e, !0)) : a;
  }
  /**
   * Returns true if the two actor.collider's surfaces are less than or equal to the distance specified from each other
   * @param actor     Actor to test
   * @param distance  Distance in pixels to test
   */
  within(t, e) {
    const i = this.get(it), s = t.get(it), n = i.get(), o = s.get();
    return n && o ? n.getClosestLineBetween(o).getLength() <= e : !1;
  }
  // #endregion
  // #region Update
  /**
   * Called by the Engine, updates the state of the actor
   * @internal
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   */
  update(t, e) {
    this._initialize(t), this._add(t), this._preupdate(t, e), this._postupdate(t, e), this._remove(t);
  }
  /**
   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
   *
   * `onPreUpdate` is called directly before an actor is updated.
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   */
  onPreUpdate(t, e) {
  }
  /**
   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`
   *
   * `onPostUpdate` is called directly after an actor is updated.
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   */
  onPostUpdate(t, e) {
  }
  /**
   * Fires before every collision resolution for a confirmed contact
   * @param self
   * @param other
   * @param side
   * @param contact
   */
  onPreCollisionResolve(t, e, i, s) {
  }
  /**
   * Fires after every resolution for a confirmed contact.
   * @param self
   * @param other
   * @param side
   * @param contact
   */
  onPostCollisionResolve(t, e, i, s) {
  }
  /**
   * Fires once when 2 entities with a ColliderComponent first start colliding or touching, if the Colliders stay in contact this
   * does not continue firing until they separate and re-collide.
   * @param self
   * @param other
   * @param side
   * @param contact
   */
  onCollisionStart(t, e, i, s) {
  }
  /**
   * Fires once when 2 entities with a ColliderComponent separate after having been in contact.
   * @param self
   * @param other
   * @param side
   * @param lastContact
   */
  onCollisionEnd(t, e, i, s) {
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _preupdate handler for {@apilink onPreUpdate} lifecycle event
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   * @internal
   */
  _preupdate(t, e) {
    this.events.emit("preupdate", new pe(t, e, this)), this.onPreUpdate(t, e);
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _preupdate handler for {@apilink onPostUpdate} lifecycle event
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   * @internal
   */
  _postupdate(t, e) {
    this.events.emit("postupdate", new me(t, e, this)), this.onPostUpdate(t, e);
  }
  // endregion
};
Rr.defaults = {
  anchor: v.Half
};
let Dt = Rr;
class it extends kt {
  constructor(t) {
    super(), this.events = new X(), this.$colliderAdded = new mt(), this.$colliderRemoved = new mt(), this._collidersToRemove = [], this.set(t);
  }
  /**
   * Get the current collider geometry
   */
  get() {
    return this._collider;
  }
  /**
   * Set the collider geometry
   * @param collider
   * @returns the collider you set
   */
  set(t) {
    return this.clear(), t && (this._collider = t, this._collider.owner = this.owner, t.events.pipe(this.events), this.$colliderAdded.notifyAll(t), this.update()), t;
  }
  /**
   * Remove collider geometry from collider component
   */
  clear() {
    this._collider && (this._collidersToRemove.push(this._collider), this._collider = null);
  }
  processColliderRemoval() {
    for (const t of this._collidersToRemove)
      t.events.unpipe(this.events), this.$colliderRemoved.notifyAll(t), t.owner = null;
  }
  clone() {
    return new it(this._collider.clone());
  }
  /**
   * Return world space bounds
   */
  get bounds() {
    var t, e;
    return (e = (t = this._collider) == null ? void 0 : t.bounds) != null ? e : new F();
  }
  /**
   * Return local space bounds
   */
  get localBounds() {
    var t, e;
    return (e = (t = this._collider) == null ? void 0 : t.localBounds) != null ? e : new F();
  }
  /**
   * Update the collider's transformed geometry
   */
  update() {
    var t;
    const e = (t = this.owner) == null ? void 0 : t.get(P);
    this._collider && (this._collider.owner = this.owner, e && this._collider.update(e.get()));
  }
  /**
   * Collide component with another
   * @param other
   */
  collide(t) {
    let e = this._collider, i = t._collider;
    if (!e || !i)
      return [];
    let s = !1;
    if (i instanceof ht && (e = i, i = this._collider, s = !0), this._collider) {
      const n = e.collide(i);
      return n ? (s && n.forEach((o) => {
        o.mtv = o.mtv.negate(), o.normal = o.normal.negate(), o.tangent = o.normal.perpendicular(), o.colliderA = this._collider, o.colliderB = t._collider;
      }), n) : [];
    }
    return [];
  }
  onAdd(t) {
    this._collider && this.update(), this.events.on("precollision", (e) => {
      const i = e;
      t.events.emit(
        "precollision",
        new Ie(i.self, i.other, i.side, i.intersection, i.contact)
      ), t instanceof Dt && t.onPreCollisionResolve(i.self, i.other, i.side, i.contact);
    }), this.events.on("postcollision", (e) => {
      const i = e;
      t.events.emit(
        "postcollision",
        new Re(
          i.self,
          i.other,
          i.side,
          i.intersection,
          i.contact
        )
      ), t instanceof Dt && t.onPostCollisionResolve(i.self, i.other, i.side, i.contact);
    }), this.events.on("collisionstart", (e) => {
      const i = e;
      t.events.emit("collisionstart", new pi(i.self, i.other, i.side, i.contact)), t instanceof Dt && t.onCollisionStart(i.self, i.other, i.side, i.contact);
    }), this.events.on("collisionend", (e) => {
      const i = e;
      t.events.emit("collisionend", new mi(i.self, i.other, i.side, i.lastContact)), t instanceof Dt && t.onCollisionEnd(i.self, i.other, i.side, i.lastContact);
    });
  }
  onRemove() {
    this.events.clear(), this.$colliderRemoved.notifyAll(this._collider);
  }
  /**
   * Sets up a box geometry based on the current bounds of the associated actor of this physics body.
   *
   * If no width/height are specified the body will attempt to use the associated actor's width/height.
   *
   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
   */
  useBoxCollider(t, e, i = v.Half, s = v.Zero) {
    const n = _t.Box(t, e, i, s);
    return this.set(n);
  }
  /**
   * Sets up a {@apilink PolygonCollider | `polygon`} collision geometry based on a list of of points relative
   *  to the anchor of the associated actor
   * of this physics body.
   *
   * Only [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon) definitions are supported.
   *
   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
   */
  usePolygonCollider(t, e = v.Zero) {
    const i = _t.Polygon(t, e);
    return this.set(i);
  }
  /**
   * Sets up a {@apilink Circle | `circle collision geometry`} as the only collider with a specified radius in pixels.
   *
   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
   */
  useCircleCollider(t, e = v.Zero) {
    const i = _t.Circle(t, e);
    return this.set(i);
  }
  /**
   * Sets up an {@apilink Edge | `edge collision geometry`} with a start point and an end point relative to the anchor of the associated actor
   * of this physics body.
   *
   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
   */
  useEdgeCollider(t, e) {
    const i = _t.Edge(t, e);
    return this.set(i);
  }
  /**
   * Setups up a {@apilink CompositeCollider} which can define any arbitrary set of excalibur colliders
   * @param colliders
   */
  useCompositeCollider(t) {
    return this.set(new ht(t));
  }
}
var le = /* @__PURE__ */ ((r) => (r.Rotation = "rotation", r.X = "x", r.Y = "y", r))(le || {});
const bs = class ui extends kt {
  constructor(t) {
    var e, i, s;
    super(), this.dependencies = [P, N], this.id = Pe("body", ui._ID++), this.events = new X(), this.island = null, this.oldTransform = new re(), this.__oldTransformCaptured = !1, this.enableFixedUpdateInterpolate = !0, this.sleepTime = 0, this.collisionType = E.PreventCollision, this.group = Ee.All, this.canSleep = this.collisionType === E.Active, this._sleeping = !1, this.bounciness = 0.2, this.friction = 0.99, this.useGravity = !0, this.limitDegreeOfFreedom = [], this._oldGlobalPos = v.Zero, this.oldVel = new v(0, 0), this.oldAcc = v.Zero, this._impulseScratch = w(0, 0), this._distanceFromCenterScratch = w(0, 0), t ? (this.collisionType = (e = t.type) != null ? e : this.collisionType, this.group = (i = t.group) != null ? i : this.group, this.useGravity = (s = t.useGravity) != null ? s : this.useGravity, this._bodyConfig = {
      ...ne().bodies,
      ...t.config
    }) : this._bodyConfig = {
      ...ne().bodies
    }, this.updatePhysicsConfig(this._bodyConfig), this._mass = ui._DEFAULT_CONFIG.defaultMass;
  }
  get matrix() {
    return this.transform.get().matrix;
  }
  /**
   * Called by excalibur to update physics config defaults if they change
   * @param config
   */
  updatePhysicsConfig(t) {
    this._bodyConfig = {
      ...ne().bodies,
      ...t
    }, this.canSleep = this._bodyConfig.canSleepByDefault, this.sleepMotion = this._bodyConfig.sleepEpsilon * 5, this.wakeThreshold = this._bodyConfig.wakeThreshold;
  }
  get canFallAsleep() {
    return this.canSleep && this.collisionType === E.Active && this.sleepMotion < this._bodyConfig.sleepEpsilon;
  }
  get canWakeUp() {
    return this.collisionType === E.Active && this.sleepMotion > this.wakeThreshold;
  }
  /**
   * Called by excalibur to update defaults
   * @param config
   */
  static updateDefaultPhysicsConfig(t) {
    ui._DEFAULT_CONFIG = t;
  }
  get mass() {
    return this._mass;
  }
  set mass(t) {
    this._mass = t, this._cachedInertia = void 0, this._cachedInverseInertia = void 0;
  }
  /**
   * The inverse mass (1/mass) of the body. If {@apilink CollisionType.Fixed} this is 0, meaning "infinite" mass
   */
  get inverseMass() {
    return this.collisionType === E.Fixed ? 0 : 1 / this.mass;
  }
  /**
   * Whether this body is sleeping or not
   * @deprecated use isSleeping
   */
  get sleeping() {
    return this.isSleeping;
  }
  /**
   * Whether this body is sleeping or not
   */
  get isSleeping() {
    return this.canSleep && this._sleeping;
  }
  /**
   * Set the sleep state of the body
   * @param sleeping
   * @deprecated use isSleeping
   */
  setSleeping(t) {
    this.isSleeping = t;
  }
  wake() {
    var t;
    this._sleeping && this.collisionType === E.Active && (this._sleeping = !1, (t = this.owner) == null || t.removeTag("ex.is_sleeping"), this.sleepMotion = this._bodyConfig.sleepEpsilon * 2, this.sleepTime = 0);
  }
  sleep() {
    var t;
    !this._sleeping && this.canSleep && (this._sleeping = !0, (t = this.owner) == null || t.addTag("ex.is_sleeping"), this.vel = v.Zero, this.acc = v.Zero, this.angularVelocity = 0, this.sleepMotion = 0);
  }
  set isSleeping(t) {
    t ? this.sleep() : this.wake();
  }
  /**
   * Update body's {@apilink BodyComponent.sleepMotion} for the purpose of sleeping
   */
  updateMotion(t) {
    if (this.collisionType !== E.Active)
      return;
    const e = this.pos.sub(this.oldPos), i = no(Ht(this.rotation), Ht(this.oldRotation)), s = e.magnitude, n = i, o = s * s + n * n, a = Math.pow(this._bodyConfig.sleepBias, t / 1e3), h = this.sleepMotion;
    this.sleepMotion = a * h + (1 - a) * o, this.sleepMotion = D(this.sleepMotion, 0, 10 * this._bodyConfig.sleepEpsilon), this.canFallAsleep && (this.sleepTime += t);
  }
  /**
   * Get the moment of inertia from the {@apilink ColliderComponent}
   */
  get inertia() {
    if (this._cachedInertia)
      return this._cachedInertia;
    const t = this.owner.get(it);
    if (t) {
      t.$colliderAdded.subscribe(() => {
        this._cachedInertia = null;
      }), t.$colliderRemoved.subscribe(() => {
        this._cachedInertia = null;
      });
      const e = t.get();
      if (e)
        return this._cachedInertia = e.getInertia(this.mass);
    }
    return 0;
  }
  /**
   * Get the inverse moment of inertial from the {@apilink ColliderComponent}. If {@apilink CollisionType.Fixed} this is 0, meaning "infinite" mass
   */
  get inverseInertia() {
    return this._cachedInverseInertia ? this._cachedInverseInertia : this._cachedInverseInertia = this.collisionType === E.Fixed ? 0 : 1 / this.inertia;
  }
  /**
   * Returns if the owner is active
   * @deprecated use isActive
   */
  get active() {
    var t;
    return !!((t = this.owner) != null && t.isActive);
  }
  /**
   * Returns if the owner is active
   */
  get isActive() {
    var t;
    return !!((t = this.owner) != null && t.isActive);
  }
  /**
   * @deprecated Use globalPos
   */
  get center() {
    return this.globalPos;
  }
  onAdd(t) {
    var e, i;
    this.transform = (e = this.owner) == null ? void 0 : e.get(P), this.motion = (i = this.owner) == null ? void 0 : i.get(N);
  }
  get pos() {
    return this.transform.pos;
  }
  set pos(t) {
    this.transform.pos = t;
  }
  /**
   * The (x, y) position of the actor this will be in the middle of the actor if the
   * {@apilink Actor.anchor} is set to (0.5, 0.5) which is default.
   * If you want the (x, y) position to be the top left of the actor specify an anchor of (0, 0).
   */
  get globalPos() {
    return this.transform.globalPos;
  }
  set globalPos(t) {
    this.transform.globalPos = t;
  }
  /**
   * The position of the actor last frame (x, y) in pixels
   */
  get oldPos() {
    return this.oldTransform.pos;
  }
  /**
   * The global position of the actor last frame (x, y) in pixels
   */
  get oldGlobalPos() {
    return this._oldGlobalPos;
  }
  /**
   * The current velocity vector (vx, vy) of the actor in pixels/second
   */
  get vel() {
    return this.motion.vel;
  }
  set vel(t) {
    this.motion.vel = t;
  }
  /**
   * The current acceleration vector (ax, ay) of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may
   * be useful to simulate a gravitational effect.
   */
  get acc() {
    return this.motion.acc;
  }
  set acc(t) {
    this.motion.acc = t;
  }
  /**
   * The current torque applied to the actor
   */
  get torque() {
    return this.motion.torque;
  }
  set torque(t) {
    this.motion.torque = t;
  }
  /**
   * Gets/sets the rotation of the body from the last frame.
   */
  get oldRotation() {
    return this.oldTransform.rotation;
  }
  /**
   * The rotation of the body in radians
   */
  get rotation() {
    return this.transform.globalRotation;
  }
  set rotation(t) {
    this.transform.globalRotation = t;
  }
  /**
   * The scale vector of the actor
   */
  get scale() {
    return this.transform.globalScale;
  }
  set scale(t) {
    this.transform.globalScale = t;
  }
  /**
   * The scale of the actor last frame
   */
  get oldScale() {
    return this.oldTransform.scale;
  }
  /**
   * The scale rate of change of the actor in scale/second
   */
  get scaleFactor() {
    return this.motion.scaleFactor;
  }
  set scaleFactor(t) {
    this.motion.scaleFactor = t;
  }
  /**
   * Get the angular velocity in radians/second
   */
  get angularVelocity() {
    return this.motion.angularVelocity;
  }
  /**
   * Set the angular velocity in radians/second
   */
  set angularVelocity(t) {
    this.motion.angularVelocity = t;
  }
  /**
   * Apply a specific impulse to the body
   * @param point
   * @param impulse
   */
  applyImpulse(t, e) {
    if (this.collisionType !== E.Active)
      return;
    const i = e.scale(this.inverseMass, this._impulseScratch);
    if (this.limitDegreeOfFreedom.indexOf(
      "x"
      /* X */
    ) > -1 && (i.x = 0), this.limitDegreeOfFreedom.indexOf(
      "y"
      /* Y */
    ) > -1 && (i.y = 0), this.vel.addEqual(i), !this.limitDegreeOfFreedom.includes(
      "rotation"
      /* Rotation */
    )) {
      const s = t.sub(this.globalPos, this._distanceFromCenterScratch);
      this.angularVelocity += this.inverseInertia * s.cross(e);
    }
  }
  /**
   * Apply only linear impulse to the body
   * @param impulse
   */
  applyLinearImpulse(t) {
    if (this.collisionType !== E.Active)
      return;
    const e = t.scale(this.inverseMass);
    this.limitDegreeOfFreedom.includes(
      "x"
      /* X */
    ) && (e.x = 0), this.limitDegreeOfFreedom.includes(
      "y"
      /* Y */
    ) && (e.y = 0), this.vel = this.vel.add(e);
  }
  /**
   * Apply only angular impulse to the body
   * @param point
   * @param impulse
   */
  applyAngularImpulse(t, e) {
    if (this.collisionType === E.Active && !this.limitDegreeOfFreedom.includes(
      "rotation"
      /* Rotation */
    )) {
      const i = t.sub(this.globalPos);
      this.angularVelocity += this.inverseInertia * i.cross(e);
    }
  }
  /**
   * Sets the old versions of pos, vel, acc, and scale.
   */
  captureOldTransform() {
    this.__oldTransformCaptured = !0;
    const t = this.transform.get();
    t.clone(this.oldTransform), this.oldTransform.parent = t.parent, this.oldVel.setTo(this.vel.x, this.vel.y), this.oldAcc.setTo(this.acc.x, this.acc.y), this.oldGlobalPos.setTo(this.globalPos.x, this.globalPos.y);
  }
  clone() {
    return super.clone();
  }
};
bs._ID = 0;
bs._DEFAULT_CONFIG = {
  ...ne().bodies
};
let U = bs;
class Mr {
  constructor(t, e) {
    this.object = t, this.id = -1, this.cells = [], this.hasZeroBounds = !1, this.gridSize = e, this.bounds = t.bounds, this.hasZeroBounds = this.bounds.hasZeroDimensions(), this.leftX = Math.floor(this.bounds.left / this.gridSize), this.rightX = Math.floor(this.bounds.right / this.gridSize), this.bottomY = Math.floor(this.bounds.bottom / this.gridSize), this.topY = Math.floor(this.bounds.top / this.gridSize);
  }
  /**
   * Has the hashed bounds changed
   */
  hasChanged() {
    const t = this.object.bounds, e = Math.floor(t.left / this.gridSize), i = Math.floor(t.right / this.gridSize), s = Math.floor(t.bottom / this.gridSize), n = Math.floor(t.top / this.gridSize);
    return this.leftX !== e || this.rightX !== i || this.bottomY !== s || this.topY !== n;
  }
  /**
   * Clears all collider references
   */
  clear() {
    for (const t of this.cells) {
      const e = t.proxies.indexOf(this);
      e > -1 && t.proxies.splice(e, 1);
    }
  }
  /**
   * Update bounds of the proxy
   */
  updateBounds() {
    this.bounds = this.object.bounds;
  }
  /**
   * Updates the hashed bounds coordinates
   */
  update() {
    this.bounds = this.object.bounds, this.leftX = Math.floor(this.bounds.left / this.gridSize), this.rightX = Math.floor(this.bounds.right / this.gridSize), this.bottomY = Math.floor(this.bounds.bottom / this.gridSize), this.topY = Math.floor(this.bounds.top / this.gridSize), this.hasZeroBounds = this.object.bounds.hasZeroDimensions();
  }
}
class Yt {
  constructor() {
    this.proxies = [];
  }
  configure(t, e) {
    this.x = t, this.y = e, this.key = Yt.calculateHashKey(t, e);
  }
  static calculateHashKey(t, e) {
    return `${t}+${e}`;
  }
}
class Fr {
  constructor(t) {
    this.bounds = new F(), this._hashGridCellPool = new ii(
      () => new Yt(),
      (e) => (e.configure(0, 0), e.proxies.length = 0, e),
      1e3
    ), this.gridSize = t.size, this.sparseHashGrid = /* @__PURE__ */ new Map(), this.objectToProxy = /* @__PURE__ */ new Map(), t.proxyFactory ? this._buildProxy = (e) => t.proxyFactory(e, this.gridSize) : this._buildProxy = (e) => new Mr(e, this.gridSize);
  }
  query(t) {
    const e = /* @__PURE__ */ new Set();
    if (t instanceof F) {
      const i = t, s = Math.floor(i.left / this.gridSize), n = Math.floor(i.right / this.gridSize), o = Math.floor(i.bottom / this.gridSize), a = Math.floor(i.top / this.gridSize);
      for (let h = s; h <= n; h++)
        for (let l = a; l <= o; l++) {
          const c = Yt.calculateHashKey(h, l), d = this.sparseHashGrid.get(c);
          if (d)
            for (let u = 0; u < d.proxies.length; u++)
              d.proxies[u].updateBounds(), d.proxies[u].bounds.intersect(i) && e.add(d.proxies[u].object);
        }
    } else {
      const i = t, s = Yt.calculateHashKey(Math.floor(i.x / this.gridSize), Math.floor(i.y / this.gridSize)), n = this.sparseHashGrid.get(s);
      if (n)
        for (let o = 0; o < n.proxies.length; o++)
          n.proxies[o].updateBounds(), n.proxies[o].bounds.contains(i) && e.add(n.proxies[o].object);
    }
    return Array.from(e);
  }
  get(t, e) {
    const i = Yt.calculateHashKey(t, e);
    return this.sparseHashGrid.get(i);
  }
  _insert(t, e, i) {
    const s = Yt.calculateHashKey(t, e);
    let n = this.sparseHashGrid.get(s);
    n || (n = this._hashGridCellPool.rent(), n.configure(t, e), this.sparseHashGrid.set(n.key, n)), n.proxies.push(i), i.cells.push(n), this.bounds.combine(i.bounds, this.bounds);
  }
  _remove(t, e, i) {
    const s = Yt.calculateHashKey(t, e), n = this.sparseHashGrid.get(s);
    if (n) {
      const o = n.proxies.indexOf(i);
      o > -1 && n.proxies.splice(o, 1);
      const a = i.cells.indexOf(n);
      a > -1 && i.cells.splice(a, 1), n.proxies.length === 0 && (this._hashGridCellPool.return(n), this.sparseHashGrid.delete(s));
    }
  }
  track(t) {
    const e = this._buildProxy(t);
    this.objectToProxy.set(t, e);
    for (let i = e.leftX; i <= e.rightX; i++)
      for (let s = e.topY; s <= e.bottomY; s++)
        this._insert(i, s, e);
  }
  untrack(t) {
    const e = this.objectToProxy.get(t);
    e && (e.clear(), this.objectToProxy.delete(t));
  }
  update(t) {
    let e = 0;
    for (const i of t) {
      const s = this.objectToProxy.get(i);
      if (s && s.hasChanged()) {
        for (let n = s.leftX; n <= s.rightX; n++)
          for (let o = s.topY; o <= s.bottomY; o++)
            this._remove(n, o, s);
        s.update();
        for (let n = s.leftX; n <= s.rightX; n++)
          for (let o = s.topY; o <= s.bottomY; o++)
            this._insert(n, o, s);
        e++;
      }
    }
    return e;
  }
  debug(t, e) {
    const i = T.White;
    for (const s of this.sparseHashGrid.values())
      t.debug.drawRect(s.x * this.gridSize, s.y * this.gridSize, this.gridSize, this.gridSize, { color: i, lineWidth: 2 });
  }
}
class ja extends Mr {
  constructor(t, e) {
    var i, s, n;
    super(t, e), this.collider = t, this.id = -1, this.hasZeroBounds = !1, this.cells = [], this.gridSize = e;
    const o = t.bounds;
    this.hasZeroBounds = o.hasZeroDimensions(), this.leftX = Math.floor(o.left / this.gridSize), this.rightX = Math.floor(o.right / this.gridSize), this.bottomY = Math.floor(o.bottom / this.gridSize), this.topY = Math.floor(o.top / this.gridSize), this.owner = t.owner, this.body = (i = this.owner) == null ? void 0 : i.get(U), this.collisionType = (n = (s = this.body) == null ? void 0 : s.collisionType) != null ? n : E.PreventCollision;
  }
  /**
   * Updates the hashed bounds coordinates
   */
  update() {
    var t, e, i;
    super.update(), this.body = (t = this.owner) == null ? void 0 : t.get(U), this.collisionType = (i = (e = this.body) == null ? void 0 : e.collisionType) != null ? i : E.PreventCollision, this.hasZeroBounds = this.collider.localBounds.hasZeroDimensions();
  }
}
class Xs {
  constructor(t) {
    this._pairs = /* @__PURE__ */ new Set(), this._nonPairs = /* @__PURE__ */ new Set(), this._pairPool = new us(
      () => new xt({ id: Pe("collider", 0) }, { id: Pe("collider", 0) }),
      (e) => (e.colliderA = null, e.colliderB = null, e),
      200
    ), this.gridSize = t.size, this.hashGrid = new Fr({
      size: this.gridSize,
      proxyFactory: (e, i) => new ja(e, i)
    }), this._pairPool.disableWarnings = !0;
  }
  getColliders() {
    return Array.from(this.hashGrid.objectToProxy.keys());
  }
  query(t) {
    return this.hashGrid.query(t);
  }
  rayCast(t, e) {
    var i, s, n;
    const o = [], a = (i = e == null ? void 0 : e.maxDistance) != null ? i : 1 / 0, h = e == null ? void 0 : e.collisionGroup, l = h ? h.category : (s = e == null ? void 0 : e.collisionMask) != null ? s : Ee.All.category, c = (n = e == null ? void 0 : e.searchAllColliders) != null ? n : !1, d = t.dir.normalize(), u = d.y / d.x, _ = d.x / d.y, p = Math.sqrt(1 + u * u) * this.gridSize, g = Math.sqrt(1 + _ * _) * this.gridSize, x = t.pos.x / this.gridSize, m = t.pos.y / this.gridSize, f = w(1, 1);
    let b = ~~x, C = ~~m, S = 0, I = 0;
    d.x < 0 ? (f.x = -1, S = (x - b) * p) : (f.x = 1, S = (b + 1 - x) * p), d.y < 0 ? (f.y = -1, I = (m - C) * g) : (f.y = 1, I = (C + 1 - m) * g);
    const y = /* @__PURE__ */ new Set();
    let k = !1, L = 9999;
    for (; !k && L > 0 && (L--, !!this.hashGrid.bounds.contains(w(b * this.gridSize, C * this.gridSize))); ) {
      const O = Yt.calculateHashKey(b, C), Q = this.hashGrid.sparseHashGrid.get(O);
      if (Q) {
        const st = [];
        for (let $ = 0; $ < Q.proxies.length; $++) {
          const H = Q.proxies[$];
          if (!y.has(H.collider.id.value)) {
            if (y.add(H.collider.id.value), H.body) {
              if (e != null && e.ignoreCollisionGroupAll && H.body.group === Ee.All)
                continue;
              const lt = (l & H.body.group.category) !== 0;
              if (H.body.group && !lt)
                continue;
            }
            const rt = H.collider.rayCast(t, a);
            rt && st.push(rt);
          }
        }
        st.sort(($, H) => $.distance - H.distance);
        for (let $ = 0; $ < st.length; $++) {
          const H = st[$];
          if (e != null && e.filter) {
            if (e.filter(H) && (o.push(H), !c)) {
              k = !0;
              break;
            }
          } else if (o.push(H), !c) {
            k = !0;
            break;
          }
        }
      }
      S < I ? (b += f.x, S += p) : (C += f.y, I += g);
    }
    return o.sort((O, Q) => O.distance - Q.distance), !c && o.length ? [o[0]] : o;
  }
  /**
   * Adds the collider to the internal data structure for collision tracking
   * @param target
   */
  track(t) {
    let e = [t];
    if (t instanceof ht) {
      const i = t.getColliders();
      for (const s of i)
        s.owner = t.owner;
      e = i;
    }
    for (const i of e)
      this.hashGrid.track(i);
  }
  /**
   * Removes a collider from the internal data structure for tracking collisions
   * @param target
   */
  untrack(t) {
    let e = [t];
    t instanceof ht && (e = t.getColliders());
    for (const i of e)
      this.hashGrid.untrack(i);
  }
  _canCollide(t, e) {
    return !(t.collider.id === e.collider.id || t.owner && e.owner && t.owner.id === e.owner.id || t.hasZeroBounds || e.hasZeroBounds || t.body && e.body && !t.body.group.canCollide(e.body.group) || t.collisionType === E.Fixed && e.collisionType === E.Fixed || t.collisionType === E.PreventCollision || e.collisionType === E.PreventCollision || !t.owner.isActive || !e.owner.isActive);
  }
  /**
   * Runs the broadphase sweep over tracked colliders and returns possible collision pairs
   * @param targets
   * @param elapsed
   */
  broadphase(t, e) {
    const i = [];
    this._pairs.clear(), this._nonPairs.clear();
    let s = 0;
    for (const n of this.hashGrid.objectToProxy.values())
      if (n.id = s++, !(!n.owner.isActive || n.collisionType === E.PreventCollision))
        for (let o = 0; o < n.cells.length; o++) {
          const a = n.cells[o];
          for (let h = 0; h < a.proxies.length; h++) {
            const l = a.proxies[h];
            if (l.id === n.id)
              continue;
            const c = xt.calculatePairHash(n.collider.id, l.collider.id);
            if (!this._nonPairs.has(c))
              if (!this._pairs.has(c) && this._canCollide(n, l) && n.object.bounds.overlaps(l.object.bounds)) {
                const d = this._pairPool.get();
                d.colliderA = n.collider, d.colliderB = l.collider, d.id = c, this._pairs.add(c), i.push(d);
              } else
                this._nonPairs.add(c);
          }
        }
    return i;
  }
  /**
   * Runs a fine grain pass on collision pairs and does geometry intersection tests producing any contacts
   * @param pairs
   * @param stats
   */
  narrowphase(t, e) {
    const i = [];
    for (let s = 0; s < t.length; s++) {
      const n = t[s].collide();
      for (let o = 0; o < n.length; o++) {
        const a = n[o];
        i.push(a), e && e.physics.contacts.set(a.id, a);
      }
    }
    return this._pairPool.done(), e && (e.physics.collisions += i.length), i;
  }
  /**
   * Perform data structure maintenance, returns number of colliders updated
   */
  update(t, e) {
    return this.hashGrid.update(t);
  }
  /**
   * Draws the internal data structure
   * @param ex
   * @param elapsed
   */
  debug(t, e) {
    this.hashGrid.debug(t, e);
  }
}
class Oe {
  constructor(t, e) {
    this.bounds = t, this.options = e, this._defaultOptions = {
      maxDepth: 10,
      capacity: 10,
      level: 0
    }, this.items = [], this._isDivided = !1, this.topLeft = null, this.topRight = null, this.bottomLeft = null, this.bottomRight = null, this.options = { ...this._defaultOptions, ...e }, this.halfWidth = t.width / 2, this.halfHeight = t.height / 2;
  }
  /**
   * Splits the quad tree one level deeper
   */
  _split() {
    this._isDivided = !0;
    const t = {
      maxDepth: this.options.maxDepth,
      capacity: this.options.capacity,
      level: this.options.level + 1
    };
    this.topLeft = new Oe(
      new F({
        left: this.bounds.left,
        top: this.bounds.top,
        right: this.bounds.left + this.halfWidth,
        bottom: this.bounds.top + this.halfHeight
      }),
      t
    ), this.topRight = new Oe(
      new F({
        left: this.bounds.left + this.halfWidth,
        top: this.bounds.top,
        right: this.bounds.right,
        bottom: this.bounds.top + this.halfHeight
      }),
      t
    ), this.bottomLeft = new Oe(
      new F({
        left: this.bounds.left,
        top: this.bounds.top + this.halfHeight,
        right: this.bounds.left + this.halfWidth,
        bottom: this.bounds.bottom
      }),
      t
    ), this.bottomRight = new Oe(
      new F({
        left: this.bounds.left + this.halfWidth,
        top: this.bounds.top + this.halfHeight,
        right: this.bounds.right,
        bottom: this.bounds.bottom
      }),
      t
    );
  }
  _insertIntoSubNodes(t) {
    var e, i, s, n;
    (e = this.topLeft) != null && e.bounds.overlaps(t.bounds) && this.topLeft.insert(t), (i = this.topRight) != null && i.bounds.overlaps(t.bounds) && this.topRight.insert(t), (s = this.bottomLeft) != null && s.bounds.overlaps(t.bounds) && this.bottomLeft.insert(t), (n = this.bottomRight) != null && n.bounds.overlaps(t.bounds) && this.bottomRight.insert(t);
  }
  /**
   * Insert an item to be tracked in the QuadTree
   * @param item
   */
  insert(t) {
    if (this._isDivided) {
      this._insertIntoSubNodes(t);
      return;
    }
    if (this.items.push(t), this.items.length > this.options.capacity && this.options.level < this.options.maxDepth) {
      this._isDivided || this._split();
      for (const e of this.items)
        this._insertIntoSubNodes(e);
      this.items.length = 0;
    }
  }
  /**
   * Remove a tracked item in the QuadTree
   * @param item
   */
  remove(t) {
    var e, i, s, n;
    if (this.bounds.overlaps(t.bounds)) {
      if (!this._isDivided) {
        const o = this.items.indexOf(t);
        o > -1 && this.items.splice(o, 1);
        return;
      }
      (e = this.topLeft) != null && e.bounds.overlaps(t.bounds) && this.topLeft.remove(t), (i = this.topRight) != null && i.bounds.overlaps(t.bounds) && this.topRight.remove(t), (s = this.bottomLeft) != null && s.bounds.overlaps(t.bounds) && this.bottomLeft.remove(t), (n = this.bottomRight) != null && n.bounds.overlaps(t.bounds) && this.bottomRight.remove(t);
    }
  }
  /**
   * Query the structure for all objects that intersect the bounding box
   * @param boundingBox
   * @returns items
   */
  query(t) {
    let e = this.items;
    return this._isDivided && (this.topLeft.bounds.overlaps(t) && (e = e.concat(this.topLeft.query(t))), this.topRight.bounds.overlaps(t) && (e = e.concat(this.topRight.query(t))), this.bottomLeft.bounds.overlaps(t) && (e = e.concat(this.bottomLeft.query(t))), this.bottomRight.bounds.overlaps(t) && (e = e.concat(this.bottomRight.query(t)))), e = e.filter((i, s) => e.indexOf(i) >= s), e;
  }
  clear() {
    this.items = [], this._isDivided = !1, this.topLeft = null, this.topRight = null, this.bottomLeft = null, this.bottomRight = null;
  }
  getAllItems() {
    let t = this.items;
    return this._isDivided && (t = t.concat(this.topLeft.getAllItems()), t = t.concat(this.topRight.getAllItems()), t = t.concat(this.bottomLeft.getAllItems()), t = t.concat(this.bottomRight.getAllItems())), t = t.filter((e, i) => t.indexOf(e) >= i), t;
  }
  getTreeDepth() {
    return this._isDivided ? 1 + Math.max(this.topLeft.getTreeDepth(), this.topRight.getTreeDepth(), this.bottomLeft.getTreeDepth(), this.bottomRight.getTreeDepth()) : 0;
  }
  debug(t) {
    this.bounds.debug(t, { color: T.Yellow }), this._isDivided && (this.topLeft.bounds.debug(t, { color: T.Yellow }), this.topRight.bounds.debug(t, { color: T.Yellow }), this.bottomLeft.bounds.debug(t, { color: T.Yellow }), this.bottomRight.bounds.debug(t, { color: T.Yellow }));
  }
}
class $s {
  constructor(t) {
    this.config = t, this.directionMap = /* @__PURE__ */ new Map(), this.distanceMap = /* @__PURE__ */ new Map(), this._compositeContactsIds = /* @__PURE__ */ new Set();
  }
  solve(t) {
    this.preSolve(t), t = t.filter((i) => !i.isCanceled());
    let e;
    switch (this.config.contactSolveBias) {
      case _e.HorizontalFirst: {
        e = ir;
        break;
      }
      case _e.VerticalFirst: {
        e = er;
        break;
      }
      default:
        e = sr;
    }
    t.sort((i, s) => {
      const n = this.directionMap.get(i.id), o = this.directionMap.get(s.id), a = this.distanceMap.get(i.id), h = this.distanceMap.get(s.id);
      return e[n] - e[o] || a - h;
    });
    for (const i of t)
      this.solvePosition(i), this.solveVelocity(i);
    return this.postSolve(t), t;
  }
  preSolve(t) {
    for (let i = 0; i < t.length; i++) {
      const s = t[i], n = s.id.indexOf("|");
      if (n > 0) {
        const l = s.id.substring(n + 1);
        if (this._compositeContactsIds.has(l)) {
          s.cancel();
          continue;
        }
        this._compositeContactsIds.add(l);
      }
      if (Math.abs(s.mtv.x) < 1e-4 && Math.abs(s.mtv.y) < 1e-4) {
        s.cancel();
        continue;
      }
      const o = G.fromDirection(s.mtv), a = s.mtv.negate(), h = Math.abs(s.info.separation);
      this.distanceMap.set(s.id, h), this.directionMap.set(s.id, o === G.Left || o === G.Right ? "horizontal" : "vertical"), s.colliderA.events.emit("precollision", new Ie(s.colliderA, s.colliderB, o, a, s)), s.colliderB.events.emit(
        "precollision",
        new Ie(s.colliderB, s.colliderA, G.getOpposite(o), a.negate(), s)
      );
    }
    this._compositeContactsIds.clear();
  }
  postSolve(t) {
    var e, i;
    for (let s = 0; s < t.length; s++) {
      const n = t[s];
      if (n.isCanceled())
        continue;
      const o = n.colliderA, a = n.colliderB, h = (e = o.owner) == null ? void 0 : e.get(U), l = (i = a.owner) == null ? void 0 : i.get(U);
      if (h && l && (h.collisionType === E.Passive || l.collisionType === E.Passive))
        continue;
      const c = G.fromDirection(n.mtv), d = n.mtv.negate();
      n.colliderA.events.emit("postcollision", new Re(n.colliderA, n.colliderB, c, d, n)), n.colliderB.events.emit(
        "postcollision",
        new Re(n.colliderB, n.colliderA, G.getOpposite(c), d.negate(), n)
      );
    }
  }
  solvePosition(t) {
    var e, i;
    if (!t.colliderA.bounds.overlaps(t.colliderB.bounds, 1e-4)) {
      t.cancel();
      return;
    }
    if (Math.abs(t.mtv.x) < 1e-4 && Math.abs(t.mtv.y) < 1e-4) {
      t.cancel();
      return;
    }
    let n = t.mtv;
    const o = t.colliderA, a = t.colliderB, h = (e = o.owner) == null ? void 0 : e.get(U), l = (i = a.owner) == null ? void 0 : i.get(U);
    if (h && l) {
      if (h.collisionType === E.Passive || l.collisionType === E.Passive)
        return;
      h.collisionType === E.Active && l.collisionType === E.Active && (n = n.scale(0.5)), h.collisionType === E.Active && (h.globalPos.x -= n.x, h.globalPos.y -= n.y, o.update(h.transform.get())), l.collisionType === E.Active && (l.globalPos.x += n.x, l.globalPos.y += n.y, a.update(l.transform.get()));
    }
  }
  solveVelocity(t) {
    var e, i;
    if (t.isCanceled())
      return;
    const s = t.colliderA, n = t.colliderB, o = (e = s.owner) == null ? void 0 : e.get(U), a = (i = n.owner) == null ? void 0 : i.get(U);
    if (o && a) {
      if (o.collisionType === E.Passive || a.collisionType === E.Passive)
        return;
      const h = t.normal, l = h.negate();
      if (o.collisionType === E.Active && o.vel.normalize().dot(l) < 0) {
        const c = h.scale(h.dot(o.vel.negate()));
        o.vel = o.vel.add(c);
      }
      if (a.collisionType === E.Active && a.vel.normalize().dot(h) < 0) {
        const c = l.scale(l.dot(a.vel.negate()));
        a.vel = a.vel.add(c);
      }
    }
  }
}
class Qa {
  constructor(t, e, i) {
    this.point = t, this.local = e, this.contact = i, this.normalImpulse = 0, this.tangentImpulse = 0, this.normalMass = 0, this.tangentMass = 0, this.aToContact = new v(0, 0), this.bToContact = new v(0, 0), this.originalVelocityAndRestitution = 0, this.update();
  }
  /**
   * Updates the contact information
   */
  update() {
    const t = this.contact.bodyA, e = this.contact.colliderA, i = this.contact.bodyB, s = this.contact.colliderB;
    if (t && i) {
      const n = this.contact.normal, o = this.contact.tangent;
      this.aToContact = this.point.sub(e.center), this.bToContact = this.point.sub(s.center);
      const a = this.aToContact.cross(n), h = this.bToContact.cross(n);
      this.normalMass = t.inverseMass + i.inverseMass + t.inverseInertia * a * a + i.inverseInertia * h * h;
      const l = this.aToContact.cross(o), c = this.bToContact.cross(o);
      this.tangentMass = t.inverseMass + i.inverseMass + t.inverseInertia * l * l + i.inverseInertia * c * c;
    }
    return this;
  }
  /**
   * Returns the relative velocity between bodyA and bodyB
   */
  getRelativeVelocity() {
    const t = this.contact.bodyA, e = this.contact.bodyB;
    if (t && e) {
      const i = t.vel.add(v.cross(t.angularVelocity, this.aToContact));
      return e.vel.add(v.cross(e.angularVelocity, this.bToContact)).sub(i);
    }
    return v.Zero;
  }
}
class Ys {
  constructor(t) {
    this.config = t, this.directionMap = /* @__PURE__ */ new Map(), this.distanceMap = /* @__PURE__ */ new Map(), this.lastFrameContacts = /* @__PURE__ */ new Map(), this.idToContactConstraint = /* @__PURE__ */ new Map();
  }
  getContactConstraints(t) {
    var e;
    return (e = this.idToContactConstraint.get(t)) != null ? e : [];
  }
  solve(t) {
    this.preSolve(t), t = t.filter((i) => !i.isCanceled());
    let e;
    switch (this.config.contactSolveBias) {
      case _e.HorizontalFirst: {
        e = ir;
        break;
      }
      case _e.VerticalFirst: {
        e = er;
        break;
      }
      default:
        e = sr;
    }
    return t.sort((i, s) => {
      const n = this.directionMap.get(i.id), o = this.directionMap.get(s.id), a = this.distanceMap.get(i.id), h = this.distanceMap.get(s.id);
      return e[n] - e[o] || a - h;
    }), this.solveVelocity(t), this.solvePosition(t), this.postSolve(t), t;
  }
  preSolve(t) {
    var e, i, s, n;
    for (let h = 0; h < t.length; h++) {
      const l = t[h];
      if (Math.abs(l.mtv.x) < 1e-4 && Math.abs(l.mtv.y) < 1e-4) {
        l.cancel();
        continue;
      }
      const c = G.fromDirection(l.mtv), d = Math.abs(((e = l == null ? void 0 : l.info) == null ? void 0 : e.separation) || 0);
      this.distanceMap.set(l.id, d), this.directionMap.set(l.id, c === G.Left || c === G.Right ? "horizontal" : "vertical"), l.colliderA.events.emit(
        "precollision",
        new Ie(l.colliderA, l.colliderB, c, l.mtv, l)
      ), l.colliderA.events.emit(
        "beforecollisionresolve",
        new ji(l.colliderA, l.colliderB, c, l.mtv, l)
      ), l.colliderB.events.emit(
        "precollision",
        new Ie(l.colliderB, l.colliderA, G.getOpposite(c), l.mtv.negate(), l)
      ), l.colliderB.events.emit(
        "beforecollisionresolve",
        new ji(l.colliderB, l.colliderA, G.getOpposite(c), l.mtv.negate(), l)
      );
    }
    const a = Array.from(this.idToContactConstraint.keys());
    for (let h = 0; h < t.length; h++) {
      const l = t[h], c = a.indexOf(l.id);
      c > -1 && a.splice(c, 1);
      const d = (i = this.idToContactConstraint.get(l.id)) != null ? i : [];
      let u = 0;
      const _ = l.bodyA, p = l.colliderA, g = l.bodyB, x = l.colliderB;
      if (_ && g && (!_.isSleeping || !g.isSleeping))
        for (let m = 0; m < l.points.length; m++) {
          const f = l.points[m], b = l.normal, C = l.tangent, S = f.sub(p.center), I = f.sub(x.center), y = S.cross(b), k = I.cross(b), L = _.inverseMass + g.inverseMass + _.inverseInertia * y * y + g.inverseInertia * k * k, O = S.cross(C), Q = I.cross(C), st = _.inverseMass + g.inverseMass + _.inverseInertia * O * O + g.inverseInertia * Q * Q;
          d[u] && ((n = (s = d[u]) == null ? void 0 : s.point) == null ? void 0 : n.squareDistance(f)) < 4 ? (d[u].point = f, d[u].local = l.localPoints[u]) : d[u] = new Qa(f, l.localPoints[u], l), d[u].aToContact = S, d[u].bToContact = I, d[u].normalMass = 1 / L, d[u].tangentMass = 1 / st;
          const $ = _.bounciness > g.bounciness ? _.bounciness : g.bounciness, H = l.normal.dot(d[u].getRelativeVelocity());
          d[u].originalVelocityAndRestitution = 0, H < -0.1 && (d[u].originalVelocityAndRestitution = -$ * H), u++;
        }
      this.idToContactConstraint.set(l.id, d);
    }
    for (const h of a)
      this.idToContactConstraint.delete(h);
    if (this.config.warmStart)
      this.warmStart(t);
    else
      for (let h = 0; h < t.length; h++) {
        const l = t[h], c = this.getContactConstraints(l.id);
        for (const d of c)
          d.normalImpulse = 0, d.tangentImpulse = 0;
      }
  }
  postSolve(t) {
    for (let e = 0; e < t.length; e++) {
      const i = t[e], s = i.bodyA, n = i.bodyB;
      if (s && n && (s.collisionType === E.Passive || n.collisionType === E.Passive))
        continue;
      const o = G.fromDirection(i.mtv);
      i.colliderA.events.emit(
        "postcollision",
        new Re(i.colliderA, i.colliderB, o, i.mtv, i)
      ), i.colliderA.events.emit(
        "aftercollisionresolve",
        new Qi(i.colliderA, i.colliderB, o, i.mtv, i)
      ), i.colliderB.events.emit(
        "postcollision",
        new Re(i.colliderB, i.colliderA, G.getOpposite(o), i.mtv.negate(), i)
      ), i.colliderB.events.emit(
        "aftercollisionresolve",
        new Qi(i.colliderB, i.colliderA, G.getOpposite(o), i.mtv.negate(), i)
      );
    }
    this.lastFrameContacts.clear();
    for (let e = 0; e < t.length; e++) {
      const i = t[e];
      this.lastFrameContacts.set(i.id, i);
    }
  }
  /**
   * Warm up body's based on previous frame contact points
   * @param contacts
   */
  warmStart(t) {
    var e;
    for (let i = 0; i < t.length; i++) {
      const s = t[i], n = s.bodyA, o = s.bodyB;
      if (!(n.isSleeping && o.isSleeping) && n && o) {
        const a = (e = this.idToContactConstraint.get(s.id)) != null ? e : [];
        for (const h of a)
          if (this.config.warmStart) {
            const l = s.normal.scale(h.normalImpulse), c = s.tangent.scale(h.tangentImpulse), d = l.add(c);
            n.applyImpulse(h.point, d.negate()), o.applyImpulse(h.point, d);
          } else
            h.normalImpulse = 0, h.tangentImpulse = 0;
      }
    }
  }
  /**
   * Iteratively solve the position overlap constraint
   * @param contacts
   */
  solvePosition(t) {
    var e;
    for (let i = 0; i < this.config.positionIterations; i++)
      for (let s = 0; s < t.length; s++) {
        const n = t[s], o = n.bodyA, a = n.bodyB;
        if (!(o.isSleeping && a.isSleeping) && o && a) {
          if (o.collisionType === E.Passive || a.collisionType === E.Passive)
            continue;
          const h = (e = this.idToContactConstraint.get(n.id)) != null ? e : [];
          for (const l of h) {
            const c = n.normal, d = Ot.FindContactSeparation(n, l.local), u = this.config.steeringFactor, _ = -5, p = this.config.slop, g = D(u * (d + p), _, 0), x = c.scale(-g * l.normalMass);
            if (o.collisionType === E.Active) {
              const m = x.negate().scale(o.inverseMass);
              o.limitDegreeOfFreedom.includes(le.X) && (m.x = 0), o.limitDegreeOfFreedom.includes(le.Y) && (m.y = 0), o.globalPos = o.globalPos.add(m), o.limitDegreeOfFreedom.includes(le.Rotation) || (o.rotation -= l.aToContact.cross(x) * o.inverseInertia);
            }
            if (a.collisionType === E.Active) {
              const m = x.scale(a.inverseMass);
              a.limitDegreeOfFreedom.includes(le.X) && (m.x = 0), a.limitDegreeOfFreedom.includes(le.Y) && (m.y = 0), a.globalPos = a.globalPos.add(m), a.limitDegreeOfFreedom.includes(le.Rotation) || (a.rotation += l.bToContact.cross(x) * a.inverseInertia);
            }
          }
        }
      }
  }
  solveVelocity(t) {
    var e;
    for (let i = 0; i < this.config.velocityIterations; i++)
      for (let s = 0; s < t.length; s++) {
        const n = t[s], o = n.bodyA, a = n.bodyB;
        if (!(o.isSleeping && a.isSleeping) && o && a) {
          if (o.collisionType === E.Passive || a.collisionType === E.Passive)
            continue;
          const h = Math.min(o.friction, a.friction), l = (e = this.idToContactConstraint.get(n.id)) != null ? e : [];
          for (const c of l) {
            let _ = -c.getRelativeVelocity().dot(n.tangent) * c.tangentMass;
            const p = h * c.normalImpulse, g = D(c.tangentImpulse + _, -p, p);
            _ = g - c.tangentImpulse, c.tangentImpulse = g;
            const x = n.tangent.scale(_);
            o.applyImpulse(c.point, x.negate()), a.applyImpulse(c.point, x);
          }
          for (const c of l) {
            const u = c.getRelativeVelocity().dot(n.normal);
            let _ = -c.normalMass * (u - c.originalVelocityAndRestitution);
            const p = Math.max(c.normalImpulse + _, 0);
            _ = p - c.normalImpulse, c.normalImpulse = p;
            const g = n.normal.scale(_);
            o.applyImpulse(c.point, g.negate()), a.applyImpulse(c.point, g);
          }
        }
      }
  }
}
class ys extends Ft {
  constructor(t, e) {
    super(), this.world = t, this.physics = e, this.systemType = Mt.Update, this._physicsConfigDirty = !1, this.query = this._createPhysicsQuery(t, e), e.$configUpdate.subscribe(() => {
      this._physicsConfigDirty = !0;
    });
  }
  _createPhysicsQuery(t, e) {
    return t.query({
      components: {
        all: [P, N]
      },
      tags: {
        not: e.config.integration.onScreenOnly ? ["ex.offscreen", "ex.is_sleeping"] : ["ex.is_sleeping"]
      }
    });
  }
  update(t) {
    let e, i;
    const s = this.query.entities, o = this.physics.config.substep;
    for (let a = 0; a < s.length; a++) {
      if (e = s[a].get(P), i = s[a].get(N), i.integration.onScreenOnly && s[a].hasTag("ex.offscreen"))
        continue;
      const h = s[a].get(U);
      if (this._physicsConfigDirty && h && h.updatePhysicsConfig(this.physics.config.bodies), h != null && h.isSleeping)
        continue;
      const l = i.acc.clone();
      (h == null ? void 0 : h.collisionType) === E.Active && (h != null && h.useGravity) && l.addEqual(this.physics.config.gravity), s[a].parent || this.captureOldTransformWithChildren(s[a]), Ar.integrate(e, i, l, t / o);
    }
    this._physicsConfigDirty && (this._physicsConfigDirty = !1, this.query = this._createPhysicsQuery(this.world, this.physics));
  }
  captureOldTransformWithChildren(t) {
    var e;
    (e = t.get(U)) == null || e.captureOldTransform();
    for (let i = 0; i < t.children.length; i++)
      this.captureOldTransformWithChildren(t.children[i]);
  }
}
ys.priority = Kt.Higher;
class Ja {
  constructor(t) {
    this.config = t, this.bodies = [], this.contacts = [], this.isSleeping = !1;
  }
  wake() {
    this.isSleeping = !1;
    for (const t of this.bodies)
      t.wake();
  }
  sleep() {
    this.isSleeping = !0;
    for (const t of this.bodies)
      t.sleep();
  }
  updateSleepState(t) {
    let e = !1, i = !0;
    for (const s of this.bodies)
      s.updateMotion(t), s.canFallAsleep || i && (i = !1), s.canWakeUp && (e || (e = !0));
    if (e)
      this.wake();
    else if (i) {
      let s = 1 / 0;
      for (const n of this.bodies)
        s = Math.min(s, n.sleepTime);
      s > this.config.sleepTimeThreshold && this.sleep();
    }
  }
}
function Ka(r, t, e) {
  const i = /* @__PURE__ */ new Map();
  function s(h) {
    return i.has(h) || i.set(h, h), i.get(h) !== h && i.set(h, s(i.get(h))), i.get(h);
  }
  function n(h, l) {
    const c = s(h), d = s(l);
    c !== d && i.set(c, d);
  }
  const o = /* @__PURE__ */ new Map();
  for (const h of e)
    h.bodyA.collisionType === E.Active && h.bodyB.collisionType === E.Active && n(h.bodyA, h.bodyB), o.has(h.bodyA) || o.set(h.bodyA, []), o.has(h.bodyB) || o.set(h.bodyB, []), h.bodyA.collisionType === E.Active && o.get(h.bodyA).push(h), h.bodyB.collisionType === E.Active && o.get(h.bodyB).push(h);
  const a = /* @__PURE__ */ new Map();
  for (const h of t) {
    if (h.collisionType !== E.Active)
      continue;
    const l = s(h);
    a.has(l) || a.set(l, []), a.get(l).push(h);
  }
  return Array.from(a.values()).map((h) => {
    const l = new Ja(r);
    return l.bodies = h, h.forEach((c) => c.island = l), l.contacts = Array.from(new Set(h.flatMap((c) => o.get(c)))), l;
  });
}
class Cs extends Ft {
  constructor(t, e) {
    super(), this._physics = e, this.systemType = Mt.Update, this._configDirty = !1, this._lastFrameContacts = /* @__PURE__ */ new Map(), this._currentFrameContacts = /* @__PURE__ */ new Map(), this._bodies = [], this._arcadeSolver = new $s(e.config.arcade), this._realisticSolver = new Ys(e.config.realistic), this._physics.$configUpdate.subscribe(() => this._configDirty = !0), this._trackCollider = (i) => this._processor.track(i), this._untrackCollider = (i) => this._processor.untrack(i), this.query = t.query([P, it]), this.query.entityAdded$.subscribe((i) => {
      const s = i.get(it);
      s.$colliderAdded.subscribe(this._trackCollider), s.$colliderRemoved.subscribe(this._untrackCollider);
      const n = s.get();
      n && this._processor.track(n);
    }), this.query.entityRemoved$.subscribe((i) => {
      const s = i.get(it), n = s.get();
      s && n && this._processor.untrack(n);
    }), this._motionSystem = t.get(ys), this.bodyQuery = t.query([U]), this.bodyQuery.entityAdded$.subscribe((i) => {
      this._bodies.push(i.get(U));
    }), this.bodyQuery.entityRemoved$.subscribe((i) => {
      const s = i.get(U), n = this._bodies.indexOf(s);
      n > -1 && this._bodies.splice(n, 1);
    });
  }
  get _processor() {
    return this._physics.collisionProcessor;
  }
  initialize(t, e) {
    this._engine = e.engine;
  }
  update(t) {
    var e, i, s, n;
    if (!this._physics.config.enabled)
      return;
    let o = [];
    for (let d = 0; d < this.query.entities.length; d++) {
      const _ = this.query.entities[d].get(it), p = _ == null ? void 0 : _.get();
      if (_ && ((e = _.owner) != null && e.isActive) && p)
        if (_.update(), p instanceof ht) {
          const g = p.getColliders();
          p.compositeStrategy || (p.compositeStrategy = this._physics.config.colliders.compositeStrategy), o = o.concat(g);
        } else
          o.push(p);
    }
    this._processor.update(o, t);
    let a = this._processor.broadphase(o, t);
    this._currentFrameContacts.clear();
    let h = [];
    const l = this.getSolver(), c = this._physics.config.substep;
    for (let d = 0; d < c; d++)
      if (d > 0 && this._motionSystem.update(t), h.length && (a = h.map((u) => new xt(u.colliderA, u.colliderB))), a.length) {
        if (h = this._processor.narrowphase(a, (n = (s = (i = this._engine) == null ? void 0 : i.debug) == null ? void 0 : s.stats) == null ? void 0 : n.currFrame), this._physics.config.solver === wi.Realistic) {
          const u = Ka(this._physics.config.bodies, this._bodies, h);
          for (const _ of u)
            _.updateSleepState(t / c);
        }
        h = l.solve(h, t / c);
        for (const u of h) {
          if (u.isCanceled())
            continue;
          const _ = u.id.indexOf("|");
          if (_ > 0) {
            const p = u.id.substring(_ + 1);
            this._currentFrameContacts.set(p, u);
          } else
            this._currentFrameContacts.set(u.id, u);
        }
      }
    this.runContactStartEnd(), this._lastFrameContacts.clear(), this._lastFrameContacts = new Map(this._currentFrameContacts);
    for (const d of this.query.entities) {
      const u = d.get(it);
      u && u.processColliderRemoval();
    }
  }
  postupdate() {
    Ve.SeparationPool.done();
  }
  getSolver() {
    return this._configDirty && (this._configDirty = !1, this._arcadeSolver = new $s(this._physics.config.arcade), this._realisticSolver = new Ys(this._physics.config.realistic)), this._physics.config.solver === wi.Realistic ? this._realisticSolver : this._arcadeSolver;
  }
  debug(t) {
    this._processor.debug(t, 0);
  }
  runContactStartEnd() {
    for (const [t, e] of this._currentFrameContacts)
      if (!this._lastFrameContacts.has(t)) {
        const i = e.colliderA, s = e.colliderB, n = G.fromDirection(e.mtv), o = G.getOpposite(n);
        i.events.emit("collisionstart", new pi(i, s, n, e)), i.events.emit("contactstart", new Yi(i, s, n, e)), s.events.emit("collisionstart", new pi(s, i, o, e)), s.events.emit("contactstart", new Yi(s, i, o, e));
      }
    for (const [t, e] of this._lastFrameContacts)
      if (!this._currentFrameContacts.has(t)) {
        const i = e.colliderA, s = e.colliderB;
        e.bodyA.isSleeping = !1, e.bodyB.isSleeping = !1;
        const n = G.fromDirection(e.mtv), o = G.getOpposite(n);
        i.events.emit("collisionend", new mi(i, s, n, e)), i.events.emit("contactend", new Zi(i, s, n, e)), s.events.emit("collisionend", new mi(s, i, o, e)), s.events.emit("contactend", new Zi(s, i, o, e));
      }
  }
}
Cs.priority = Kt.Higher;
class th {
  constructor(t) {
    this.$configUpdate = new mt(), this._configDirty = !1, this.config = t, this.$configUpdate.subscribe((e) => {
      this._configDirty = !0, U.updateDefaultPhysicsConfig(e.bodies);
    }), this._config.spatialPartition === bi.SparseHashGrid ? this._collisionProcessor = new Xs(this._config.sparseHashGrid) : this._collisionProcessor = new Ki(this._config);
  }
  get config() {
    return So(this._config, (t) => {
      this.$configUpdate.notifyAll(t);
    });
  }
  set config(t) {
    this._config = t, this.$configUpdate.notifyAll(t);
  }
  /**
   * Spatial data structure for locating potential collision pairs and ray casts
   */
  get collisionProcessor() {
    if (this._configDirty) {
      this._configDirty = !1;
      const t = this._collisionProcessor.getColliders();
      this._config.spatialPartition === bi.SparseHashGrid ? this._collisionProcessor = new Xs(this._config.sparseHashGrid) : this._collisionProcessor = new Ki(this._config);
      for (const e of t)
        this._collisionProcessor.track(e);
    }
    return this._collisionProcessor;
  }
  /**
   * Raycast into the scene's physics world
   * @param ray
   * @param options
   */
  rayCast(t, e) {
    return this.collisionProcessor.rayCast(t, e);
  }
  query(t) {
    return this._collisionProcessor.query(t);
  }
}
var _i = /* @__PURE__ */ ((r) => (r.Fixed = "Fixed", r.FitContainerAndFill = "FitContainerAndFill", r.FitScreenAndFill = "FitScreenAndFill", r.FitContainerAndZoom = "FitContainerAndZoom", r.FitScreenAndZoom = "FitScreenAndZoom", r.FitScreen = "FitScreen", r.FillScreen = "FillScreen", r.FitContainer = "FitContainer", r.FillContainer = "FillContainer", r))(_i || {});
class Zs {
  /* istanbul ignore next */
  static get SVGA() {
    return { width: 800, height: 600 };
  }
  /* istanbul ignore next */
  static get Standard() {
    return { width: 1920, height: 1080 };
  }
  /* istanbul ignore next */
  static get Atari2600() {
    return { width: 160, height: 192 };
  }
  /* istanbul ignore next */
  static get GameBoy() {
    return { width: 160, height: 144 };
  }
  /* istanbul ignore next */
  static get GameBoyAdvance() {
    return { width: 240, height: 160 };
  }
  /* istanbul ignore next */
  static get NintendoDS() {
    return { width: 256, height: 192 };
  }
  /* istanbul ignore next */
  static get NES() {
    return { width: 256, height: 224 };
  }
  /* istanbul ignore next */
  static get SNES() {
    return { width: 256, height: 244 };
  }
}
const ql = {
  ScreenResize: "resize",
  PixelRatioChange: "pixelratio",
  FullScreenChange: "fullscreen"
};
class js {
  constructor(t) {
    this.events = new X(), this._antialiasing = !0, this._canvasImageRendering = "auto", this._resolutionStack = [], this._viewportStack = [], this._pixelRatioOverride = null, this._isFullscreen = !1, this._isDisposed = !1, this._logger = R.getInstance(), this._fullscreenChangeHandler = () => {
      this._isDisposed || (this._isFullscreen = !this._isFullscreen, this._logger.debug("Fullscreen Change", this._isFullscreen), this.events.emit("fullscreen", {
        fullscreen: this.isFullscreen
      }));
    }, this._pixelRatioChangeHandler = () => {
      this._isDisposed || (this._logger.debug("Pixel Ratio Change", window.devicePixelRatio), this._listenForPixelRatio(), this._devicePixelRatio = this._calculateDevicePixelRatio(), this.applyResolutionAndViewport(), this.events.emit("pixelratio", {
        pixelRatio: this.pixelRatio
      }));
    }, this._resizeHandler = () => {
      if (this._isDisposed)
        return;
      const o = this.parent;
      this._logger.debug("View port resized"), this._setResolutionAndViewportByDisplayMode(o), this.applyResolutionAndViewport(), this.events.emit("resize", {
        resolution: this.resolution,
        viewport: this.viewport
      });
    }, this._devicePixelRatio = this._calculateDevicePixelRatio(), this._contentArea = new F(), this._unsafeArea = new F();
    var e, i, s, n;
    this.viewport = t.viewport, this.resolution = (e = t.resolution) != null ? e : { ...this.viewport }, this._contentResolution = this.resolution, this._displayMode = (i = t.displayMode) != null ? i : "Fixed", this._canvas = t.canvas, this.graphicsContext = t.context, this._antialiasing = (s = t.antialiasing) != null ? s : this._antialiasing, this._canvasImageRendering = (n = t.canvasImageRendering) != null ? n : this._canvasImageRendering, this._browser = t.browser, this._pixelRatioOverride = t.pixelRatio, this._applyDisplayMode(), this._listenForPixelRatio(), this._canvas.addEventListener("fullscreenchange", this._fullscreenChangeHandler), this.applyResolutionAndViewport();
  }
  _listenForPixelRatio() {
    this._mediaQueryList && !this._mediaQueryList.addEventListener && this._mediaQueryList.removeListener(this._pixelRatioChangeHandler), this._mediaQueryList = this._browser.window.nativeComponent.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`), this._mediaQueryList.addEventListener ? this._mediaQueryList.addEventListener("change", this._pixelRatioChangeHandler, { once: !0 }) : this._mediaQueryList.addListener(this._pixelRatioChangeHandler);
  }
  dispose() {
    this._isDisposed || (this._isDisposed = !0, this.events.clear(), this._browser.window.off("resize", this._resizeHandler), this._browser.window.clear(), this._resizeObserver && this._resizeObserver.disconnect(), this.parent.removeEventListener("resize", this._resizeHandler), this._mediaQueryList.removeEventListener ? this._mediaQueryList.removeEventListener("change", this._pixelRatioChangeHandler) : this._mediaQueryList.removeListener(this._pixelRatioChangeHandler), this._canvas.removeEventListener("fullscreenchange", this._fullscreenChangeHandler), this._canvas = null);
  }
  _calculateDevicePixelRatio() {
    return window.devicePixelRatio < 1 ? 1 : window.devicePixelRatio || 1;
  }
  /**
   * Returns the computed pixel ratio, first using any override, then the device pixel ratio
   */
  get pixelRatio() {
    return this._pixelRatioOverride ? this._pixelRatioOverride : this._devicePixelRatio;
  }
  /**
   * This calculates the ratio between excalibur pixels and the HTML pixels.
   *
   * This is useful for scaling HTML UI so that it matches your game.
   */
  get worldToPagePixelRatio() {
    if (this._canvas) {
      const t = this.worldToPageCoordinates(v.Zero);
      return this.worldToPageCoordinates(w(1, 0)).sub(t).x;
    } else
      return 1;
  }
  /**
   * Get or set the pixel ratio override
   *
   * You will need to call applyResolutionAndViewport() affect change on the screen
   */
  get pixelRatioOverride() {
    return this._pixelRatioOverride;
  }
  set pixelRatioOverride(t) {
    this._pixelRatioOverride = t;
  }
  get isHiDpi() {
    return this.pixelRatio !== 1;
  }
  get displayMode() {
    return this._displayMode;
  }
  get canvas() {
    return this._canvas;
  }
  get parent() {
    switch (this.displayMode) {
      case "FillContainer":
      case "FitContainer":
      case "FitContainerAndFill":
      case "FitContainerAndZoom":
        return this.canvas.parentElement || document.body;
      default:
        return window;
    }
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(t) {
    this._resolution = t;
  }
  /**
   * Returns screen dimensions in pixels or percentage
   */
  get viewport() {
    return this._viewport ? this._viewport : this._resolution;
  }
  set viewport(t) {
    this._viewport = t;
  }
  get aspectRatio() {
    return this._resolution.width / this._resolution.height;
  }
  get scaledWidth() {
    return this._resolution.width * this.pixelRatio;
  }
  get scaledHeight() {
    return this._resolution.height * this.pixelRatio;
  }
  setCurrentCamera(t) {
    this._camera = t;
  }
  pushResolutionAndViewport() {
    this._resolutionStack.push(this.resolution), this._viewportStack.push(this.viewport), this.resolution = { ...this.resolution }, this.viewport = { ...this.viewport };
  }
  peekViewport() {
    return this._viewportStack[this._viewportStack.length - 1];
  }
  peekResolution() {
    return this._resolutionStack[this._resolutionStack.length - 1];
  }
  popResolutionAndViewport() {
    this._resolutionStack.length && this._viewportStack.length && (this.resolution = this._resolutionStack.pop(), this.viewport = this._viewportStack.pop());
  }
  applyResolutionAndViewport() {
    if (this.graphicsContext instanceof Qt && !this.graphicsContext.checkIfResolutionSupported({
      width: this.scaledWidth,
      height: this.scaledHeight
    }) && (this._logger.warnOnce(
      `The currently configured resolution (${this.resolution.width}x${this.resolution.height}) and pixel ratio (${this.pixelRatio}) are too large for the platform WebGL implementation, this may work but cause WebGL rendering to behave oddly. Try reducing the resolution or disabling Hi DPI scaling to avoid this (read more here https://excaliburjs.com/docs/screens#understanding-viewport--resolution).`
    ), !this.pixelRatioOverride)) {
      let s = Math.max(1, this.pixelRatio - 0.5), n = !1;
      for (; s > 1 && !n; ) {
        s = Math.max(1, s - 0.5);
        const o = this._resolution.width * s, a = this._resolution.height * s;
        n = this.graphicsContext.checkIfResolutionSupported({ width: o, height: a });
      }
      this.pixelRatioOverride = s, this._logger.warnOnce(
        `Scaled resolution too big attempted recovery! Pixel ratio was automatically reduced to (${this.pixelRatio}) to avoid 4k texture limit. Setting \`ex.Engine({pixelRatio: ...}) will override any automatic recalculation, do so at your own risk.\`  (read more here https://excaliburjs.com/docs/screens#understanding-viewport--resolution).`
      );
    }
    this._canvas.width = this.scaledWidth, this._canvas.height = this.scaledHeight, this._canvasImageRendering === "auto" ? this._canvas.style.imageRendering = "auto" : (this._canvas.style.imageRendering = "pixelated", this._canvas.style.imageRendering === "" && (this._canvas.style.imageRendering = "crisp-edges"));
    const t = this.viewport.widthUnit === "percent" ? "%" : "px", e = this.viewport.heightUnit === "percent" ? "%" : "px";
    this._canvas.style.width = this.viewport.width + t, this._canvas.style.height = this.viewport.height + e, this.graphicsContext.updateViewport(this.resolution), this.graphicsContext.resetTransform(), this.graphicsContext.smoothing = this._antialiasing, this.graphicsContext instanceof ns && this.graphicsContext.scale(this.pixelRatio, this.pixelRatio), document.documentElement.style.setProperty("--ex-pixel-ratio", this.worldToPagePixelRatio.toString());
  }
  /**
   * Get or set screen antialiasing,
   *
   * If true smoothing is applied
   */
  get antialiasing() {
    return this._antialiasing;
  }
  /**
   * Get or set screen antialiasing
   */
  set antialiasing(t) {
    this._antialiasing = t, this.graphicsContext.smoothing = this._antialiasing;
  }
  /**
   * Returns true if excalibur is fullscreen using the browser fullscreen api
   * @deprecated use isFullscreen()
   */
  get isFullScreen() {
    return this._isFullscreen;
  }
  /**
   * Returns true if excalibur is fullscreen using the browser fullscreen api
   */
  get isFullscreen() {
    return this._isFullscreen;
  }
  /**
   * Requests to go fullscreen using the browser fullscreen api, requires user interaction to be successful.
   * For example, wire this to a user click handler.
   *
   * Optionally specify a target element id to go fullscreen, by default the game canvas is used
   * @param elementId
   * @deprecated use enterFullscreen(...)
   */
  goFullScreen(t) {
    return this.enterFullscreen(t);
  }
  /**
   * Requests to enter fullscreen using the browser fullscreen api, requires user interaction to be successful.
   * For example, wire this to a user click handler.
   *
   * Optionally specify a target element id to go fullscreen, by default the game canvas is used
   * @param elementId
   */
  enterFullscreen(t) {
    var e, i, s, n, o, a;
    if (t) {
      const h = document.getElementById(t);
      if (h != null && h.requestFullscreen || h != null && h.webkitRequestFullscreen) {
        if (h.getAttribute("ex-fullscreen-listener") || (h.setAttribute("ex-fullscreen-listener", "true"), h.addEventListener("fullscreenchange", this._fullscreenChangeHandler)), h.requestFullscreen)
          return (e = h.requestFullscreen()) != null ? e : Promise.resolve();
        if (h.webkitRequestFullscreen)
          return (i = h.webkitRequestFullscreen()) != null ? i : Promise.resolve();
      }
    }
    return (s = this._canvas) != null && s.requestFullscreen ? (o = (n = this._canvas) == null ? void 0 : n.requestFullscreen()) != null ? o : Promise.resolve() : this._canvas.webkitRequestFullscreen ? (a = this._canvas.webkitRequestFullscreen()) != null ? a : Promise.resolve() : (this._logger.warnOnce("Could not go fullscreen, is this an iPhone? Currently Apple does not support fullscreen on iPhones"), Promise.resolve());
  }
  /**
   * Requests to exit fullscreen using the browser fullscreen api
   * @deprecated use exitFullscreen()
   */
  exitFullScreen() {
    return this.exitFullscreen();
  }
  exitFullscreen() {
    return document.exitFullscreen();
  }
  _viewportToPixels(t) {
    return {
      width: t.widthUnit === "percent" ? this.canvas.offsetWidth : t.width,
      height: t.heightUnit === "percent" ? this.canvas.offsetHeight : t.height
    };
  }
  /**
   * Takes a coordinate in normal html page space, for example from a pointer move event, and translates it to
   * Excalibur screen space.
   *
   * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the
   * bottom right corner (resolutionX, resolutionY). When using *AndFill suffixed display modes screen space
   * (0, 0) is the top left of the safe content area bounding box not the viewport.
   * @param point
   */
  pageToScreenCoordinates(t) {
    let e = t.x, i = t.y;
    this._isFullscreen || (e -= ze(this._canvas).x, i -= ze(this._canvas).y);
    const s = this._viewportToPixels(this.viewport);
    if (this._isFullscreen)
      if (window.innerWidth / this.aspectRatio < window.innerHeight) {
        const n = window.innerWidth / this.aspectRatio, o = (window.innerHeight - n) / 2;
        i = (i - o) / n * s.height, e = e / window.innerWidth * s.width;
      } else {
        const n = window.innerHeight * this.aspectRatio, o = (window.innerWidth - n) / 2;
        e = (e - o) / n * s.width, i = i / window.innerHeight * s.height;
      }
    return e = e / s.width * this.resolution.width, i = i / s.height * this.resolution.height, e = e - this.contentArea.left, i = i - this.contentArea.top, new v(e, i);
  }
  /**
   * Takes a coordinate in Excalibur screen space, and translates it to normal html page space. For example,
   * this is where html elements might live if you want to position them relative to Excalibur.
   *
   * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the
   * bottom right corner (resolutionX, resolutionY)
   * @param point
   */
  screenToPageCoordinates(t) {
    let e = t.x, i = t.y;
    const s = this._viewportToPixels(this.viewport);
    if (e = e / this.resolution.width * s.width, i = i / this.resolution.height * s.height, this._isFullscreen)
      if (window.innerWidth / this.aspectRatio < window.innerHeight) {
        const n = window.innerWidth / this.aspectRatio, o = (window.innerHeight - n) / 2;
        i = i / s.height * n + o, e = e / s.width * window.innerWidth;
      } else {
        const n = window.innerHeight * this.aspectRatio, o = (window.innerWidth - n) / 2;
        e = e / s.width * n + o, i = i / s.height * window.innerHeight;
      }
    return this._isFullscreen || (e += ze(this._canvas).x, i += ze(this._canvas).y), new v(e, i);
  }
  /**
   * Takes a coordinate in Excalibur screen space, and translates it to Excalibur world space.
   *
   * World space is where {@apilink Entity | `entities`} in Excalibur live by default {@apilink CoordPlane.World}
   * and extends infinitely out relative from the {@apilink Camera}.
   * @param point  Screen coordinate to convert
   */
  screenToWorldCoordinates(t) {
    return t = t.add(w(this.contentArea.left, this.contentArea.top)), this._camera ? this._camera.inverse.multiply(t) : t.sub(w(this.resolution.width / 2, this.resolution.height / 2));
  }
  /**
   * Takes a coordinate in Excalibur world space, and translates it to Excalibur screen space.
   *
   * Screen space is where {@apilink ScreenElement | `screen elements`} and {@apilink Entity | `entities`} with {@apilink CoordPlane.Screen} live.
   * @param point  World coordinate to convert
   */
  worldToScreenCoordinates(t) {
    return this._camera ? this._camera.transform.multiply(t) : t.add(w(this.resolution.width / 2, this.resolution.height / 2));
  }
  pageToWorldCoordinates(t) {
    const e = this.pageToScreenCoordinates(t);
    return this.screenToWorldCoordinates(e);
  }
  worldToPageCoordinates(t) {
    const e = this.worldToScreenCoordinates(t);
    return this.screenToPageCoordinates(e);
  }
  /**
   * Returns a BoundingBox of the top left corner of the screen
   * and the bottom right corner of the screen.
   *
   * World bounds are in world coordinates, useful for culling objects offscreen that are in world space
   */
  getWorldBounds() {
    return F.fromDimension(this.resolution.width, this.resolution.height, v.Half).scale(w(1 / this._camera.zoom, 1 / this._camera.zoom)).rotate(this._camera.rotation).translate(this._camera.drawPos);
  }
  /**
   * Returns a BoundingBox of the top left corner of the screen and the bottom right corner of the screen.
   *
   * Screen bounds are in screen coordinates, useful for culling objects offscreen that are in screen space
   */
  getScreenBounds() {
    return F.fromDimension(this.resolution.width, this.resolution.height, v.Zero, v.Zero);
  }
  /**
   * The width of the game canvas in pixels (physical width component of the
   * resolution of the canvas element)
   */
  get canvasWidth() {
    return this.canvas.width;
  }
  /**
   * Returns half width of the game canvas in pixels (half physical width component)
   */
  get halfCanvasWidth() {
    return this.canvas.width / 2;
  }
  /**
   * The height of the game canvas in pixels, (physical height component of
   * the resolution of the canvas element)
   */
  get canvasHeight() {
    return this.canvas.height;
  }
  /**
   * Returns half height of the game canvas in pixels (half physical height component)
   */
  get halfCanvasHeight() {
    return this.canvas.height / 2;
  }
  /**
   * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
   */
  get drawWidth() {
    return this._camera ? this.resolution.width / this._camera.zoom : this.resolution.width;
  }
  /**
   * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
   */
  get width() {
    return this._camera ? this.resolution.width / this._camera.zoom : this.resolution.width;
  }
  /**
   * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
   */
  get halfDrawWidth() {
    return this.drawWidth / 2;
  }
  /**
   * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
   */
  get drawHeight() {
    return this._camera ? this.resolution.height / this._camera.zoom : this.resolution.height;
  }
  get height() {
    return this._camera ? this.resolution.height / this._camera.zoom : this.resolution.height;
  }
  /**
   * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
   */
  get halfDrawHeight() {
    return this.drawHeight / 2;
  }
  /**
   * Returns screen center coordinates including zoom and device pixel ratio.
   */
  get center() {
    return w(this.halfDrawWidth, this.halfDrawHeight);
  }
  /**
   * Returns the content area in screen space where it is safe to place content
   */
  get contentArea() {
    return this._contentArea;
  }
  /**
   * Returns the unsafe area in screen space, this is the full screen and some space may not be onscreen.
   */
  get unsafeArea() {
    return this._unsafeArea;
  }
  _computeFit() {
    document.body.style.margin = "0px", document.body.style.overflow = "hidden";
    const t = this.aspectRatio;
    let e = 0, i = 0;
    window.innerWidth / t < window.innerHeight ? (e = window.innerWidth, i = window.innerWidth / t) : (e = window.innerHeight * t, i = window.innerHeight), this.viewport = {
      width: e,
      height: i
    }, this._contentArea = F.fromDimension(this.resolution.width, this.resolution.height, v.Zero), this._unsafeArea = F.fromDimension(this.resolution.width, this.resolution.height, v.Zero), this.events.emit("resize", {
      resolution: this.resolution,
      viewport: this.viewport
    });
  }
  _computeFitScreenAndFill() {
    document.body.style.margin = "0px", document.body.style.overflow = "hidden";
    const t = window.innerWidth, e = window.innerHeight;
    this._computeFitAndFill(t, e), this.events.emit("resize", {
      resolution: this.resolution,
      viewport: this.viewport
    });
  }
  _computeFitContainerAndFill() {
    this.canvas.style.width = "100%", this.canvas.style.height = "100%", this._computeFitAndFill(this.canvas.offsetWidth, this.canvas.offsetHeight, {
      width: 100,
      widthUnit: "percent",
      height: 100,
      heightUnit: "percent"
    }), this.events.emit("resize", {
      resolution: this.resolution,
      viewport: this.viewport
    });
  }
  _computeFitAndFill(t, e, i) {
    if (this.viewport = i != null ? i : {
      width: t,
      height: e
    }, t / e <= this._contentResolution.width / this._contentResolution.height) {
      this.resolution = {
        width: t * this._contentResolution.width / t,
        height: t * this._contentResolution.width / t * e / t
      };
      const s = (this.resolution.height - this._contentResolution.height) / 2;
      this._contentArea = new F({
        top: s,
        left: 0,
        right: this._contentResolution.width,
        bottom: this.resolution.height - s
      }), this._unsafeArea = new F({
        top: -s,
        left: 0,
        right: this._contentResolution.width,
        bottom: this.resolution.height + s
      });
    } else {
      this.resolution = {
        width: e * this._contentResolution.height / e * t / e,
        height: e * this._contentResolution.height / e
      };
      const s = (this.resolution.width - this._contentResolution.width) / 2;
      this._contentArea = new F({
        top: 0,
        left: s,
        right: this.resolution.width - s,
        bottom: this._contentResolution.height
      }), this._unsafeArea = new F({
        top: 0,
        left: -s,
        right: this.resolution.width + s,
        bottom: this._contentResolution.height
      });
    }
  }
  _computeFitScreenAndZoom() {
    document.body.style.margin = "0px", document.body.style.overflow = "hidden", this.canvas.style.position = "absolute";
    const t = window.innerWidth, e = window.innerHeight;
    this._computeFitAndZoom(t, e), this.events.emit("resize", {
      resolution: this.resolution,
      viewport: this.viewport
    });
  }
  _computeFitContainerAndZoom() {
    this.canvas.style.width = "100%", this.canvas.style.height = "100%", this.canvas.style.position = "relative";
    const t = this.canvas.parentElement;
    t.style.overflow = "hidden";
    const { offsetWidth: e, offsetHeight: i } = this.canvas;
    this._computeFitAndZoom(e, i), this.events.emit("resize", {
      resolution: this.resolution,
      viewport: this.viewport
    });
  }
  _computeFitAndZoom(t, e) {
    const i = this.aspectRatio;
    let s = 0, n = 0;
    t / i < e ? (s = t, n = t / i) : (s = e * i, n = e);
    const o = t / s, a = e / n, h = Math.max(o, a), l = s * h, c = n * h;
    l > t ? this.canvas.style.left = -(l - t) / 2 + "px" : this.canvas.style.left = "", c > e ? this.canvas.style.top = -(c - e) / 2 + "px" : this.canvas.style.top = "", this.viewport = {
      width: l,
      height: c
    };
    const d = F.fromDimension(this.viewport.width, this.viewport.height, v.Zero);
    if (this.viewport.width > t) {
      const u = (this.viewport.width - t) / this.viewport.width * this.resolution.width;
      d.top = 0, d.left = u / 2, d.right = this.resolution.width - u / 2, d.bottom = this.resolution.height;
    }
    if (this.viewport.height > e) {
      const u = (this.viewport.height - e) / this.viewport.height * this.resolution.height;
      d.top = u / 2, d.left = 0, d.bottom = this.resolution.height - u / 2, d.right = this.resolution.width;
    }
    this._contentArea = d;
  }
  _computeFitContainer() {
    const t = this.aspectRatio;
    let e = 0, i = 0, s = "pixel", n = "pixel";
    const o = this.canvas.parentElement;
    o.clientWidth / t < o.clientHeight ? (this.canvas.style.width = "100%", e = 100, s = "percent", i = this.canvas.offsetWidth / t) : (this.canvas.style.height = "100%", i = 100, n = "percent", e = this.canvas.offsetHeight * t), this.viewport = {
      width: e,
      widthUnit: s,
      height: i,
      heightUnit: n
    }, this._contentArea = F.fromDimension(this.resolution.width, this.resolution.height, v.Zero), this.events.emit("resize", {
      resolution: this.resolution,
      viewport: this.viewport
    });
  }
  _applyDisplayMode() {
    this._setResolutionAndViewportByDisplayMode(this.parent), this.parent instanceof Window ? this._browser.window.on("resize", this._resizeHandler) : (this._resizeObserver = new ResizeObserver(() => {
      this._resizeHandler();
    }), this._resizeObserver.observe(this.parent)), this.parent.addEventListener("resize", this._resizeHandler);
  }
  /**
   * Sets the resolution and viewport based on the selected display mode.
   */
  _setResolutionAndViewportByDisplayMode(t) {
    this.displayMode === "FillContainer" && (this.canvas.style.width = "100%", this.canvas.style.height = "100%", this.viewport = {
      width: 100,
      widthUnit: "percent",
      height: 100,
      heightUnit: "percent"
    }, this.resolution = {
      width: this.canvas.offsetWidth,
      height: this.canvas.offsetHeight
    }), this.displayMode === "FillScreen" && (document.body.style.margin = "0px", document.body.style.overflow = "hidden", this.resolution = {
      width: t.innerWidth,
      height: t.innerHeight
    }, this.viewport = this.resolution), this._contentArea = F.fromDimension(this.resolution.width, this.resolution.height, v.Zero), this.displayMode === "FitScreen" && this._computeFit(), this.displayMode === "FitContainer" && this._computeFitContainer(), this.displayMode === "FitScreenAndFill" && this._computeFitScreenAndFill(), this.displayMode === "FitContainerAndFill" && this._computeFitContainerAndFill(), this.displayMode === "FitScreenAndZoom" && this._computeFitScreenAndZoom(), this.displayMode === "FitContainerAndZoom" && this._computeFitContainerAndZoom();
  }
}
class De {
  static create() {
    return this._INSTANCE || (window.AudioContext || window.webkitAudioContext) && (this._INSTANCE = new AudioContext()), this._INSTANCE;
  }
  /**
   * Return the current audio context time in millseconds
   */
  static currentTime() {
    return De.create().currentTime * 1e3;
  }
}
function eh(r) {
  return !!r.playbackState;
}
const Dr = class fi {
  /**
   * Play an empty sound to unlock Safari WebAudio context. Call this function
   * right after a user interaction event.
   * @source https://paulbakaus.com/tutorials/html5/web-audio-on-ios/
   */
  static unlock() {
    return new Promise((e, i) => {
      if (fi._UNLOCKED || !De.create())
        return e(!0);
      const s = setTimeout(() => {
        R.getInstance().warn("Excalibur was unable to unlock the audio context, audio probably will not play in this browser."), e(!1);
      }, 200), n = De.create();
      n.resume().then(
        () => {
          const o = n.createBuffer(1, 1, 22050), a = n.createBufferSource();
          let h = !1;
          a.buffer = o, a.connect(n.destination), a.onended = () => h = !0, a.start(0), setTimeout(() => {
            eh(a) ? (a.playbackState === a.PLAYING_STATE || a.playbackState === a.FINISHED_STATE) && (fi._UNLOCKED = !0) : (n.currentTime > 0 || h) && (fi._UNLOCKED = !0);
          }, 0), clearTimeout(s), e(!0);
        },
        () => {
          i();
        }
      );
    });
  }
  static isUnlocked() {
    return this._UNLOCKED;
  }
};
Dr._UNLOCKED = !1;
let ih = Dr;
class Br {
}
Br.type = {
  any: "",
  blob: "blob",
  json: "json",
  text: "text",
  document: "document",
  arraybuffer: "arraybuffer"
};
class Ts {
  constructor() {
    this.states = /* @__PURE__ */ new Map();
  }
  get currentState() {
    return this._currentState;
  }
  set currentState(t) {
    this._currentState = t;
  }
  static create(t, e) {
    const i = new Ts();
    i.data = e;
    for (const s in t.states)
      i.states.set(s, {
        name: s,
        ...t.states[s]
      });
    for (const s of i.states.values())
      for (const n of s.transitions)
        if (n !== "*" && !i.states.has(n))
          throw Error(
            `Invalid state machine, state [${s.name}] has a transition to another state that doesn't exist [${n}]`
          );
    return i.currentState = i.startState = i.states.get(t.start), i;
  }
  in(t) {
    return this.currentState.name === t;
  }
  go(t, e) {
    var i, s;
    if (this.currentState.transitions.includes(t) || this.currentState.transitions.includes("*")) {
      const n = this.states.get(t);
      return this.currentState.onExit && ((i = this.currentState) == null ? void 0 : i.onExit({ to: n.name, data: this.data })) === !1 || n != null && n.onEnter && (n == null ? void 0 : n.onEnter({ from: this.currentState.name, eventData: e, data: this.data })) === !1 ? !1 : (this.currentState = n, (s = this.currentState) != null && s.onState && this.currentState.onState(), !0);
    }
    return !1;
  }
  update(t) {
    this.currentState.onUpdate && this.currentState.onUpdate(this.data, t);
  }
  save(t) {
    localStorage.setItem(
      t,
      JSON.stringify({
        currentState: this.currentState.name,
        data: this.data
      })
    );
  }
  restore(t) {
    const e = JSON.parse(localStorage.getItem(t));
    this.currentState = this.states.get(e.currentState), this.data = e.data;
  }
}
class sh {
  constructor(t) {
    this._src = t, this._audioContext = De.create(), this._volumeNode = this._audioContext.createGain(), this._playingFuture = new yt(), this._stateMachine = Ts.create(
      {
        start: "STOPPED",
        states: {
          PLAYING: {
            onEnter: ({ data: e }) => {
              this._createNewBufferSource(), this._handleEnd(), this.loop ? this._instance.start(this.scheduledStartTime, e.pausedAt * this._playbackRate) : this._instance.start(this.scheduledStartTime, e.pausedAt * this._playbackRate, this.duration), e.startedAt = this._audioContext.currentTime - e.pausedAt, e.pausedAt = 0;
            },
            onState: () => this._playStarted(),
            onExit: ({ to: e }) => {
              e === "STOPPED" && this._playingFuture.resolve(!0), this._instance.onended = null, this._instance.disconnect(), this._instance.stop(0), this._instance = null;
            },
            transitions: ["STOPPED", "PAUSED", "SEEK"]
          },
          SEEK: {
            onEnter: ({ eventData: e, data: i }) => {
              i.pausedAt = (e != null ? e : 0) / this._playbackRate, i.startedAt = 0;
            },
            transitions: ["*"]
          },
          STOPPED: {
            onEnter: ({ data: e }) => {
              e.pausedAt = 0, e.startedAt = 0, this._playingFuture.resolve(!0);
            },
            transitions: ["PLAYING", "PAUSED", "SEEK"]
          },
          PAUSED: {
            onEnter: ({ data: e }) => {
              e.pausedAt = this._audioContext.currentTime - e.startedAt;
            },
            transitions: ["PLAYING", "STOPPED", "SEEK"]
          }
        }
      },
      {
        startedAt: 0,
        pausedAt: 0
      }
    ), this._volume = 1, this._loop = !1, this._playStarted = () => {
    }, this._playbackRate = 1, this.scheduledStartTime = 0, this._createNewBufferSource();
  }
  _createNewBufferSource() {
    this._instance = this._audioContext.createBufferSource(), this._instance.buffer = this._src, this._instance.loop = this.loop, this._instance.playbackRate.value = this._playbackRate, this._instance.connect(this._volumeNode), this._volumeNode.connect(this._audioContext.destination);
  }
  _handleEnd() {
    this.loop || (this._instance.onended = () => {
      this._playingFuture.resolve(!0);
    });
  }
  set loop(t) {
    this._loop = t, this._instance && (this._instance.loop = t, this.loop || (this._instance.onended = () => {
      this._playingFuture.resolve(!0);
    }));
  }
  get loop() {
    return this._loop;
  }
  set volume(t) {
    t = D(t, 0, 1), this._volume = t, this._stateMachine.in("PLAYING") && this._volumeNode.gain.setTargetAtTime ? this._volumeNode.gain.setTargetAtTime(t, this._audioContext.currentTime, 0.1) : this._volumeNode.gain.value = t;
  }
  get volume() {
    return this._volume;
  }
  /**
   * Returns the set duration to play, otherwise returns the total duration if unset
   */
  get duration() {
    var t;
    return (t = this._duration) != null ? t : this.getTotalPlaybackDuration();
  }
  /**
   * Set the duration that this audio should play.
   *
   * Note: if you seek to a specific point the duration will start from that point, for example
   *
   * If you have a 10 second clip, seek to 5 seconds, then set the duration to 2, it will play the clip from 5-7 seconds.
   */
  set duration(t) {
    this._duration = t;
  }
  isPlaying() {
    return this._stateMachine.in("PLAYING");
  }
  isPaused() {
    return this._stateMachine.in("PAUSED") || this._stateMachine.in("SEEK");
  }
  isStopped() {
    return this._stateMachine.in("STOPPED");
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  play(t = () => {
  }) {
    return this._playStarted = t, this._stateMachine.go("PLAYING"), this._playingFuture.promise;
  }
  pause() {
    this._stateMachine.go("PAUSED");
  }
  stop() {
    this._stateMachine.go("STOPPED");
  }
  seek(t) {
    this._stateMachine.go("PAUSED"), this._stateMachine.go("SEEK", t);
  }
  getTotalPlaybackDuration() {
    return this._src.duration;
  }
  getPlaybackPosition() {
    const { pausedAt: t, startedAt: e } = this._stateMachine.data;
    return t ? t * this._playbackRate : e ? (this._audioContext.currentTime - e) * this._playbackRate : 0;
  }
  set playbackRate(t) {
    this._instance.playbackRate.value = this._playbackRate = t;
  }
  get playbackRate() {
    return this._instance.playbackRate.value;
  }
}
class kr extends B {
  constructor(t, e = "MediaEvent") {
    super(), this.target = t, this._name = e;
  }
  /**
   * Media event cannot bubble
   */
  set bubbles(t) {
  }
  /**
   * Media event cannot bubble
   */
  get bubbles() {
    return !1;
  }
  /**
   * Media event cannot bubble, so they have no path
   */
  get _path() {
    return null;
  }
  /**
   * Media event cannot bubble, so they have no path
   */
  set _path(t) {
  }
  /**
   * Prevents event from bubbling
   */
  stopPropagation() {
  }
  /**
   * Action, that calls when event happens
   */
  action() {
  }
  /**
   * Propagate event further through event path
   */
  propagate() {
  }
  layPath(t) {
  }
}
class be extends kr {
  constructor(t, e) {
    super(t, "NativeSoundEvent"), this.track = e;
  }
}
class nh extends kr {
  constructor(t, e) {
    super(t, "NativeSoundProcessedEvent"), this._processedData = e, this.data = this._processedData;
  }
}
function rh(r) {
  try {
    const t = new Audio(), e = /.*\.([A-Za-z0-9]+)(?:(?:\?|\#).*)*$/, i = r.match(e)[1];
    return !!t.canPlayType("audio/" + i);
  } catch (t) {
    return R.getInstance().warn("Cannot determine audio support, assuming no support for the Audio Tag", t), !1;
  }
}
const Xl = {
  VolumeChange: "volumechange",
  Processed: "processed",
  Pause: "pause",
  Stop: "stop",
  PlaybackEnd: "playbackend",
  Resume: "resume",
  PlaybackStart: "playbackstart"
};
function oh(r) {
  var t;
  return !!((t = r[0]) != null && t.paths);
}
class Lr {
  constructor(...t) {
    this.events = new X(), this.logger = R.getInstance(), this.scheduledStartTime = 0, this._loop = !1, this._volume = 1, this._isStopped = !1, this._tracks = [], this._wasPlayingOnHidden = !1, this._playbackRate = 1, this._audioContext = De.create();
    let e;
    oh(t) ? e = t[0] : e = {
      paths: t
    }, this._resource = new Ii("", Br.type.arraybuffer);
    const { volume: i, position: s, playbackRate: n, loop: o, bustCache: a, duration: h } = e;
    this.volume = i != null ? i : this.volume, this.playbackRate = n != null ? n : this.playbackRate, this.loop = o != null ? o : this.loop, this.duration = h != null ? h : this.duration, this.bustCache = a != null ? a : this.bustCache, this.position = s != null ? s : this.position;
    for (const l of e.paths)
      if (rh(l)) {
        this.path = l;
        break;
      }
    this.path || (this.logger.warn("This browser does not support any of the audio files specified:", e.paths.join(", ")), this.logger.warn("Attempting to use", e.paths[0]), this.path = e.paths[0]);
  }
  /**
   * Indicates whether the clip should loop when complete
   * @param value  Set the looping flag
   */
  set loop(t) {
    this._loop = t;
    for (const e of this._tracks)
      e.loop = this._loop;
    this.logger.debug("Set loop for all instances of sound", this.path, "to", this._loop);
  }
  get loop() {
    return this._loop;
  }
  set volume(t) {
    this._volume = t;
    for (const e of this._tracks)
      e.volume = this._volume;
    this.events.emit("volumechange", new be(this)), this.logger.debug("Set loop for all instances of sound", this.path, "to", this._volume);
  }
  get volume() {
    return this._volume;
  }
  /**
   * Get the duration that this audio should play. If unset the total natural playback duration will be used.
   */
  get duration() {
    return this._duration;
  }
  /**
   * Set the duration that this audio should play. If unset the total natural playback duration will be used.
   *
   * Note: if you seek to a specific point the duration will start from that point, for example
   *
   * If you have a 10 second clip, seek to 5 seconds, then set the duration to 2, it will play the clip from 5-7 seconds.
   */
  set duration(t) {
    this._duration = t;
  }
  /**
   * Return array of Current AudioInstances playing or being paused
   */
  get instances() {
    return this._tracks;
  }
  get path() {
    return this._resource.path;
  }
  set path(t) {
    this._resource.path = t;
  }
  /**
   * Should excalibur add a cache busting querystring? By default false.
   * Must be set before loading
   */
  get bustCache() {
    return this._resource.bustCache;
  }
  set bustCache(t) {
    this._resource.bustCache = t;
  }
  isLoaded() {
    return !!this.data;
  }
  async load() {
    var t, e;
    if (this.data)
      return this.data;
    const i = await this._resource.load(), s = await this.decodeAudio(i.slice(0));
    return this._duration = (e = (t = this._duration) != null ? t : s == null ? void 0 : s.duration) != null ? e : void 0, this.events.emit("processed", new nh(this, s)), this.data = s;
  }
  async decodeAudio(t) {
    try {
      return await this._audioContext.decodeAudioData(t.slice(0));
    } catch (e) {
      return this.logger.error(
        "Unable to decode  this browser may not fully support this format, or the file may be corrupt, if this is an mp3 try removing id3 tags and album art from the file."
      ), await Promise.reject();
    }
  }
  wireEngine(t) {
    t && (this._engine = t, this._engine.on("hidden", () => {
      t.pauseAudioWhenHidden && this.isPlaying() && (this._wasPlayingOnHidden = !0, this.pause());
    }), this._engine.on("visible", () => {
      t.pauseAudioWhenHidden && this._wasPlayingOnHidden && (this.play(), this._wasPlayingOnHidden = !1);
    }), this._engine.on("start", () => {
      this._isStopped = !1;
    }), this._engine.on("stop", () => {
      this.stop(), this._isStopped = !0;
    }));
  }
  /**
   * Returns how many instances of the sound are currently playing
   */
  instanceCount() {
    return this._tracks.length;
  }
  /**
   * Whether or not the sound is playing right now
   */
  isPlaying() {
    return this._tracks.some((t) => t.isPlaying());
  }
  isPaused() {
    return this._tracks.some((t) => t.isPaused());
  }
  isStopped() {
    return this._tracks.some((t) => t.isStopped());
  }
  /**
   * Play the sound, returns a promise that resolves when the sound is done playing
   * An optional volume argument can be passed in to play the sound. Max volume is 1.0
   */
  play(t) {
    if (!this.isLoaded())
      return this.logger.warn("Cannot start playing. Resource", this.path, "is not loaded yet"), Promise.resolve(!0);
    if (this._isStopped)
      return this.logger.warn("Cannot start playing. Engine is in a stopped state."), Promise.resolve(!1);
    let e = 0;
    if (t instanceof Object) {
      const { volume: i, scheduledStartTime: s } = t;
      e = (s != null ? s : 0) / 1e3 || e, this.volume = i != null ? i : this.volume;
    } else
      this.volume = t != null ? t : this.volume;
    return this.isPaused() ? this._resumePlayback() : (this.position && this.seek(this.position), this._startPlayback(e));
  }
  /**
   * Stop the sound, and do not rewind
   */
  pause() {
    if (this.isPlaying()) {
      for (const t of this._tracks)
        t.pause();
      this.events.emit("pause", new be(this)), this.logger.debug("Paused all instances of sound", this.path);
    }
  }
  /**
   * Stop the sound if it is currently playing and rewind the track. If the sound is not playing, rewinds the track.
   */
  stop() {
    for (const t of this._tracks)
      t.stop();
    this.events.emit("stop", new be(this)), this._tracks.length = 0, this.logger.debug("Stopped all instances of sound", this.path);
  }
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(t) {
    this._playbackRate = t, this._tracks.forEach((e) => {
      e.playbackRate = this._playbackRate;
    });
  }
  seek(t, e = 0) {
    this._tracks.length === 0 && this._getTrackInstance(this.data), this._tracks[e].seek(t);
  }
  getTotalPlaybackDuration() {
    return this.isLoaded() ? this.data.duration : (this.logger.warnOnce(
      `Sound from ${this.path} is not loaded, cannot return total playback duration.Did you forget to add Sound to a loader? https://excaliburjs.com/docs/loaders/`
    ), 0);
  }
  /**
   * Return the current playback time of the playing track in seconds from the start.
   *
   * Optionally specify the track to query if multiple are playing at once.
   * @param trackId
   */
  getPlaybackPosition(t = 0) {
    return this._tracks.length ? this._tracks[t].getPlaybackPosition() : 0;
  }
  /**
   * Get Id of provided AudioInstance in current trackList
   * @param track {@apilink Audio} which Id is to be given
   */
  getTrackId(t) {
    return this._tracks.indexOf(t);
  }
  async _resumePlayback(t = 0) {
    if (this.isPaused()) {
      const e = [];
      for (const i of this._tracks)
        i.scheduledStartTime = t, e.push(
          i.play().then(() => (this._tracks.splice(this.getTrackId(i), 1), !0))
        );
      this.events.emit("resume", new be(this)), this.logger.debug("Resuming paused instances for sound", this.path, this._tracks), await Promise.all(e);
    }
    return !0;
  }
  /**
   * Starts playback, returns a promise that resolves when playback is complete
   */
  async _startPlayback(t = 0) {
    const e = this._getTrackInstance(this.data);
    e.scheduledStartTime = t;
    const i = await e.play(() => {
      this.events.emit("playbackstart", new be(this, e)), this.logger.debug("Playing new instance for sound", this.path);
    });
    this.events.emit("playbackend", new be(this, e));
    const s = this.getTrackId(e);
    return s !== -1 && this._tracks.splice(s, 1), i;
  }
  _getTrackInstance(t) {
    var e;
    const i = new sh(t);
    return i.loop = this.loop, i.volume = this.volume, i.duration = (e = this.duration) != null ? e : 0, i.playbackRate = this._playbackRate, this._tracks.push(i), i;
  }
  emit(t, e) {
    this.events.emit(t, e);
  }
  on(t, e) {
    return this.events.on(t, e);
  }
  once(t, e) {
    return this.events.once(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
}
const $l = {
  // Add event types here
  BeforeLoad: "beforeload",
  AfterLoad: "afterload",
  UserAction: "useraction",
  LoadResourceStart: "loadresourcestart",
  LoadResourceEnd: "loadresourceend"
};
function Qs(r) {
  var t, e;
  return !!(r != null && r.prototype) && !!((e = (t = r == null ? void 0 : r.prototype) == null ? void 0 : t.constructor) != null && e.name);
}
class yi {
  /**
   * @param options Optionally provide the list of resources you want to load at constructor time
   */
  constructor(t) {
    this.events = new X(), this.canvas = new xs({
      filtering: wt.Blended,
      smoothing: !0,
      cache: !1,
      draw: this.onDraw.bind(this)
    }), this._resources = [], this._numLoaded = 0, this._loaded = !1, this._isLoading = !1, this._totalTimeMs = 0, this._resourcesLoadedFuture = new yt(), this._loaderCompleteFuture = new yt();
    var e;
    t && ((e = t.loadables) != null && e.length) && this.addResources(t.loadables);
  }
  get resources() {
    return this._resources;
  }
  /**
   * Called by the engine before loading
   * @param engine
   */
  onInitialize(t) {
    this.engine = t, this.canvas.width = this.engine.screen.resolution.width, this.canvas.height = this.engine.screen.resolution.height;
  }
  /**
   * Return a promise that resolves when the user interacts with the loading screen in some way, usually a click.
   *
   * It's important to implement this in order to unlock the audio context in the browser. Browsers automatically prevent
   * audio from playing until the user performs an action.
   *
   */
  async onUserAction() {
    return await Promise.resolve();
  }
  /**
   * Overridable lifecycle method, called directly before loading starts
   */
  async onBeforeLoad() {
  }
  /**
   * Overridable lifecycle method, called after loading has completed
   */
  async onAfterLoad() {
    await xi(500, this.engine.clock);
  }
  /**
   * Add a resource to the loader to load
   * @param loadable  Resource to add
   */
  addResource(t) {
    this._resources.push(t), this._loaded = !1;
  }
  /**
   * Add a list of resources to the loader to load
   * @param loadables  The list of resources to load
   */
  addResources(t) {
    let e = 0;
    const i = t.length;
    for (e; e < i; e++)
      this.addResource(t[e]);
    this._loaded = !1;
  }
  markResourceComplete() {
    this._numLoaded++;
  }
  /**
   * Returns the progress of the loader as a number between [0, 1] inclusive.
   */
  get progress() {
    const t = this._resources.length;
    return t > 0 ? D(this._numLoaded, 0, t) / t : 1;
  }
  /**
   * Returns true if the loader has completely loaded all resources
   */
  isLoaded() {
    return this._loaded || this._resources.length === 0;
  }
  /**
   * Optionally override the onUpdate
   * @param engine
   * @param elapsed
   */
  onUpdate(t, e) {
    this._totalTimeMs += e;
  }
  /**
   * Optionally override the onDraw
   */
  onDraw(t) {
    const e = this._totalTimeMs / 1e3;
    t.fillStyle = T.Black.toRGBA(), t.fillRect(0, 0, this.engine.screen.resolution.width, this.engine.screen.resolution.height), t.save(), t.translate(this.engine.screen.resolution.width / 2, this.engine.screen.resolution.height / 2);
    const i = e * 10;
    t.strokeStyle = "white", t.lineWidth = 10, t.lineCap = "round", t.arc(0, 0, 40, i, i + Math.PI * 3 / 2), t.stroke(), t.fillStyle = "white", t.font = "16px sans-serif";
    const s = (this.progress * 100).toFixed(0) + "%", n = t.measureText(s), o = Math.abs(n.actualBoundingBoxLeft) + Math.abs(n.actualBoundingBoxRight), a = Math.abs(n.actualBoundingBoxAscent) + Math.abs(n.actualBoundingBoxDescent);
    t.fillText(s, -o / 2, a / 2), t.restore();
  }
  areResourcesLoaded() {
    return this._resources.length === 0 ? Promise.resolve() : this._resourcesLoadedFuture.promise;
  }
  /**
   * Not meant to be overridden
   *
   * Begin loading all of the supplied resources, returning a promise
   * that resolves when loading of all is complete AND the user has interacted with the loading screen
   */
  async load() {
    if (this._isLoading)
      return this._loaderCompleteFuture.promise;
    if (this.isLoaded())
      return this.data = this._resources;
    this._isLoading = !0, this._loaderCompleteFuture = new yt(), await this.onBeforeLoad(), this.events.emit("beforeload"), this.canvas.flagDirty(), await Promise.all(
      this._resources.filter((t) => !t.isLoaded()).map(async (t) => {
        this.events.emit("loadresourcestart", t), await t.load().finally(() => {
          this._numLoaded++, this.canvas.flagDirty(), this.events.emit("loadresourceend", t);
        });
      })
    );
    for (const t of this._resources)
      t instanceof Lr && t.wireEngine(this.engine);
    return this._resourcesLoadedFuture.resolve(), this.canvas.flagDirty(), await this.onUserAction(), this.events.emit("useraction"), await ih.unlock(), await this.onAfterLoad(), this.events.emit("afterload"), this._isLoading = !1, this._loaded = !0, this._loaderCompleteFuture.resolve(this._resources), this.data = this._resources;
  }
  emit(t, e) {
    this.events.emit(t, e);
  }
  on(t, e) {
    return this.events.on(t, e);
  }
  once(t, e) {
    return this.events.once(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
}
const ah = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAdQAAAB2CAYAAABxhGI9AAAACXBIWXMAAAsSAAALEgHS3X78AAAKnUlEQVR42u3dP2wjSx0H8N8hJIonIRmJjsq0SBR+BQ1dcqKhe0lD77SvSwpKkJKGPulpktfRIMUdEqKIqV57rpAokM4dbSiyq7ONPTP7x39ifz7SFbnEnp3xer47O7uzH15fXwMA6OYHmgAABCoACFQAEKgAgEAFAIEKAAIVAAQqACBQAUCgAoBABQCBCgAIVAAQqAAgUAFAoAIAAhUABCoACFQAEKgAgECFLbmOiNeFf2PbAyz68Pr6qhUgbRwR92v+/zwiJrYHMEKFMmcN///UtgcQqFBk1PD/97U9Qx8VCFSgu4EmAIEKAAIVAAQqACBQ4Z25jojP8eX+0WtNAgIVaOY+Im5j+eKh24h41jQgUIEyZ7F5NaPU7wCBCiwYd/w9cOB+qAlgJ3KLLow0EV198803RWvJfvfddx+0lhEqHKu5JgAjVCBvlhmFzjQRXUekHz9+TP79y8uLRjNChXfvoePvAYEKxNtj1e42/O5JoIJABcrdRMRVLM+X3kTEpaaB988cKuzWg9EobTWdMx0Oly8uN4dqhAoARqgnaN3arHfqu7OyH8ItKLVB/P+CEfMTHyGPY3npx1m8zWGDEeoBfUk/xdti57dr/r1Wv2+6EPow3tZ5rRdS72s1neuF97xvWd+XTH0/V+UMttDWqbI/r2nrxfp+jv2uSjSO7S+OXy/A/3lN+9xX5T5HxEUPZZ0tfB71+w57eJ/HFu+z+jkv1u92YX9fbI/HhX3JA9rp5MPr66tWaG9UfUGbrHIzi7cLUyYFf/tpTady03EEeL8mUJ6i7MKYNvWNqr4Pe2jradXO60LrvPAz2PQ5RPX684ah8dxD+2zantnCgVipSVV+m/tgB9W2DDq2Sx/vM95wcHhZhWVJm8yrv58cSgfTdc70+++/X/r522+/tUKSEepBqo+om4ZLPerMjUwuNnQCtx1GWJtee1FwdD5uWd86xLs8UaVt2aNEO1/saZ/Z5rYMW4zq6v34rGV9Bg3q2eZ9SkeNm9qwyUh30OPIHYFKx5FG03C7znSOqYBq+qW/zpQ3anH037TNHluG6f0WPsPhHvab4QFty7ogOeuxDYcNy2/zu2214WNYWxmBurNO8bGn97pNBOO8xy/9uCorZZ4I2r4C7aJgO7ZV9iE49Dm6NvOWx+pWE9CUq3zbdTp9doz38TbXtzqH9RT5CyWe422OaZoZGeZCabrhPQY9HjwsjpTvCg4YtlE2+Ta/j2bzn8fqrDqgm+6yUHOmAvWUjAtGhbNYvsBknDnqH1Qhc7VmxHgeb/NbudA5j/UXlYwif2p6luhAc9teu1npiHKnDs8if6tCm7JLX3NKpgttXe9ruc9mHMd7a83iwdxF5vt8tutARaCeklRnNK9C8WnNF7geJQ4T4XG3JhSnVdilQrG+yOnrlVHfsEGYzhNBn7Lu6tS7+HJafJQ4EMiNlNqWXZ9WPvVgnVYHG5M1ByDXkT6leX2EgTqJtyt45yv7S2qO3sEZjZhDLXeR+YKdJ0Zdk8QocvH9N732KrNtq+FZ/zzIHABcJrYpd+Xv14lOd5ap76SgrduW/VTQ1qcQpqnbgu4ifZvUMNpd9XuoZmvCtPaQ2Y/BCHVLgbrJTeRPDdVf6pfMKDU2fOkHmVFFfXr3MsouLsnNvV5kRoe5+s431PeuoKPqWnaurY/ZPBEeqwceN4l96iwO6H7Mjq4y7VGPVNe10VaZMzVCPVWpI/Z6FZbcv5fMqGCU+dLfFGzj58jP8+bCdJCo7yzKTwdOF0bu9Ug7V4c+yz7FJfYeGoysUss0HssIdVZwYLDujMqlESoCdTtGsZtbHnJBeNdDSJSs0jTKdMJN1HNX54Wv7bvsU9NkVJVa13dX+/wuArV0X/l5RHyo/lnfF4G6p6DrS0kHdtXhy35TGErDPYZUn2WfWqDOo/lVqdMD2O/hKJhD7S/odukymq9s02QN4EEPR/zbaOumZc+r15zK1Zqznl9jsfiemTM1QmV3HUuTkedlg9HIQzRbUD93dfC+2tpj2fIHEH2+RqCCQH13gZq7hWXTNpVu19OB1fc9nQ0AKOKUb5lU0P1kDyOneoWk0lOZ9cIP0x7qu8+2BhCoR2wYu1+e7DmaXzBSsu5vaX1ne2zrpmUPTmxf7PM1Dm4y/vC7ny7Nif7+z/9ZmtM0Z3panPLtPmra9f16bcK0Dpbnwk43Vd/RHtu6zfNQTy1QBy3aqG2g9nVmxml+BOoJyT3NpWmn9xhfFnu4bvDa+44BXhqqfdf3uUF9+yz77AT31Yue2mjecYQ62NLfgkA9ghHqLNEhNem4H1c6vdyDxhf/bpz5m4coW/c39wi6VH2bPtHlcaV9cvXts+zxCe6rTeqc2ndL7uGd93QwM9bFcAzMoZZ7SgTBbWx+asui61h/iq1+RmjqdbnQXQ3T1DNQ63V/U9ucqm/pMzPb1rePsk/1iTOjgvatR4W3Lc8ULB78pELyrnAfeTcj1NU509/86mfJ33/8+Mf00a05UyPUEw7UVCeWG/WNEiExyHRMt5ltW30izUPk18ytt7lNfc8i//DvtvXto+ySA5BjljsLUF8lPkqMPEtW1JomDsiGBZ9Byb4NAvUITSN9GuwsIj6t6UTOqk7jJREkmzqli8xIs96udSO20sX0H1vW92IL9e1a9rgqVyf91gbPsTy9UD9n9lOkT8k+RfkFR5PMNqxOcdSf32PBvg3vilO+zdxE+okx9Wm0ph36XYsRZCpMF993GOk5qvqB3Dct6jvssb67KvuUNJ3frw92bhr8/STSF0JdRPMLpUCgnsgo9S76PZ246ZFk1wWvK5m3vVoYvW1Sz7nN91jfXbQ1ZQc7TW6HeaoOalypG/8/p/rP1aNAc6ZHzSnfdqPUPhdy2PQw6Nz9gSVhuhiqueUHR3uu7y7K3rdDX4u46ZrPbUa0IFBZ0seKQ3XQTRt2vm3W/a2DbNKys++rvm3ep6+y1x2UdP3bWU9lzra47U1GmlctX/sQ23t+aOlByLTh/4NAPaCRxtcdO5HLSJ/6vNtCwGx67VPmPbvWd1q9frKHtp4kAqRJ2HR9j762JfX3bZ//elPtj13PPDx1+D5tqk/Xi6NO8SHz7MmH19dXrdBNfVFP6T2PT1UHNit87/t4m5+aRH+nQBdvqyhZDKJLfZs8h7XPsqdV2ZOV+tanKB8aln0dyxdAXbV4j4gvt4oMOrbP6vbU73NW7TMlbdTnPrWpfqXfh9HKZ9vke7KuTeZRNtXRSe6+1FV//ce/ln5eXfsXgcqXzr6+9261M3moOoa7E6nvTZTfy7iNsmfb7kjfgXGsvxe0vihsEts9HTquPpt1q1vtahu2TqAiUAEEKj0zhwoARqgAu/OnX/442WH+9xc/Wvr58re/Tr7f41/+ZsRqhAoACFQAEKgAcHjMoQJskJsz/eqrr5Z+vvr7v5fmQFevAl5lztQIFQAQqAAgUAHgIJlDBdhgdQ41N2eKESoAIFABQKACwFEwhwoARqgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAEKgAgUAFAoAKAQAUAgQoACFQAEKgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAQqAAgUAFAoAKAQAUAlvwPcFDns1DsH4sAAAAASUVORK5CYII=", hh = 'button#excalibur-play{display:none}button#excalibur-play{box-sizing:border-box;display:flex;gap:.25rem;justify-content:center;position:relative;z-index:999;border-radius:6px;border:none;padding:1rem;margin:0;text-decoration:none;background:#00b233;color:#fff;font-family:sans-serif;font-size:2rem;white-space:nowrap;line-height:1;cursor:pointer;text-align:center;transition:background .25s ease-in-out,transform .15s ease;-webkit-appearance:none;-moz-appearance:none;-webkit-animation:excalibur-button-fadein .2s;-moz-animation:excalibur-button-fadein .2s;-ms-animation:excalibur-button-fadein .2s;-o-animation:excalibur-button-fadein .2s;animation:excalibur-button-fadein .2s}span#excalibur-play-icon{content:"";display:inline-block;position:relative;width:2rem;height:2rem}span#excalibur-play-icon:after{box-sizing:border-box;position:absolute;content:"";border:.5rem solid;border-color:transparent transparent transparent white;left:calc(50% - .1rem);top:calc(30% - .1rem);width:0;height:0}span#excalibur-play-icon:before{box-sizing:border-box;left:50%;top:50%;transform:translate(-50%,-50%);position:absolute;content:"";border:3px solid;border-radius:1rem;width:2rem;height:2rem}button#excalibur-play:focus{outline:1px solid #fff;outline-offset:-4px}button#excalibur-play:active{transform:scale(.99)}@keyframes excalibur-button-fadein{0%{opacity:0}to{opacity:1}}@-moz-keyframes excalibur-button-fadein{0%{opacity:0}to{opacity:1}}@-webkit-keyframes excalibur-button-fadein{0%{opacity:0}to{opacity:1}}@-ms-keyframes excalibur-button-fadein{0%{opacity:0}to{opacity:1}}@-o-keyframes excalibur-button-fadein{0%{opacity:0}to{opacity:1}}', Ur = class zr extends yi {
  constructor(t) {
    const e = Array.isArray(t) ? {
      loadables: t
    } : t;
    super(e), this._logger = R.getInstance(), this._originalOptions = { loadables: [] }, this.events = new X(), this._playButtonShown = !1, this.logo = ah, this.logoWidth = 468, this.logoHeight = 118, this.loadingBarColor = T.White, this.backgroundColor = "#176BAA", this._imageLoaded = new yt(), this.suppressPlayButton = !1, this._playButtonStyles = hh, this.playButtonText = "Play game", this.startButtonFactory = () => {
      let i = document.getElementById("excalibur-play");
      if (i || (i = document.createElement("button")), i.id = "excalibur-play", i.style.display = "none", i) {
        let [s, n] = i.getElementsByTagName("span");
        s || (s != null || (s = document.createElement("span")), i.appendChild(s)), s.id = "excalibur-play-icon", n || (n != null || (n = document.createElement("span")), i.appendChild(n)), n.id = "excalibur-play-text", n.textContent = this.playButtonText;
      }
      return i;
    }, this._originalOptions = { ...zr._DEFAULT_LOADER_OPTIONS, ...e };
  }
  get _image() {
    return this._imageElement || (this._imageElement = new Image(), this._imageElement.onload = () => this._imageLoaded.resolve(), this._imageElement.src = this.logo), this._imageElement;
  }
  get playButtonRootElement() {
    return this._playButtonRootElement;
  }
  get playButtonElement() {
    return this._playButtonElement;
  }
  get _playButton() {
    const t = document.getElementById("excalibur-play-root");
    return t && (this._playButtonRootElement = t), this._playButtonRootElement || (this._playButtonRootElement = document.createElement("div"), this._playButtonRootElement.id = "excalibur-play-root", this._playButtonRootElement.style.position = "absolute", document.body.appendChild(this._playButtonRootElement)), this._styleBlock || (this._styleBlock = document.createElement("style"), this._styleBlock.textContent = this._playButtonStyles, document.head.appendChild(this._styleBlock)), this._playButtonElement || (this._playButtonElement = this.startButtonFactory(), this._playButtonRootElement.appendChild(this._playButtonElement)), this._playButtonElement;
  }
  onInitialize(t) {
    this.engine = t, this.screen = t.screen, this.canvas.width = this.engine.canvas.width, this.canvas.height = this.engine.canvas.height, this.screen.events.on("resize", () => {
      this.canvas.width = this.engine.canvas.width, this.canvas.height = this.engine.canvas.height;
    });
  }
  /**
   * Shows the play button and returns a promise that resolves when clicked
   */
  async showPlayButton() {
    var t, e;
    if (this.suppressPlayButton)
      this.hidePlayButton(), await xi(500, (t = this.engine) == null ? void 0 : t.clock);
    else {
      const i = () => {
        try {
          this._positionPlayButton();
        } catch (n) {
        }
      };
      return (e = this.engine) != null && e.browser && this.engine.browser.window.on("resize", i), this._playButtonShown = !0, this._playButton.style.display = "flex", document.body.addEventListener("keyup", (n) => {
        n.key === "Enter" && this._playButton.click();
      }), this._positionPlayButton(), await new Promise((n) => {
        const o = (a) => {
          var h;
          if (a.stopPropagation(), this.hidePlayButton(), (h = this.engine) != null && h.browser && this.engine.browser.window.off("resize", i), this._originalOptions.fullscreenAfterLoad)
            try {
              this._logger.info("requesting fullscreen"), this._originalOptions.fullscreenContainer instanceof HTMLElement ? this._originalOptions.fullscreenContainer.requestFullscreen() : this.engine.screen.enterFullscreen(this._originalOptions.fullscreenContainer);
            } catch (l) {
              this._logger.error("could not go fullscreen", l);
            }
          n();
        };
        this._playButton.addEventListener("click", o), this._playButton.addEventListener("touchend", o), this._playButton.addEventListener("pointerup", o), this.engine && this.engine.input.gamepads.once("button", () => o(new Event("button")));
      });
    }
  }
  hidePlayButton() {
    this._playButtonShown = !1, this._playButton.style.display = "none";
  }
  /**
   * Clean up generated elements for the loader
   */
  dispose() {
    this._playButtonRootElement.parentElement && (this._playButtonRootElement.removeChild(this._playButtonElement), document.body.removeChild(this._playButtonRootElement), document.head.removeChild(this._styleBlock), this._playButtonRootElement = null, this._playButtonElement = null, this._styleBlock = null);
  }
  async onUserAction() {
    var t;
    await xi(200, (t = this.engine) == null ? void 0 : t.clock), this.canvas.flagDirty(), await this.showPlayButton();
  }
  async onBeforeLoad() {
    this.screen.pushResolutionAndViewport(), this.screen.resolution = { width: this.screen.resolution.width, height: this.screen.resolution.height }, this.screen.applyResolutionAndViewport();
    const t = this._image;
    await this._imageLoaded.promise, await (t == null ? void 0 : t.decode());
  }
  // eslint-disable-next-line require-await
  async onAfterLoad() {
    this.screen.popResolutionAndViewport(), this.screen.applyResolutionAndViewport(), this.dispose();
  }
  _positionPlayButton() {
    if (this.engine) {
      const { x: t, y: e, width: i, height: s } = this.engine.canvas.getBoundingClientRect();
      if (this._playButtonRootElement && this._playButtonElement) {
        const n = this._playButtonElement.querySelector("#excalibur-play-text");
        i < 450 ? n.style.display = "none" : n.style.display = "inline-block";
        const o = this._playButton.clientWidth, a = this._playButton.clientHeight;
        this.playButtonPosition ? (this._playButtonRootElement.style.left = `${this.playButtonPosition.x}px`, this._playButtonRootElement.style.top = `${this.playButtonPosition.y}px`) : (this._playButtonRootElement.style.left = `${t + i / 2 - o / 2}px`, this._playButtonRootElement.style.top = `${e + s / 2 - a / 2 + 100}px`), i < 450 && (this._playButtonRootElement.style.left = `${t + i / 2 - o / 2}px`, this._playButtonRootElement.style.top = `${e + s / 2 - a / 2 + 25}px`);
      }
    }
  }
  /**
   * Loader draw function. Draws the default Excalibur loading screen.
   * Override `logo`, `logoWidth`, `logoHeight` and `backgroundColor` properties
   * to customize the drawing, or just override entire method.
   */
  onDraw(t) {
    const e = this.engine.canvasHeight / this.engine.pixelRatio, i = this.engine.canvasWidth / this.engine.pixelRatio;
    t.fillStyle = this.backgroundColor, t.fillRect(0, 0, i, e);
    let s = e / 2;
    const n = Math.min(this.logoWidth, i * 0.75);
    let o = i / 2 - n / 2;
    this.logoPosition && (o = this.logoPosition.x, s = this.logoPosition.y);
    const a = Math.floor(n * (this.logoHeight / this.logoWidth)), h = this.engine.screen.antialiasing;
    if (this.engine.screen.antialiasing = !0, this.logoPosition ? t.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, o, s, n, a) : t.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, o, s - a - 20, n, a), !this.suppressPlayButton && this._playButtonShown) {
      this.engine.screen.antialiasing = h;
      return;
    }
    let l = o, c = s;
    this.loadingBarPosition && (l = this.loadingBarPosition.x, c = this.loadingBarPosition.y), t.lineWidth = 2, is(t, l, c, n, 20, 10, this.loadingBarColor);
    const d = n * this.progress, u = 5, _ = d - u * 2, p = 20 - u * 2;
    is(
      t,
      l + u,
      c + u,
      _ > 10 ? _ : 10,
      p,
      5,
      null,
      this.loadingBarColor
    ), this.engine.screen.antialiasing = h;
  }
};
Ur._DEFAULT_LOADER_OPTIONS = {
  loadables: [],
  fullscreenAfterLoad: !1,
  fullscreenContainer: void 0
};
let as = Ur;
const Js = {
  webgl: "WebGL",
  webaudio: "WebAudio",
  gamepadapi: "Gamepad API"
};
class lh {
  constructor() {
    this._features = null, this.failedTests = [], this._criticalTests = {
      // Test canvas/2d context support
      canvasSupport: function() {
        const t = document.createElement("canvas");
        return !!(t.getContext && t.getContext("2d"));
      },
      // Test array buffer support ex uses for downloading binary data
      arrayBufferSupport: function() {
        const t = new XMLHttpRequest();
        t.open("GET", "/");
        try {
          t.responseType = "arraybuffer";
        } catch (e) {
          return !1;
        }
        return t.responseType === "arraybuffer";
      },
      // Test data urls ex uses for sprites
      dataUrlSupport: function() {
        return document.createElement("canvas").toDataURL("image/png").indexOf("data:image/png") === 0;
      },
      // Test object url support for loading
      objectUrlSupport: function() {
        return "URL" in window && "revokeObjectURL" in URL && "createObjectURL" in URL;
      },
      // RGBA support for colors
      rgbaSupport: function() {
        const t = document.createElement("a").style;
        return t.cssText = "background-color:rgba(150,255,150,.5)", ("" + t.backgroundColor).indexOf("rgba") > -1;
      }
    }, this._warningTest = {
      webAudioSupport: function() {
        return !!(window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext || window.oAudioContext);
      },
      webglSupport: function() {
        const t = document.createElement("canvas");
        return !!(t.getContext && t.getContext("webgl"));
      }
    }, this._features = this._loadBrowserFeatures();
  }
  /**
   * Returns a map of currently supported browser features. This method
   * treats the features as a singleton and will only calculate feature
   * support if it has not previously been done.
   */
  getBrowserFeatures() {
    return this._features === null && (this._features = this._loadBrowserFeatures()), this._features;
  }
  /**
   * Report on non-critical browser support for debugging purposes.
   * Use native browser console colors for visibility.
   */
  logBrowserFeatures() {
    let t = `%cSUPPORTED BROWSER FEATURES
==========================%c
`;
    const e = ["font-weight: bold; color: navy", "font-weight: normal; color: inherit"], i = this.getBrowserFeatures();
    for (const s of Object.keys(Js))
      i[s] ? (t += "(%c%c)", e.push("font-weight: bold; color: green"), e.push("font-weight: normal; color: inherit")) : (t += "(%c%c)", e.push("font-weight: bold; color: red"), e.push("font-weight: normal; color: inherit")), t += " " + Js[s] + `
`;
    e.unshift(t), console.log.apply(console, e);
  }
  /**
   * Executes several IIFE's to get a constant reference to supported
   * features within the current execution context.
   */
  _loadBrowserFeatures() {
    return {
      // IIFE to check canvas support
      canvas: this._criticalTests.canvasSupport(),
      // IIFE to check arraybuffer support
      arraybuffer: this._criticalTests.arrayBufferSupport(),
      // IIFE to check dataurl support
      dataurl: this._criticalTests.dataUrlSupport(),
      // IIFE to check objecturl support
      objecturl: this._criticalTests.objectUrlSupport(),
      // IIFE to check rgba support
      rgba: this._criticalTests.rgbaSupport(),
      // IIFE to check webaudio support
      webaudio: this._warningTest.webAudioSupport(),
      // IIFE to check webgl support
      webgl: this._warningTest.webglSupport(),
      // IIFE to check gamepadapi support
      gamepadapi: !!navigator.getGamepads
    };
  }
  test() {
    let t = !1;
    for (const e in this._criticalTests)
      this._criticalTests[e].call(this) || (this.failedTests.push(e), R.getInstance().error("Critical browser feature missing, Excalibur requires:", e), t = !0);
    if (t)
      return !1;
    for (const e in this._warningTest)
      this._warningTest[e]() || R.getInstance().warn("Warning browser feature missing, Excalibur will have reduced performance:", e);
    return !0;
  }
}
function ch(r) {
  return r instanceof Hr;
}
class Hr extends Dt {
  constructor(t) {
    var e, i;
    super({ ...t }), this.get(P).coordPlane = at.Screen, this.anchor = (e = t == null ? void 0 : t.anchor) != null ? e : w(0, 0), this.body.collisionType = (i = t == null ? void 0 : t.collisionType) != null ? i : E.PreventCollision, this.pointer.useGraphicsBounds = !0, this.pointer.useColliderShape = !1, !(t != null && t.collider) && (t == null ? void 0 : t.width) > 0 && (t == null ? void 0 : t.height) > 0 && this.collider.useBoxCollider(t.width, t.height, this.anchor);
  }
  _initialize(t) {
    this._engine = t, super._initialize(t);
  }
  contains(t, e, i = !0) {
    if (i)
      return super.contains(t, e);
    const s = this._engine.worldToScreenCoordinates(new v(t, e));
    return super.contains(s.x, s.y);
  }
}
const Yl = {
  Start: "start",
  Stop: "stop",
  Pause: "pause",
  Resume: "resume",
  Cancel: "cancel",
  Action: "action",
  Complete: "complete"
}, Or = class Nr {
  constructor(t) {
    this._logger = R.getInstance(), this.id = 0, this.events = new X(), this._elapsedTime = 0, this._totalTimeAlive = 0, this._running = !1, this._numberOfTicks = 0, this.interval = 10, this.repeats = !1, this.maxNumberOfRepeats = -1, this.randomRange = [0, 0], this._baseInterval = 10, this._generateRandomInterval = () => this._baseInterval + this.random.integer(this.randomRange[0], this.randomRange[1]), this._onComplete = () => {
    }, this._complete = !1, this.scene = null;
    var e, i;
    const s = (e = t.action) != null ? e : t.fcn, n = t.interval, o = t.repeats, a = t.numberOfRepeats, h = t.randomRange, l = t.random;
    if (this._onComplete = (i = t.onComplete) != null ? i : this._onComplete, a && a >= 0 && (this.maxNumberOfRepeats = a, !o))
      throw new Error("repeats must be set to true if numberOfRepeats is set");
    if (this.id = Nr._MAX_ID++, this._callbacks = [], this._baseInterval = this.interval = n, h) {
      if (h[0] > h[1])
        throw new Error("min value must be lower than max value for range");
      this.random = l != null ? l : new ge(), this.randomRange = h, this.interval = this._generateRandomInterval(), this.on(() => {
        this.interval = this._generateRandomInterval();
      });
    }
    this.repeats = o || this.repeats, s && this.on(s);
  }
  get complete() {
    return this._complete;
  }
  /**
   * Adds a new callback to be fired after the interval is complete
   * @param action The callback to be added to the callback list, to be fired after the interval is complete.
   */
  on(t) {
    this._callbacks.push(t);
  }
  /**
   * Removes a callback from the callback list to be fired after the interval is complete.
   * @param action The callback to be removed from the callback list, to be fired after the interval is complete.
   */
  off(t) {
    const e = this._callbacks.indexOf(t);
    this._callbacks.splice(e, 1);
  }
  /**
   * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.
   * @param elapsed  Number of elapsed milliseconds since the last update.
   */
  update(t) {
    this._running && (this._totalTimeAlive += t, this._elapsedTime += t, this.maxNumberOfRepeats > -1 && this._numberOfTicks >= this.maxNumberOfRepeats && (this._complete = !0, this._running = !1, this._elapsedTime = 0, this._onComplete(), this.events.emit("complete")), !this.complete && this._elapsedTime >= this.interval && (this._callbacks.forEach((e) => {
      e.call(this);
    }), this._numberOfTicks++, this.events.emit("action"), this.repeats ? this._elapsedTime = 0 : (this._complete = !0, this._running = !1, this._elapsedTime = 0, this._onComplete(), this.events.emit("complete"))));
  }
  /**
   * Resets the timer so that it can be reused, and optionally reconfigure the timers interval.
   *
   * Warning** you may need to call `timer.start()` again if the timer had completed
   * @param newInterval If specified, sets a new non-negative interval in milliseconds to refire the callback
   * @param newNumberOfRepeats If specified, sets a new non-negative upper limit to the number of time this timer executes
   */
  reset(t, e) {
    if (t && t >= 0 && (this._baseInterval = this.interval = t), this.maxNumberOfRepeats && this.maxNumberOfRepeats >= 0 && (this.maxNumberOfRepeats = e, !this.repeats))
      throw new Error("repeats must be set to true if numberOfRepeats is set");
    this._complete = !1, this._elapsedTime = 0, this._numberOfTicks = 0;
  }
  get timesRepeated() {
    return this._numberOfTicks;
  }
  getTimeRunning() {
    return this._totalTimeAlive;
  }
  /**
   * @returns milliseconds until the next action callback, if complete will return 0
   */
  get timeToNextAction() {
    return this.complete ? 0 : this.interval - this._elapsedTime;
  }
  /**
   * @returns milliseconds elapsed toward the next action
   */
  get timeElapsedTowardNextAction() {
    return this._elapsedTime;
  }
  get isRunning() {
    return this._running;
  }
  /**
   * Pauses the timer, time will no longer increment towards the next call
   */
  pause() {
    return this._running = !1, this.events.emit("pause"), this;
  }
  /**
   * Resumes the timer, time will now increment towards the next call.
   */
  resume() {
    return this._running = !0, this.events.emit("resume"), this;
  }
  /**
   * Starts the timer, if the timer was complete it will restart the timer and reset the elapsed time counter
   */
  start() {
    return this.scene || this._logger.warn("Cannot start a timer not part of a scene, timer wont start until added"), this._running = !0, this.complete ? (this._complete = !1, this._elapsedTime = 0, this._numberOfTicks = 0) : this.events.emit("start"), this;
  }
  /**
   * Stops the timer and resets the elapsed time counter towards the next action invocation
   */
  stop() {
    return this._running = !1, this._elapsedTime = 0, this._numberOfTicks = 0, this.events.emit("stop"), this;
  }
  /**
   * Cancels the timer, preventing any further executions.
   */
  cancel() {
    this.pause(), this.scene && (this.scene.cancelTimer(this), this.events.emit("cancel"));
  }
};
Or._MAX_ID = 0;
let Wi = Or;
function Ks(r) {
  return r && r._dispatchPointerEvents && r._processPointerToObject;
}
class dh {
  get events() {
    return this.object.events;
  }
  init(t, e, i) {
    this.object = t, this.contains = e, this.active = i;
  }
}
class Ss {
  constructor() {
    this._proxyPool = new ii(
      () => new dh(),
      (t) => t,
      100
    ), this._objectToProxy = /* @__PURE__ */ new Map(), this._proxies = [], this._lastFrameObjectToPointers = /* @__PURE__ */ new Map(), this._currentFrameObjectToPointers = /* @__PURE__ */ new Map();
  }
  /**
   * Tracks an object to associate with pointers and their events
   * @param object
   * @param contains
   * @param active
   */
  addObject(t, e, i) {
    const s = this._proxyPool.rent(!1);
    s.init(t, e, i), this._proxies.push(s), this._objectToProxy.set(t, s);
  }
  _getProxy(t) {
    const e = this._objectToProxy.get(t);
    if (e)
      return e;
    throw new Error("No PointerTargetProxy for object");
  }
  /**
   * Untracks an object associated with pointers and their events
   * @param object
   */
  removeObject(t) {
    const e = this._objectToProxy.get(t);
    if (e) {
      const i = this._proxies.indexOf(e);
      this._objectToProxy.delete(t), i > -1 && this._proxies.splice(i, 1), this._proxyPool.return(e);
    }
  }
  _objectCurrentlyUnderPointer(t, e) {
    return !!(this._currentFrameObjectToPointers.has(t) && this._currentFrameObjectToPointers.get(t).includes(e));
  }
  _objectWasUnderPointer(t, e) {
    return !!(this._lastFrameObjectToPointers.has(t) && this._lastFrameObjectToPointers.get(t).includes(e));
  }
  _entered(t, e) {
    return this._objectCurrentlyUnderPointer(t, e) && !this._lastFrameObjectToPointers.has(t);
  }
  _left(t, e) {
    return !this._currentFrameObjectToPointers.has(t) && this._objectWasUnderPointer(t, e);
  }
  /**
   * Manually associate a pointer id with an object.
   *
   * This assumes you've checked that the pointer is indeed over the object.
   */
  addPointerToObject(t, e) {
    const i = this._objectToProxy.get(t);
    i && this._addPointerToProxy(i, e);
  }
  _addPointerToProxy(t, e) {
    if (!this._currentFrameObjectToPointers.has(t)) {
      this._currentFrameObjectToPointers.set(t, [e]);
      return;
    }
    const i = this._currentFrameObjectToPointers.get(t);
    this._currentFrameObjectToPointers.set(t, i.concat(e));
  }
  /**
   * Dispatches the appropriate pointer events in sortedObject order on tracked objects
   * @param receiver
   * @param sortedObjects
   */
  dispatchEvents(t, e) {
    const i = new Set(this._lastFrameObjectToPointers.keys()), s = new Set(this._currentFrameObjectToPointers.keys());
    let n, o, a, h = [];
    if (e)
      for (let l = 0; l < e.length; l++) {
        const c = e[l], d = this._getProxy(c);
        h.push(d);
      }
    else {
      const l = new Set(i);
      for (const c of s)
        l.add(c);
      h = Array.from(l);
    }
    for (let l = 0; l < h.length; l++) {
      const c = h[l];
      if (Ks(c.object) && c.object._dispatchPointerEvents(t), i.has(c) || s.has(c)) {
        a = this._processDownAndEmit(t, c), o = this._processUpAndEmit(t, c), n = this._processMoveAndEmit(t, c);
        const d = [...n.values(), ...a.values(), ...o.values()];
        this._processEnterLeaveAndEmit(t, c, d), this._processCancelAndEmit(t, c), this._processWheelAndEmit(t, c);
      }
    }
  }
  /**
   * Given the tracked objects, update pointer containment given the provided contains()
   * @param receiver
   * @param objects
   */
  processPointerToObject(t, e) {
    for (let i = 0; i < e.length; i++) {
      const s = e[i], n = this._getProxy(s);
      Ks(s) && s._processPointerToObject(t);
      for (const [o, a] of t.currentFramePointerCoords.entries())
        n.contains(a) && this._addPointerToProxy(n, o);
    }
  }
  /**
   * Clear current frames pointer-object associations and track last frame pointer-object associations
   */
  clear() {
    this._lastFrameObjectToPointers.clear(), this._lastFrameObjectToPointers = new Map(this._currentFrameObjectToPointers), this._currentFrameObjectToPointers.clear();
  }
  _processDownAndEmit(t, e) {
    const i = /* @__PURE__ */ new Map();
    for (const s of t.currentFrameDown)
      s.active && this._objectCurrentlyUnderPointer(e, s.pointerId) && (e.events.emit("pointerdown", s), t.isDragStart(s.pointerId) && e.events.emit("pointerdragstart", s)), i.set(s.pointerId, s);
    return i;
  }
  _processUpAndEmit(t, e) {
    const i = /* @__PURE__ */ new Map();
    for (const s of t.currentFrameUp)
      s.active && this._objectCurrentlyUnderPointer(e, s.pointerId) && (e.events.emit("pointerup", s), t.isDragEnd(s.pointerId) && e.events.emit("pointerdragend", s)), i.set(s.pointerId, s);
    return i;
  }
  _processMoveAndEmit(t, e) {
    const i = /* @__PURE__ */ new Map();
    for (const s of t.currentFrameMove)
      s.active && e.active() && this._objectCurrentlyUnderPointer(e, s.pointerId) && (e.events.emit("pointermove", s), t.isDragging(s.pointerId) && e.events.emit("pointerdragmove", s)), i.set(s.pointerId, s);
    return i;
  }
  _processEnterLeaveAndEmit(t, e, i) {
    for (const s of i) {
      if (s.active && e.active() && this._entered(e, s.pointerId)) {
        e.events.emit("pointerenter", s), t.isDragging(s.pointerId) && e.events.emit("pointerdragenter", s);
        break;
      }
      if (s.active && e.active() && // leave can happen on move
      (this._left(e, s.pointerId) || // or leave can happen on pointer up
      this._objectCurrentlyUnderPointer(e, s.pointerId) && s.type === "up")) {
        e.events.emit("pointerleave", s), t.isDragging(s.pointerId) && e.events.emit("pointerdragleave", s);
        break;
      }
    }
  }
  _processCancelAndEmit(t, e) {
    for (const i of t.currentFrameCancel)
      i.active && e.active() && this._objectCurrentlyUnderPointer(e, i.pointerId) && e.events.emit("pointercancel", i);
  }
  _processWheelAndEmit(t, e) {
    for (const i of t.currentFrameWheel)
      i.active && e.active() && this._objectCurrentlyUnderPointer(e, 0) && e.events.emit("pointerwheel", i);
  }
}
const Zl = {
  PreUpdate: "preupdate",
  PostUpdate: "postupdate",
  PreDraw: "predraw",
  PostDraw: "postdraw",
  PointerUp: "pointerup",
  PointerDown: "pointerdown",
  PointerMove: "pointermove",
  PointerCancel: "pointercancel"
};
class uh extends Rt {
  /**
   * @param options
   */
  constructor(t) {
    var e, i, s;
    super([], t.name), this.events = new X(), this._token = 0, this.logger = R.getInstance(), this.tiles = [], this._rows = [], this._cols = [], this.renderFromTopOfGraphic = !1, this.meshingLookBehind = 10, this._collidersDirty = !0, this._oldRotation = 0, this._originalOffsets = /* @__PURE__ */ new WeakMap(), this.meshingLookBehind = (e = t.meshingLookBehind) != null ? e : this.meshingLookBehind, this.addComponent(new P()), this.addComponent(new N()), this.addComponent(
      new U({
        type: E.Fixed
      })
    ), this.addComponent(
      new tt({
        onPostDraw: (o, a) => this.draw(o, a)
      })
    ), this.addComponent(new gs((o, a) => this.debug(o, a), !1)), this.addComponent(new it()), this.addComponent(new fe()), this.pointer = this.get(fe), this._graphics = this.get(tt), this.transform = this.get(P), this._motion = this.get(N), this.collider = this.get(it), this._composite = this.collider.useCompositeCollider([]), this.transform.pos = (i = t.pos) != null ? i : v.Zero, this._oldPos = this.transform.pos.clone(), this._oldScale = this.transform.scale.clone(), this.renderFromTopOfGraphic = (s = t.renderFromTopOfGraphic) != null ? s : this.renderFromTopOfGraphic, this.tileWidth = t.tileWidth, this.tileHeight = t.tileHeight, this.rows = t.rows, this.columns = t.columns, this._pointerEventDispatcher = new Ss(), this.tiles = new Array(this.rows * this.columns), this._rows = new Array(this.rows), this._cols = new Array(this.columns);
    let n = [];
    for (let o = 0; o < this.columns; o++) {
      for (let a = 0; a < this.rows; a++) {
        const h = new _h({
          x: o,
          y: a,
          map: this
        });
        h.map = this, this.tiles[o + a * this.columns] = h, this._pointerEventDispatcher.addObject(
          h,
          (l) => h.bounds.contains(l.worldPos),
          () => !0
        ), n.push(h), this._rows[a] || (this._rows[a] = []), this._rows[a].push(h);
      }
      this._cols[o] = n, n = [];
    }
    this._graphics.localBounds = new F({
      left: 0,
      top: 0,
      right: this.columns * this.tileWidth * this.scale.x,
      bottom: this.rows * this.tileHeight * this.scale.y
    });
  }
  flagCollidersDirty() {
    this._collidersDirty = !0;
  }
  flagTilesDirty() {
    for (let t = 0; t < this.tiles.length; t++)
      this.tiles[t] && this.tiles[t].flagDirty();
  }
  get x() {
    var t;
    return (t = this.transform.pos.x) != null ? t : 0;
  }
  set x(t) {
    var e;
    (e = this.transform) != null && e.pos && (this.get(P).pos = w(t, this.y));
  }
  get y() {
    var t, e;
    return (e = (t = this.transform) == null ? void 0 : t.pos.y) != null ? e : 0;
  }
  set y(t) {
    var e;
    (e = this.transform) != null && e.pos && (this.transform.pos = w(this.x, t));
  }
  get z() {
    var t;
    return (t = this.transform.z) != null ? t : 0;
  }
  set z(t) {
    this.transform && (this.transform.z = t);
  }
  get rotation() {
    var t, e;
    return (e = (t = this.transform) == null ? void 0 : t.rotation) != null ? e : 0;
  }
  set rotation(t) {
    this.transform && (t !== this.transform.rotation && (this.flagCollidersDirty(), this.flagTilesDirty()), this.transform.rotation = t);
  }
  get scale() {
    var t, e;
    return (e = (t = this.transform) == null ? void 0 : t.scale) != null ? e : v.One;
  }
  set scale(t) {
    this.transform && (t != null && t.equals(this.transform.scale) || (this.flagCollidersDirty(), this.flagTilesDirty()), this.transform.scale = t);
  }
  get pos() {
    return this.transform.pos;
  }
  set pos(t) {
    this.transform && (t != null && t.equals(this.transform.pos) || (this.flagCollidersDirty(), this.flagTilesDirty()), this.transform.pos = t);
  }
  get vel() {
    return this._motion.vel;
  }
  set vel(t) {
    this._motion.vel = t;
  }
  /**
   * Width of the whole tile map in pixels
   */
  get width() {
    return this.tileWidth * this.columns * this.scale.x;
  }
  /**
   * Height of the whole tilemap in pixels
   */
  get height() {
    return this.tileHeight * this.rows * this.scale.y;
  }
  emit(t, e) {
    this.events.emit(t, e);
  }
  on(t, e) {
    return this.events.on(t, e);
  }
  once(t, e) {
    return this.events.once(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
  _initialize(t) {
    super._initialize(t), this._engine = t;
  }
  _getOrSetColliderOriginalOffset(t) {
    var e;
    if (this._originalOffsets.has(t))
      return (e = this._originalOffsets.get(t)) != null ? e : v.Zero;
    {
      const i = t.offset;
      return this._originalOffsets.set(t, i), i;
    }
  }
  /**
   * Tiles colliders based on the solid tiles in the tilemap.
   */
  _updateColliders() {
    this.collider.$colliderRemoved.notifyAll(this._composite), this._composite.clearColliders();
    const t = [];
    this._composite = this.collider.useCompositeCollider([]);
    let e = null;
    const i = (n, o) => n && o ? n.top === o.top && n.bottom === o.bottom && // Shared right/left edge
    n.right === o.left : !1, s = (n, o, a = this.meshingLookBehind) => {
      if (!n)
        return !1;
      for (let h = o.length - 1; h >= 0; h--) {
        if (a-- < 0)
          return !1;
        const l = o[h];
        if (i(l, n))
          return o[h] = l.combine(n), !0;
      }
      return !1;
    };
    for (let n = 0; n < this.columns; n++) {
      for (let o = 0; o < this.rows; o++) {
        const a = this.tiles[n + o * this.columns];
        if (a.solid)
          if (a.getColliders().length > 0) {
            for (const h of a.getColliders()) {
              const l = this._getOrSetColliderOriginalOffset(h);
              h.offset = w(a.x * this.tileWidth * this.scale.x, a.y * this.tileHeight * this.scale.y).add(l), h.owner = this, this._composite.addCollider(h);
            }
            e && !s(e, t) && t.push(e), e = null;
          } else
            e ? e = e.combine(a.defaultGeometry) : e = a.defaultGeometry;
        else
          e && !s(e, t) && t.push(e), e = null;
      }
      e && !s(e, t) && t.push(e), e = null;
    }
    for (const n of t) {
      const o = _t.Box(n.width, n.height, v.Zero, w(n.left - this.pos.x, n.top - this.pos.y));
      o.owner = this, this._composite.addCollider(o);
    }
    this.collider.update(), this.collider.$colliderAdded.notifyAll(this._composite);
  }
  /**
   * Returns the {@apilink Tile} by index (row major order)
   *
   * Returns null if out of bounds
   */
  getTileByIndex(t) {
    var e;
    return (e = this.tiles[t]) != null ? e : null;
  }
  /**
   * Returns the {@apilink Tile} by its x and y integer coordinates
   *
   * Returns null if out of bounds
   *
   * For example, if I want the tile in fifth column (x), and second row (y):
   * `getTile(4, 1)` 0 based, so 0 is the first in row/column
   */
  getTile(t, e) {
    return t < 0 || e < 0 || t >= this.columns || e >= this.rows ? null : this.tiles[t + e * this.columns];
  }
  /**
   * Returns the {@apilink Tile} by testing a point in world coordinates,
   * returns `null` if no Tile was found.
   */
  getTileByPoint(t) {
    const { x: e, y: i } = this._getTileCoordinates(t), s = this.getTile(e, i);
    return e >= 0 && i >= 0 && e < this.columns && i < this.rows && s ? s : null;
  }
  _getTileCoordinates(t) {
    t = this.transform.applyInverse(t);
    const e = Math.floor(t.x / this.tileWidth), i = Math.floor(t.y / this.tileHeight);
    return { x: e, y: i };
  }
  getRows() {
    return this._rows;
  }
  getColumns() {
    return this._cols;
  }
  /**
   * Returns the on screen tiles for a tilemap, this will overshoot by a small amount because of the internal quad tree data structure.
   *
   * Useful if you need to perform specific logic on onscreen tiles
   */
  getOnScreenTiles() {
    const t = this._engine.screen.getWorldBounds();
    let e = w(0, 0), i = this.transform.coordPlane === at.Screen ? this._engine.screen.getScreenBounds() : t;
    const s = this.get(ps);
    if (s && this.isInitialized) {
      const p = v.One.sub(s.parallaxFactor);
      e = this._engine.currentScene.camera.pos.scale(p), i = i.translate(e.negate());
    }
    const n = this._getTileCoordinates(i.topLeft), o = this._getTileCoordinates(i.topRight), a = this._getTileCoordinates(i.bottomRight), h = this._getTileCoordinates(i.bottomLeft), l = Math.min(D(n.x, 0, this.columns - 1), D(o.x, 0, this.columns - 1)), c = Math.min(D(n.y, 0, this.rows - 1), D(o.y, 0, this.rows - 1)), d = Math.max(D(a.x, 0, this.columns - 1), D(h.x, 0, this.columns - 1)), u = Math.max(D(a.y, 0, this.rows - 1), D(h.y, 0, this.rows - 1)), _ = [];
    for (let p = l; p <= d; p++)
      for (let g = c; g <= u; g++)
        _.push(this.getTile(p, g));
    return _;
  }
  /**
   * @internal
   */
  _processPointerToObject(t) {
    const e = Array.from(t.currentFramePointerCoords.entries());
    for (const [i, s] of e) {
      const n = this.getTileByPoint(this.transform.coordPlane === at.World ? s.worldPos : s.screenPos);
      n && this._pointerEventDispatcher.addPointerToObject(n, i);
    }
  }
  /**
   * @internal
   */
  _dispatchPointerEvents(t) {
    this._pointerEventDispatcher.dispatchEvents(t);
  }
  update(t, e) {
    this._initialize(t), this.onPreUpdate(t, e), this.emit("preupdate", new pe(t, e, this)), (!this._oldPos.equals(this.pos) || this._oldRotation !== this.rotation || !this._oldScale.equals(this.scale)) && (this.flagCollidersDirty(), this.flagTilesDirty()), this._collidersDirty && (this._collidersDirty = !1, this._updateColliders()), this._pointerEventDispatcher.clear(), this._token++, this.pos.clone(this._oldPos), this._oldRotation = this.rotation, this.scale.clone(this._oldScale), this.transform.pos = this.pos, this.onPostUpdate(t, e), this.emit("postupdate", new me(t, e, this));
  }
  /**
   * Draws the tile map to the screen. Called by the {@apilink Scene}.
   * @param ctx ExcaliburGraphicsContext
   * @param elapsed  The number of milliseconds since the last draw
   */
  draw(t, e) {
    if (!this.isInitialized)
      return;
    this.emit("predraw", new Qe(t, e, this));
    let i, s, n;
    const o = this.getOnScreenTiles();
    for (let a = 0; a < o.length; a++) {
      const h = o[a], l = h.getGraphicsOffsets();
      for (i = h.getGraphics(), s = 0, n = i.length; s < n; s++) {
        const c = i[s], d = l[s];
        if (c) {
          Ir(c) && (c == null || c.tick(e, this._token));
          const u = this.renderFromTopOfGraphic ? 0 : c.height - this.tileHeight;
          c.draw(t, h.x * this.tileWidth + d.x, h.y * this.tileHeight - u + d.y);
        }
      }
    }
    this.emit("postdraw", new Je(t, e, this));
  }
  debug(t, e) {
    const {
      showAll: i,
      showGrid: s,
      gridColor: n,
      gridWidth: o,
      showSolidBounds: a,
      solidBoundsColor: h,
      showColliderGeometry: l
    } = e.tilemap, { geometryColor: c, geometryLineWidth: d, geometryPointSize: u } = e.collider, _ = this.tileWidth * this.columns * this.scale.x, p = this.tileHeight * this.rows * this.scale.y, g = this.pos;
    if (s || i) {
      for (let x = 0; x < this.rows + 1; x++) {
        const m = w(0, x * this.tileHeight * this.scale.y);
        t.debug.drawLine(g.add(m), g.add(w(_, m.y)), { color: n, lineWidth: o });
      }
      for (let x = 0; x < this.columns + 1; x++) {
        const m = w(x * this.tileWidth * this.scale.x, 0);
        t.debug.drawLine(g.add(m), g.add(w(m.x, p)), { color: n, lineWidth: o });
      }
    }
    if (i || a || l) {
      const x = this._composite.getColliders();
      t.save(), t.translate(this.pos.x, this.pos.y), t.scale(this.scale.x, this.scale.y);
      for (const m of x) {
        const f = m.localBounds, b = m.worldPos.sub(this.pos);
        a && t.debug.drawRect(b.x, b.y, f.width, f.height, { color: h });
      }
      if (t.restore(), l)
        for (const m of x)
          m.debug(t, c, { lineWidth: d, pointSize: u });
    }
    if (i || a) {
      if (t.save(), t.z = 999, a)
        for (let x = 0; x < this.tiles.length; x++)
          this.tiles[x].bounds.debug(t);
      t.restore();
    }
  }
}
class _h {
  constructor(t) {
    this._posDirty = !1, this.events = new X(), this._solid = !1, this._graphics = [], this._offsets = [], this._colliders = [], this.data = /* @__PURE__ */ new Map();
    var e, i;
    this.x = t.x, this.y = t.y, this.map = t.map, this._width = t.map.tileWidth * this.map.scale.x, this._height = t.map.tileHeight * this.map.scale.y, this.solid = (e = t.solid) != null ? e : this.solid, this._graphics = (i = t.graphics) != null ? i : [], this._recalculate();
  }
  /**
   * Return the world position of the top left corner of the tile
   */
  get pos() {
    return this._posDirty && (this._recalculate(), this._posDirty = !1), this._pos;
  }
  /**
   * Width of the tile in pixels
   */
  get width() {
    return this._width;
  }
  /**
   * Height of the tile in pixels
   */
  get height() {
    return this._height;
  }
  /**
   * Wether this tile should be treated as solid by the tilemap
   */
  get solid() {
    return this._solid;
  }
  /**
   * Wether this tile should be treated as solid by the tilemap
   */
  set solid(t) {
    var e;
    (e = this.map) == null || e.flagCollidersDirty(), this._solid = t;
  }
  /**
   * Current list of graphics for this tile
   */
  getGraphics() {
    return this._graphics;
  }
  /**
   * Current list of offsets for this tile's graphics
   */
  getGraphicsOffsets() {
    return this._offsets;
  }
  /**
   * Add another {@apilink Graphic} to this TileMap tile
   * @param graphic
   */
  addGraphic(t, e) {
    this._graphics.push(t), e != null && e.offset ? this._offsets.push(e.offset) : this._offsets.push(v.Zero);
  }
  /**
   * Remove an instance of a {@apilink Graphic} from this tile
   */
  removeGraphic(t) {
    const e = this._graphics.indexOf(t);
    e > -1 && (this._graphics.splice(e, 1), this._offsets.splice(e, 1));
  }
  /**
   * Clear all graphics from this tile
   */
  clearGraphics() {
    this._graphics.length = 0, this._offsets.length = 0;
  }
  /**
   * Returns the list of colliders
   */
  getColliders() {
    return this._colliders;
  }
  /**
   * Adds a custom collider to the {@apilink Tile} to use instead of it's bounds
   *
   * If no collider is set but {@apilink Tile.solid} is set, the tile bounds are used as a collider.
   *
   * **Note!** the {@apilink Tile.solid} must be set to true for it to act as a "fixed" collider
   * @param collider
   */
  addCollider(t) {
    this._colliders.push(t), this.map.flagCollidersDirty();
  }
  /**
   * Removes a collider from the {@apilink Tile}
   * @param collider
   */
  removeCollider(t) {
    const e = this._colliders.indexOf(t);
    e > -1 && this._colliders.splice(e, 1), this.map.flagCollidersDirty();
  }
  /**
   * Clears all colliders from the {@apilink Tile}
   */
  clearColliders() {
    this._colliders.length = 0, this.map.flagCollidersDirty();
  }
  flagDirty() {
    this._posDirty = !0;
  }
  _recalculate() {
    const t = this.map.pos.add(w(this.x * this.map.tileWidth, this.y * this.map.tileHeight));
    this._geometry = new F(t.x, t.y, t.x + this.map.tileWidth, t.y + this.map.tileHeight), this._width = this.map.tileWidth * this.map.scale.x, this._height = this.map.tileHeight * this.map.scale.y, this._pos = this.map.pos.add(w(this.x * this._width, this.y * this._height)), this._bounds = new F(this._pos.x, this._pos.y, this._pos.x + this._width, this._pos.y + this._height), this.map.rotation && (this._bounds = this._bounds.rotate(this.map.rotation, this.map.pos)), this._posDirty = !1;
  }
  /**
   * Tile bounds in world space
   */
  get bounds() {
    return this._posDirty && this._recalculate(), this._bounds;
  }
  get defaultGeometry() {
    return this._geometry;
  }
  /**
   * Tile position in world space
   */
  get center() {
    return this._posDirty && this._recalculate(), new v(this._pos.x + this._width / 2, this._pos.y + this._height / 2);
  }
  emit(t, e) {
    this.events.emit(t, e);
  }
  on(t, e) {
    return this.events.on(t, e);
  }
  once(t, e) {
    return this.events.once(t, e);
  }
  off(t, e) {
    e ? this.events.off(t, e) : this.events.off(t);
  }
}
class Ci extends kt {
  /**
   * Specify the isometric map to use to position this entity's z-index
   * @param mapOrOptions
   */
  constructor(t) {
    super(), this.elevation = 0, this.columns = t.columns, this.rows = t.rows, this.tileWidth = t.tileWidth, this.tileHeight = t.tileHeight;
  }
}
class fh extends Rt {
  /**
   * Construct a new IsometricTile
   * @param x tile coordinate in x (not world position)
   * @param y tile coordinate in y (not world position)
   * @param graphicsOffset offset that tile should be shifted by (default (0, 0))
   * @param map reference to owning IsometricMap
   */
  constructor(t, e, i, s) {
    super([
      new P(),
      new tt({
        offset: i != null ? i : v.Zero,
        onPostDraw: (u, _) => this.draw(u, _)
      }),
      new Ci(s)
    ]), this.solid = !1, this.events = new X(), this._tileBounds = new F(), this._graphics = [], this._colliders = [], this.data = /* @__PURE__ */ new Map(), this.x = t, this.y = e, this.map = s, this._transform = this.get(P), this._isometricEntityComponent = this.get(Ci);
    const n = this.map.tileWidth / 2, o = this.map.tileHeight / 2, a = (this.x - this.y) * n, h = (this.x + this.y) * o;
    this._transform.pos = w(a, h), this._isometricEntityComponent.elevation = s.elevation, this._gfx = this.get(tt), this._gfx.isVisible = !1;
    const l = this.map.tileWidth, c = this.map.tileHeight, d = w(0, this.map.renderFromTopOfGraphic ? c : 0);
    this._gfx.localBounds = this._tileBounds = new F({
      left: -l / 2,
      top: -c,
      right: l / 2,
      bottom: c
    }).translate(d);
  }
  getGraphics() {
    return this._graphics;
  }
  /**
   * Tile graphics
   */
  addGraphic(t, e) {
    this._graphics.push(t), this._gfx.isVisible = this.map.isVisible, this._gfx.opacity = this.map.opacity, e != null && e.offset && (this._gfx.offset = e.offset), this._gfx.localBounds = this._recalculateBounds();
  }
  _recalculateBounds() {
    let t = this._tileBounds.clone();
    for (const e of this._graphics) {
      const i = w(
        this.map.graphicsOffset.x - this.map.tileWidth / 2,
        this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : e.height - this.map.tileHeight)
      );
      t = t.combine(e.localBounds.translate(i));
    }
    return t;
  }
  removeGraphic(t) {
    const e = this._graphics.indexOf(t);
    e > -1 && this._graphics.splice(e, 1), this._gfx.localBounds = this._recalculateBounds();
  }
  clearGraphics() {
    this._graphics.length = 0, this._gfx.isVisible = !1, this._gfx.localBounds = this._recalculateBounds();
  }
  getColliders() {
    return this._colliders;
  }
  /**
   * Adds a collider to the IsometricTile
   *
   * **Note!** the {@apilink Tile.solid} must be set to true for it to act as a "fixed" collider
   * @param collider
   */
  addCollider(t) {
    this._colliders.push(t), this.map.flagCollidersDirty();
  }
  /**
   * Removes a collider from the IsometricTile
   * @param collider
   */
  removeCollider(t) {
    const e = this._colliders.indexOf(t);
    e > -1 && this._colliders.splice(e, 1), this.map.flagCollidersDirty();
  }
  /**
   * Clears all colliders from the IsometricTile
   */
  clearColliders() {
    this._colliders.length = 0, this.map.flagCollidersDirty();
  }
  /**
   * Returns the top left corner of the {@apilink IsometricTile} in world space
   */
  get pos() {
    return this.map.tileToWorld(w(this.x, this.y));
  }
  /**
   * Returns the center of the {@apilink IsometricTile}
   */
  get center() {
    return this.pos.add(w(0, this.map.tileHeight / 2));
  }
  draw(t, e) {
    const i = this.map.tileWidth / 2;
    t.save(), t.translate(-i, 0);
    for (const s of this._graphics)
      s.draw(
        t,
        this.map.graphicsOffset.x,
        this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : s.height - this.map.tileHeight)
      );
    t.restore();
  }
}
class jl extends Rt {
  constructor(t) {
    super(
      [
        new P(),
        new U({
          type: E.Fixed
        }),
        new it(),
        new fe(),
        new gs((c, d) => this.debug(c, d), !1)
      ],
      t.name
    ), this.elevation = 0, this.isVisible = !0, this.opacity = 1, this.renderFromTopOfGraphic = !1, this.graphicsOffset = w(0, 0), this._collidersDirty = !1, this._originalOffsets = /* @__PURE__ */ new WeakMap();
    const { pos: e, tileWidth: i, tileHeight: s, columns: n, rows: o, renderFromTopOfGraphic: a, graphicsOffset: h, elevation: l } = t;
    this.transform = this.get(P), e && (this.transform.pos = e), this.collider = this.get(it), this.collider && this.collider.set(this._composite = new ht([])), this.pointer = this.get(fe), this.renderFromTopOfGraphic = a != null ? a : this.renderFromTopOfGraphic, this.graphicsOffset = h != null ? h : this.graphicsOffset, this.elevation = l != null ? l : this.elevation, this.tileWidth = i, this.tileHeight = s, this.columns = n, this.rows = o, this._pointerEventDispatcher = new Ss(), this.tiles = new Array(n * o);
    for (let c = 0; c < o; c++)
      for (let d = 0; d < n; d++) {
        const u = new fh(d, c, this.graphicsOffset, this);
        this.tiles[d + c * n] = u, this.addChild(u), this._pointerEventDispatcher.addObject(
          u,
          (_) => this.getTileByPoint(_.worldPos) === u,
          () => !0
        );
      }
    this.pointer.localBounds = F.fromDimension(
      i * n * this.transform.scale.x,
      s * o * this.transform.scale.y,
      w(0.5, 0)
    );
  }
  /**
   * Whether tiles should be visible
   * @deprecated use isVisible
   */
  get visible() {
    return this.isVisible;
  }
  /**
   * Whether tiles should be visible
   * @deprecated use isVisible
   */
  set visible(t) {
    this.isVisible = t;
  }
  /**
   * @internal
   */
  _processPointerToObject(t) {
    const e = Array.from(t.currentFramePointerCoords.entries());
    for (const [i, s] of e) {
      const n = this.getTileByPoint(this.transform.coordPlane === at.World ? s.worldPos : s.screenPos);
      n && this._pointerEventDispatcher.addPointerToObject(n, i);
    }
  }
  /**
   * @internal
   */
  _dispatchPointerEvents(t) {
    this._pointerEventDispatcher.dispatchEvents(t, this.tiles);
  }
  update() {
    this._collidersDirty && (this.updateColliders(), this._collidersDirty = !1), this._pointerEventDispatcher.clear();
  }
  flagCollidersDirty() {
    this._collidersDirty = !0;
  }
  _getOrSetColliderOriginalOffset(t) {
    var e;
    if (this._originalOffsets.has(t))
      return (e = this._originalOffsets.get(t)) != null ? e : v.Zero;
    {
      const i = t.offset;
      return this._originalOffsets.set(t, i), i;
    }
  }
  updateColliders() {
    this._composite.clearColliders();
    const t = this.get(P).pos;
    for (const e of this.tiles)
      if (e.solid)
        for (const i of e.getColliders()) {
          const s = this._getOrSetColliderOriginalOffset(i);
          i.offset = this.tileToWorld(w(e.x, e.y)).sub(t).add(s).sub(w(this.tileWidth / 2, this.tileHeight)), i.owner = this, this._composite.addCollider(i);
        }
    this.collider.update();
  }
  /**
   * Convert world space coordinates to the tile x, y coordinate
   * @param worldCoordinate
   */
  worldToTile(t) {
    t = t.sub(this.transform.globalPos);
    const e = this.tileWidth / 2, i = this.tileHeight / 2;
    return w(
      ~~((t.x / e + t.y / i) / 2),
      ~~((t.y / i - t.x / e) / 2)
    );
  }
  /**
   * Given a tile coordinate, return the top left corner in world space
   * @param tileCoordinate
   */
  tileToWorld(t) {
    const e = this.tileWidth / 2, i = this.tileHeight / 2, s = (t.x - t.y) * e, n = (t.x + t.y) * i;
    return w(s, n).add(this.transform.pos);
  }
  /**
   * Returns the {@apilink IsometricTile} by its x and y coordinates
   */
  getTile(t, e) {
    return t < 0 || e < 0 || t >= this.columns || e >= this.rows ? null : this.tiles[t + e * this.columns];
  }
  /**
   * Returns the {@apilink IsometricTile} by testing a point in world coordinates,
   * returns `null` if no Tile was found.
   */
  getTileByPoint(t) {
    const e = this.worldToTile(t);
    return this.getTile(e.x, e.y);
  }
  _getMaxZIndex() {
    let t = Number.NEGATIVE_INFINITY;
    for (const e of this.tiles) {
      const i = e.get(P).z;
      i > t && (t = i);
    }
    return t;
  }
  /**
   * Debug draw for IsometricMap, called internally by excalibur when debug mode is toggled on
   * @param gfx
   */
  debug(t, e) {
    const { showAll: i, showPosition: s, positionColor: n, positionSize: o, showGrid: a, gridColor: h, gridWidth: l, showColliderGeometry: c } = e.isometric, { geometryColor: d, geometryLineWidth: u, geometryPointSize: _ } = e.collider;
    if (t.save(), t.z = this._getMaxZIndex() + 0.5, i || a) {
      for (let p = 0; p < this.rows + 1; p++) {
        const g = this.tileToWorld(w(0, p)), x = this.tileToWorld(w(this.columns, p));
        t.debug.drawLine(g, x, { color: h, lineWidth: l });
      }
      for (let p = 0; p < this.columns + 1; p++) {
        const g = this.tileToWorld(w(p, 0)), x = this.tileToWorld(w(p, this.rows));
        t.debug.drawLine(g, x, { color: h, lineWidth: l });
      }
    }
    if (i || s)
      for (const p of this.tiles)
        t.debug.drawCircle(this.tileToWorld(w(p.x, p.y)), o, n);
    if (i || c) {
      for (const p of this.tiles)
        if (p.solid)
          for (const g of p.getColliders())
            g.debug(t, d, { lineWidth: u, pointSize: _ });
    }
    t.restore();
  }
}
class Wr extends Ft {
  constructor(t) {
    super(), this.world = t, this.systemType = Mt.Update, this.query = this.world.query([P, Ci]);
  }
  update() {
    let t, e;
    for (let i = 0; i < this.query.entities.length; i++) {
      const s = this.query.entities[i];
      t = s.get(P), e = s.get(Ci);
      const o = Math.max(e.columns * e.tileWidth, e.rows * e.tileHeight) * e.elevation + t.pos.y;
      t.z = o;
    }
  }
}
Wr.priority = Kt.Lower;
class gh {
  constructor(t) {
    this.camera = t;
  }
  /**
   * Creates and adds the {@apilink LockCameraToActorStrategy} on the current camera.
   * @param actor The actor to lock the camera to
   */
  lockToActor(t) {
    this.camera.addStrategy(new mh(t));
  }
  /**
   * Creates and adds the {@apilink LockCameraToActorAxisStrategy} on the current camera
   * @param actor The actor to lock the camera to
   * @param axis The axis to follow the actor on
   */
  lockToActorAxis(t, e) {
    this.camera.addStrategy(new xh(t, e));
  }
  /**
   * Creates and adds the {@apilink ElasticToActorStrategy} on the current camera
   * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
   * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over
   * correct and bounce around the target
   * @param actor Target actor to elastically follow
   * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
   * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
   */
  elasticToActor(t, e, i) {
    this.camera.addStrategy(new vh(t, e, i));
  }
  /**
   * Creates and adds the {@apilink RadiusAroundActorStrategy} on the current camera
   * @param actor Target actor to follow when it is "radius" pixels away
   * @param radius Number of pixels away before the camera will follow
   */
  radiusAroundActor(t, e) {
    this.camera.addStrategy(new wh(t, e));
  }
  /**
   * Creates and adds the {@apilink LimitCameraBoundsStrategy} on the current camera
   * @param box The bounding box to limit the camera to.
   */
  limitCameraBounds(t) {
    this.camera.addStrategy(new bh(t));
  }
}
var ph = /* @__PURE__ */ ((r) => (r[r.X = 0] = "X", r[r.Y = 1] = "Y", r))(ph || {});
class mh {
  constructor(t) {
    this.target = t, this.action = (e, i, s, n) => e.center;
  }
}
class xh {
  constructor(t, e) {
    this.target = t, this.axis = e, this.action = (i, s, n, o) => {
      const a = i.center, h = s.getFocus();
      return this.axis === 0 ? new v(a.x, h.y) : new v(h.x, a.y);
    };
  }
}
class vh {
  /**
   * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
   * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over
   * correct and bounce around the target
   * @param target Target actor to elastically follow
   * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
   * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
   */
  constructor(t, e, i) {
    this.target = t, this.cameraElasticity = e, this.cameraFriction = i, this.action = (s, n, o, a) => {
      const h = s.center;
      let l = n.getFocus(), c = n.vel.clone();
      const d = h.sub(l).scale(this.cameraElasticity);
      c = c.add(d);
      const u = c.scale(-1).scale(this.cameraFriction);
      return c = c.add(u), l = l.add(c), l;
    };
  }
}
class wh {
  /**
   *
   * @param target Target actor to follow when it is "radius" pixels away
   * @param radius Number of pixels away before the camera will follow
   */
  constructor(t, e) {
    this.target = t, this.radius = e, this.action = (i, s, n, o) => {
      const a = i.center, h = s.getFocus(), l = a.sub(h), c = l.magnitude;
      if (c >= this.radius) {
        const d = c - this.radius;
        return h.add(l.normalize().scale(d));
      }
      return h;
    };
  }
}
class bh {
  // Check and warn only once
  constructor(t) {
    this.target = t, this.boundSizeChecked = !1, this.action = (e, i, s, n) => {
      const o = i.getFocus();
      this.boundSizeChecked || ((e.bottom - e.top < s.drawHeight || e.right - e.left < s.drawWidth) && R.getInstance().warn("Camera bounds should not be smaller than the engine viewport"), this.boundSizeChecked = !0);
      let a = o.x, h = o.y;
      return o.x < e.left + s.halfDrawWidth ? a = e.left + s.halfDrawWidth : o.x > e.right - s.halfDrawWidth && (a = e.right - s.halfDrawWidth), o.y < e.top + s.halfDrawHeight ? h = e.top + s.halfDrawHeight : o.y > e.bottom - s.halfDrawHeight && (h = e.bottom - s.halfDrawHeight), w(a, h);
    };
  }
}
const Ql = {
  Initialize: "initialize",
  PreUpdate: "preupdate",
  PostUpdate: "postupdate"
};
class yh {
  constructor() {
    this.events = new X(), this.transform = j.identity(), this.inverse = j.identity(), this._cameraStrategies = [], this.strategy = new gh(this), this._z = 1, this.dz = 0, this.az = 0, this.rotation = 0, this._angularVelocity = 0, this._posChanged = !1, this._pos = new se(v.Zero, () => {
      this._posChanged = !0;
    }), this.drawPos = this.pos.clone(), this._oldPos = this.pos.clone(), this.vel = v.Zero, this.acc = v.Zero, this._cameraMoving = !1, this._currentLerpTime = 0, this._lerpDuration = 1e3, this._lerpStart = null, this._lerpEnd = null, this._isShaking = !1, this._shakeMagnitudeX = 0, this._shakeMagnitudeY = 0, this._shakeDuration = 0, this._elapsedShakeTime = 0, this._xShake = 0, this._yShake = 0, this._isZooming = !1, this._zoomStart = 1, this._zoomEnd = 1, this._currentZoomTime = 0, this._zoomDuration = 0, this._legacyZoomEasing = It.EaseInOutCubic, this._useLegacyZoom = !1, this._zoomEasing = Hs, this._legacyEasing = It.EaseInOutCubic, this._useLegacyEasing = !1, this._easing = Hs, this._halfWidth = 0, this._halfHeight = 0, this._viewport = null, this._isInitialized = !1, this._snapPos = w(0, 0);
  }
  get strategies() {
    return this._cameraStrategies;
  }
  get zoom() {
    return this._z;
  }
  set zoom(t) {
    this._z = t, this._engine && (this._halfWidth = this._engine.halfDrawWidth, this._halfHeight = this._engine.halfDrawHeight);
  }
  /**
   * Get or set the camera's angular velocity
   */
  get angularVelocity() {
    return this._angularVelocity;
  }
  set angularVelocity(t) {
    this._angularVelocity = t;
  }
  /**
   * Get or set the camera's position
   */
  get pos() {
    return this._pos;
  }
  set pos(t) {
    this._posChanged = !0, this._pos = new se(t, () => {
      this._posChanged = !0;
    });
  }
  /**
   * Has the position changed since the last update
   */
  hasChanged() {
    return this._posChanged;
  }
  /**
   * Get the camera's x position
   */
  get x() {
    return this.pos.x;
  }
  /**
   * Set the camera's x position (cannot be set when following an {@apilink Actor} or when moving)
   */
  set x(t) {
    !this._follow && !this._cameraMoving && (this.pos = w(t, this.pos.y));
  }
  /**
   * Get the camera's y position
   */
  get y() {
    return this.pos.y;
  }
  /**
   * Set the camera's y position (cannot be set when following an {@apilink Actor} or when moving)
   */
  set y(t) {
    !this._follow && !this._cameraMoving && (this.pos = w(this.pos.x, t));
  }
  /**
   * Get or set the camera's x velocity
   */
  get dx() {
    return this.vel.x;
  }
  set dx(t) {
    this.vel = w(t, this.vel.y);
  }
  /**
   * Get or set the camera's y velocity
   */
  get dy() {
    return this.vel.y;
  }
  set dy(t) {
    this.vel = w(this.vel.x, t);
  }
  /**
   * Get or set the camera's x acceleration
   */
  get ax() {
    return this.acc.x;
  }
  set ax(t) {
    this.acc = w(t, this.acc.y);
  }
  /**
   * Get or set the camera's y acceleration
   */
  get ay() {
    return this.acc.y;
  }
  set ay(t) {
    this.acc = w(this.acc.x, t);
  }
  /**
   * Returns the focal point of the camera, a new point giving the x and y position of the camera
   */
  getFocus() {
    return this.pos;
  }
  /**
   * This moves the camera focal point to the specified position using specified easing function. Cannot move when following an Actor.
   * @param pos The target position to move to
   * @param duration The duration in milliseconds the move should last
   * @param [easingFn] An optional easing function ({@apilink EasingFunctions.EaseInOutCubic} by default)
   * @returns A {@apilink Promise} that resolves when movement is finished, including if it's interrupted.
   *          The {@apilink Promise} value is the {@apilink Vector} of the target position. It will be rejected if a move cannot be made.
   */
  move(t, e, i = It.EaseInOutCubic) {
    if (typeof i != "function")
      throw "Please specify an EasingFunction";
    return this._follow ? Promise.reject(t) : (this._lerpPromise && this._lerpResolve && this._lerpResolve(t), this._lerpPromise = new Promise((s) => {
      this._lerpResolve = s;
    }), this._lerpStart = this.getFocus().clone(), this._lerpDuration = e, this._lerpEnd = t, this._currentLerpTime = 0, this._cameraMoving = !0, Fe(i) ? this._legacyEasing = i : this._easing = i, this._lerpPromise);
  }
  /**
   * Sets the camera to shake at the specified magnitudes for the specified duration
   * @param magnitudeX  The x magnitude of the shake
   * @param magnitudeY  The y magnitude of the shake
   * @param duration    The duration of the shake in milliseconds
   */
  shake(t, e, i) {
    this._isShaking = !0, this._shakeMagnitudeX = t, this._shakeMagnitudeY = e, this._shakeDuration = i;
  }
  /**
   * Zooms the camera in or out by the specified scale over the specified duration.
   * If no duration is specified, it take effect immediately.
   * @param scale    The scale of the zoom
   * @param duration The duration of the zoom in milliseconds
   */
  zoomOverTime(t, e = 0, i = It.EaseInOutCubic) {
    if (this._zoomPromise = new Promise((s) => {
      this._zoomResolve = s;
    }), e)
      this._isZooming = !0, Fe(i) ? this._legacyZoomEasing = i : this._easing = i, this._currentZoomTime = 0, this._zoomDuration = e, this._zoomStart = this.zoom, this._zoomEnd = t;
    else
      return this._isZooming = !1, this.zoom = t, Promise.resolve(!0);
    return this._zoomPromise;
  }
  /**
   * Gets the bounding box of the viewport of this camera in world coordinates
   */
  get viewport() {
    return this._viewport ? this._viewport : new F(0, 0, 0, 0);
  }
  /**
   * Adds one or more new camera strategies to this camera
   * @param cameraStrategy Instance of an {@apilink CameraStrategy}
   */
  addStrategy(...t) {
    this._cameraStrategies.push(...t);
  }
  /**
   * Sets the strategies of this camera, replacing all existing strategies
   * @param cameraStrategies Array of {@apilink CameraStrategy}
   */
  setStrategies(t) {
    this._cameraStrategies = [...t];
  }
  /**
   * Removes a camera strategy by reference
   * @param cameraStrategy Instance of an {@apilink CameraStrategy}
   */
  removeStrategy(t) {
    ke(t, this._cameraStrategies);
  }
  /**
   * Clears all camera strategies from the camera
   */
  clearAllStrategies() {
    this._cameraStrategies.length = 0;
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _preupdate handler for {@apilink onPreUpdate} lifecycle event
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   * @internal
   */
  _preupdate(t, e) {
    this.events.emit("preupdate", new pe(t, e, this)), this.onPreUpdate(t, e);
  }
  /**
   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
   *
   * `onPreUpdate` is called directly before a scene is updated.
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   */
  onPreUpdate(t, e) {
  }
  /**
   *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _preupdate handler for {@apilink onPostUpdate} lifecycle event
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   * @internal
   */
  _postupdate(t, e) {
    this.events.emit("postupdate", new me(t, e, this)), this.onPostUpdate(t, e);
  }
  /**
   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
   *
   * `onPostUpdate` is called directly after a scene is updated.
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   */
  onPostUpdate(t, e) {
  }
  get isInitialized() {
    return this._isInitialized;
  }
  _initialize(t) {
    if (!this.isInitialized) {
      this._engine = t, this._screen = t.screen;
      const e = this._screen.contentArea;
      let i = w(e.width / 2, e.height / 2);
      if (!this._engine.loadingComplete) {
        const s = this._screen.peekResolution();
        s && (i = w(s.width / 2, s.height / 2));
      }
      this._halfWidth = i.x, this._halfHeight = i.y, this._posChanged || (this.pos = i), this.pos.clone(this.drawPos), this.updateTransform(this.pos), this.runStrategies(t, t.clock.elapsed()), this.updateViewport(), this.updateTransform(this.pos), this.pos.clone(this._oldPos), this.onInitialize(t), this.events.emit("initialize", new Ke(t, this)), this._isInitialized = !0;
    }
  }
  /**
   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
   *
   * `onPostUpdate` is called directly after a scene is updated.
   */
  onInitialize(t) {
  }
  emit(t, e) {
    this.events.emit(t, e);
  }
  on(t, e) {
    return this.events.on(t, e);
  }
  once(t, e) {
    return this.events.once(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
  runStrategies(t, e) {
    for (const i of this._cameraStrategies)
      this.pos = i.action.call(i, i.target, this, t, e);
  }
  updateViewport() {
    this._viewport = new F(
      this.x - this._halfWidth,
      this.y - this._halfHeight,
      this.x + this._halfWidth,
      this.y + this._halfHeight
    );
  }
  update(t, e) {
    if (this._initialize(t), this._preupdate(t, e), this.pos.clone(this._oldPos), this.pos = this.pos.add(this.vel.scale(e / 1e3)), this.zoom += this.dz * e / 1e3, this.vel = this.vel.add(this.acc.scale(e / 1e3)), this.dz += this.az * e / 1e3, this.rotation += this.angularVelocity * e / 1e3, this._isZooming)
      if (this._currentZoomTime < this._zoomDuration) {
        let i = this.zoom;
        if (this._useLegacyZoom) {
          const s = this._legacyZoomEasing;
          i = s(this._currentZoomTime, this._zoomStart, this._zoomEnd, this._zoomDuration);
        } else
          i = ot(this._zoomStart, this._zoomEnd, this._zoomEasing(this._currentZoomTime / this._zoomDuration));
        this.zoom = i, this._currentZoomTime += e;
      } else
        this._isZooming = !1, this.zoom = this._zoomEnd, this._currentZoomTime = 0, this._zoomResolve(!0);
    if (this._cameraMoving)
      if (this._currentLerpTime < this._lerpDuration) {
        let i = this.pos;
        this._useLegacyEasing ? i = It.CreateVectorEasingFunction(this._legacyEasing)(this._currentLerpTime, this._lerpStart, this._lerpEnd, this._lerpDuration) : (i.x = ot(this._lerpStart.x, this._lerpEnd.x, this._easing(this._currentLerpTime / this._lerpDuration)), i.y = ot(this._lerpStart.y, this._lerpEnd.y, this._easing(this._currentLerpTime / this._lerpDuration))), this.pos = i, this._currentLerpTime += e;
      } else {
        this.pos = this._lerpEnd;
        const i = this._lerpEnd.clone();
        this._lerpStart = null, this._lerpEnd = null, this._currentLerpTime = 0, this._cameraMoving = !1, this._lerpResolve(i);
      }
    this._isDoneShaking() ? (this._isShaking = !1, this._elapsedShakeTime = 0, this._shakeMagnitudeX = 0, this._shakeMagnitudeY = 0, this._shakeDuration = 0, this._xShake = 0, this._yShake = 0) : (this._elapsedShakeTime += e, this._xShake = (Math.random() * this._shakeMagnitudeX | 0) + 1, this._yShake = (Math.random() * this._shakeMagnitudeY | 0) + 1), this.runStrategies(t, e), this.updateViewport(), this.updateTransform(this.pos), this._postupdate(t, e), this._posChanged = !1;
  }
  /**
   * Applies the relevant transformations to the game canvas to "move" or apply effects to the Camera
   * @param ctx Canvas context to apply transformations
   */
  draw(t) {
    if (this.pos.clone(this.drawPos), this._engine.fixedUpdateTimestep) {
      const e = this._engine.currentFrameLagMs / this._engine.fixedUpdateTimestep, i = this.pos.scale(e).add(this._oldPos.scale(1 - e));
      i.clone(this.drawPos), this.updateTransform(i);
    }
    if (t.snapToPixel) {
      const e = this.drawPos.clone(this._snapPos);
      e.x = ~~(e.x + M * q(e.x)), e.y = ~~(e.y + M * q(e.y)), e.clone(this.drawPos), this.updateTransform(e);
    }
    t.multiply(this.transform);
  }
  updateTransform(t) {
    const e = this._screen.resolution.width / this.zoom, i = this._screen.resolution.height / this.zoom, s = w(-t.x + e / 2 + this._xShake, -t.y + i / 2 + this._yShake);
    this.transform.reset(), this.transform.scale(this.zoom, this.zoom), this.transform.translate(e / 2, i / 2), this.transform.rotate(this.rotation), this.transform.translate(-e / 2, -i / 2), this.transform.translate(s.x, s.y), this.transform.inverse(this.inverse);
  }
  _isDoneShaking() {
    return !this._isShaking || this._elapsedShakeTime >= this._shakeDuration;
  }
}
const Jl = {
  ExitTrigger: "exit",
  EnterTrigger: "enter"
};
class Ch extends Dt {
  /**
   * @param options Trigger options
   */
  constructor(t) {
    var e, i, s, n;
    super({ ...t }), this.events = new X(), this.filter = (e = t.filter) != null ? e : () => !0, this.repeat = (i = t.repeat) != null ? i : -1, this.action = (s = t.action) != null ? s : () => {
    }, this.target = t.target, this.graphics.isVisible = (n = t.visible) != null ? n : !1, this.body.collisionType = E.Passive, this.events.on("collisionstart", ({ other: o }) => {
      this._matchesTarget(o.owner) && (this.events.emit("enter", new Hn(this, o.owner)), this._dispatchAction(o.owner), this.repeat === 0 && this.kill());
    }), this.events.on("collisionend", ({ other: o }) => {
      this._matchesTarget(o.owner) && this.events.emit("exit", new On(this, o.owner));
    });
  }
  _matchesTarget(t) {
    return this.filter(t) && (this.target === void 0 || this.target === t);
  }
  _dispatchAction(t) {
    this.repeat !== 0 && (this.action.call(this, t), this.repeat--);
  }
}
class Vr extends Ft {
  constructor(t) {
    super(), this.world = t, this.systemType = Mt.Draw, this.query = this.world.query([P]);
  }
  initialize(t, e) {
    this._graphicsContext = e.engine.graphicsContext, this._camera = e.camera, this._engine = e.engine, this._collisionSystem = t.systemManager.get(Cs);
  }
  update() {
    var t;
    if (!this._engine.isDebug)
      return;
    const e = this._engine.debug.filter;
    let i, s;
    const n = this._engine.debug.entity;
    let o;
    const a = this._engine.debug.transform;
    let h;
    const l = this._engine.debug.motion;
    let c;
    const d = this._engine.debug.collider, u = this._engine.debug.physics;
    let _, p;
    const g = this._engine.debug.body, x = this._engine.debug.camera;
    for (let m = 0; m < this.query.entities.length; m++) {
      const f = this.query.entities[m];
      if (f.hasTag("offscreen") || f instanceof ws || e.useFilter && (!(e.ids.length === 0 || e.ids.includes(f.id)) || !(e.nameQuery === "" || f.name.includes(e.nameQuery))))
        continue;
      let b = v.Zero;
      const C = w(0, 16);
      if (i = f.id, s = f.name, o = f.get(P), this._pushCameraTransform(o), this._graphicsContext.save(), o.coordPlane === at.Screen && this._graphicsContext.translate(this._engine.screen.contentArea.left, this._engine.screen.contentArea.top), this._applyTransform(f), o && ((a.showAll || a.showPosition) && this._graphicsContext.debug.drawPoint(v.Zero, { size: 4, color: a.positionColor }), (a.showAll || a.showPositionLabel) && (this._graphicsContext.debug.drawText(`pos${o.pos.toString(2)}`, b), b = b.add(C)), (a.showAll || a.showZIndex) && (this._graphicsContext.debug.drawText(`z(${o.z.toFixed(1)})`, b), b = b.add(C)), (n.showAll || n.showId) && (this._graphicsContext.debug.drawText(`id(${i}) ${f.parent ? "child of id(" + ((t = f.parent) == null ? void 0 : t.id) + ")" : ""}`, b), b = b.add(C)), (n.showAll || n.showName) && (this._graphicsContext.debug.drawText(`name(${s})`, b), b = b.add(C)), (a.showAll || a.showRotation) && (this._graphicsContext.debug.drawLine(v.Zero, v.fromAngle(o.rotation).scale(20).add(v.Zero), {
        color: a.rotationColor,
        lineWidth: 2
      }), this._graphicsContext.debug.drawText(`rot deg(${ro(o.rotation).toFixed(2)})`, b), b = b.add(C)), (a.showAll || a.showScale) && this._graphicsContext.debug.drawLine(v.Zero, o.scale, { color: a.scaleColor, lineWidth: 2 })), _ = f.get(gs), _ && (_.useTransform || this._graphicsContext.restore(), _.draw(this._graphicsContext, this._engine.debug), _.useTransform || (this._graphicsContext.save(), this._applyTransform(f))), p = f.get(U), p && ((g.showAll || g.showCollisionGroup) && (this._graphicsContext.debug.drawText(`collision group name(${p.group.name}))`, b), b = b.add(C), this._graphicsContext.debug.drawText(`          mask(0x${(p.group.mask >>> 0).toString(16)})`, b), b = b.add(C), this._graphicsContext.debug.drawText(`          category(0x${(p.group.category >>> 0).toString(16)})`, b), b = b.add(C)), (g.showAll || g.showCollisionType) && (this._graphicsContext.debug.drawText(`collision type(${p.collisionType})`, b), b = b.add(C)), (g.showAll || g.showMass) && (this._graphicsContext.debug.drawText(`mass(${p.mass})`, b), b = b.add(C)), (g.showAll || g.showMotion) && (this._graphicsContext.debug.drawText(`motion(${p.sleepMotion.toFixed(3)})`, b), b = b.add(C)), (g.showAll || g.showSleeping) && (this._graphicsContext.debug.drawText(`sleeping(${p.canSleep ? p.isSleeping : "cant sleep"})`, b), b = b.add(C))), this._graphicsContext.restore(), this._graphicsContext.save(), o.coordPlane === at.Screen && this._graphicsContext.translate(this._engine.screen.contentArea.left, this._engine.screen.contentArea.top), h = f.get(N), h && ((l.showAll || l.showVelocity) && (this._graphicsContext.debug.drawText(`vel${h.vel.toString(2)}`, b.add(o.globalPos)), this._graphicsContext.debug.drawLine(o.globalPos, o.globalPos.add(h.vel), {
        color: l.velocityColor,
        lineWidth: 2
      }), b = b.add(C)), (l.showAll || l.showAcceleration) && this._graphicsContext.debug.drawLine(o.globalPos, o.globalPos.add(h.acc), {
        color: l.accelerationColor,
        lineWidth: 2
      })), c = f.get(it), c) {
        const S = c.get();
        if ((d.showAll || d.showGeometry) && S && S.debug(this._graphicsContext, d.geometryColor, {
          lineWidth: d.geometryLineWidth,
          pointSize: d.geometryPointSize
        }), d.showAll || d.showBounds) {
          if (S instanceof ht) {
            const I = S.getColliders();
            for (const y of I) {
              const k = y.bounds, L = w(k.left, k.top);
              this._graphicsContext.debug.drawRect(L.x, L.y, k.width, k.height, {
                color: d.boundsColor,
                dashed: !0
              }), (d.showAll || d.showOwner) && this._graphicsContext.debug.drawText(`owner id(${y.owner.id})`, L);
            }
            c.bounds.debug(this._graphicsContext, {
              color: d.boundsColor,
              dashed: !0
            });
          } else if (S) {
            const I = c.bounds, y = w(I.left, I.top);
            this._graphicsContext.debug.drawRect(y.x, y.y, I.width, I.height, {
              color: d.boundsColor,
              dashed: !0
            }), (d.showAll || d.showOwner) && this._graphicsContext.debug.drawText(`owner id(${c.owner.id})`, y);
          }
        }
      }
      this._graphicsContext.restore(), this._popCameraTransform(o);
    }
    if (this._graphicsContext.save(), this._camera.draw(this._graphicsContext), (u.showAll || u.showBroadphaseSpacePartitionDebug) && this._collisionSystem.debug(this._graphicsContext), u.showAll || u.showCollisionContacts || u.showCollisionNormals)
      for (const [m, f] of this._engine.debug.stats.currFrame.physics.contacts) {
        if (u.showAll || u.showCollisionContacts)
          for (const b of f.points)
            this._graphicsContext.debug.drawPoint(b, {
              size: u.contactSize,
              color: u.collisionContactColor
            });
        if (u.showAll || u.showCollisionNormals)
          for (const b of f.points)
            this._graphicsContext.debug.drawLine(b, f.normal.scale(30).add(b), {
              color: u.collisionNormalColor
            });
      }
    this._graphicsContext.restore(), x && (this._graphicsContext.save(), this._camera.draw(this._graphicsContext), (x.showAll || x.showFocus) && this._graphicsContext.debug.drawCircle(this._camera.pos, 4, x.focusColor), (x.showAll || x.showZoom) && this._graphicsContext.debug.drawText(`zoom(${this._camera.zoom})`, this._camera.pos), this._graphicsContext.restore());
  }
  postupdate(t, e) {
    this._engine.isDebug && (this._graphicsContext.save(), this._camera && this._camera.draw(this._graphicsContext), St.flush(this._graphicsContext), this._graphicsContext.restore());
  }
  /**
   * This applies the current entity transform to the graphics context
   * @param entity
   */
  _applyTransform(t) {
    const e = t.getAncestors();
    for (const i of e) {
      const s = i == null ? void 0 : i.get(P);
      s && (this._graphicsContext.translate(s.pos.x, s.pos.y), this._graphicsContext.scale(s.scale.x, s.scale.y), this._graphicsContext.rotate(s.rotation));
    }
  }
  /**
   * Applies the current camera transform if in world coordinates
   * @param transform
   */
  _pushCameraTransform(t) {
    t.coordPlane === at.World && (this._graphicsContext.save(), this._camera && this._camera.draw(this._graphicsContext));
  }
  /**
   * Resets the current camera transform if in world coordinates
   * @param transform
   */
  _popCameraTransform(t) {
    t.coordPlane === at.World && this._graphicsContext.restore();
  }
}
Vr.priority = Kt.Lowest;
class As extends Ft {
  constructor(t) {
    super(), this.world = t, this.systemType = Mt.Update, this._graphicsHashGrid = new Fr({ size: 100 }), this._graphics = [], this._entityToPointer = /* @__PURE__ */ new Map(), this._pointerEventDispatcher = new Ss(), this.overrideUseColliderShape = !1, this.overrideUseGraphicsBounds = !1, this._sortedTransforms = [], this._sortedEntities = [], this._zHasChanged = !1, this._zIndexUpdate = () => {
      this._zHasChanged = !0;
    }, this.query = this.world.query([P, fe]), this.query.entityAdded$.subscribe((e) => {
      const i = e.get(P), s = e.get(fe);
      this._pointerEventDispatcher.addObject(
        e,
        (o) => s && s.localBounds ? s.localBounds.transform(i.get().matrix).contains(i.coordPlane === at.World ? o.worldPos : o.screenPos) : !1,
        () => e.isActive
      ), this._entityToPointer.set(e, s);
      const n = e.get(tt);
      n && (this._graphics.push(n), this._graphicsHashGrid.track(n)), this._sortedTransforms.push(i), this._sortedEntities.push(i.owner), i.zIndexChanged$.subscribe(this._zIndexUpdate), this._zHasChanged = !0;
    }), this.query.entityRemoved$.subscribe((e) => {
      this._pointerEventDispatcher.removeObject(e);
      const i = e.get(P);
      this._entityToPointer.delete(e);
      const s = e.get(tt);
      if (s) {
        const o = this._graphics.indexOf(s);
        o > -1 && this._graphics.splice(o, 1), this._graphicsHashGrid.untrack(s);
      }
      i.zIndexChanged$.unsubscribe(this._zIndexUpdate);
      const n = this._sortedTransforms.indexOf(i);
      n > -1 && (this._sortedTransforms.splice(n, 1), this._sortedEntities.splice(n, 1));
    });
  }
  initialize(t, e) {
    this._engine = e.engine, this._scene = e;
  }
  preupdate() {
    this._scene.camera.hasChanged() && this._scene.camera.updateTransform(this._scene.camera.pos), this._receivers = [this._engine.input.pointers, this._scene.input.pointers], this._engineReceiver = this._engine.input.pointers, this._zHasChanged && (this._sortedTransforms.sort((t, e) => e.z - t.z), this._sortedEntities = this._sortedTransforms.map((t) => t.owner), this._zHasChanged = !1);
  }
  update() {
    this._graphicsHashGrid.update(this._graphics);
    for (const [t, e] of this._engineReceiver.currentFramePointerCoords.entries()) {
      const i = this._scene.physics.query(e.worldPos);
      for (let n = 0; n < i.length; n++) {
        const o = i[n], a = this._entityToPointer.get(o.owner);
        a && (a.useColliderShape || this.overrideUseColliderShape) && o.contains(e.worldPos) && this._pointerEventDispatcher.addPointerToObject(o.owner, t);
      }
      const s = this._graphicsHashGrid.query(e.worldPos);
      for (let n = 0; n < s.length; n++) {
        const o = s[n], a = this._entityToPointer.get(o.owner);
        a && (a.useGraphicsBounds || this.overrideUseGraphicsBounds) && this._pointerEventDispatcher.addPointerToObject(o.owner, t);
      }
    }
    this._pointerEventDispatcher.processPointerToObject(this._engineReceiver, this._sortedEntities), this._pointerEventDispatcher.dispatchEvents(this._engineReceiver, this._sortedEntities), this._receivers.forEach((t) => t.update()), this._pointerEventDispatcher.clear(), this._receivers.forEach((t) => t.clear());
  }
}
As.priority = Kt.Higher;
class Gr extends Ft {
  constructor(t) {
    super(), this.world = t, this.systemType = Mt.Update, this._actions = [], this.query = this.world.query([Xe]), this.query.entityAdded$.subscribe((e) => this._actions.push(e.get(Xe))), this.query.entityRemoved$.subscribe((e) => {
      const i = e.get(Xe), s = this._actions.indexOf(i);
      s > -1 && this._actions.splice(s, 1);
    });
  }
  update(t) {
    for (let e = 0; e < this._actions.length; e++)
      this._actions[e].update(t);
  }
}
Gr.priority = Kt.Higher;
class Ps {
  constructor() {
    this.events = new X(), this.enabled = !1, this.supported = !!navigator.getGamepads, this._gamePadTimeStamps = [0, 0, 0, 0], this._oldPads = [], this._pads = [], this._initSuccess = !1, this._navigator = navigator, this._minimumConfiguration = null, this._enabled = !0;
  }
  init() {
    this.supported && (this._initSuccess || (this._oldPads = this._clonePads(this._navigator.getGamepads()), this._oldPads.length && this._oldPads[0] && (this._initSuccess = !0)));
  }
  toggleEnabled(t) {
    this._enabled = t;
  }
  /**
   * Sets the minimum gamepad configuration, for example {axis: 4, buttons: 4} means
   * this game requires at minimum 4 axis inputs and 4 buttons, this is not restrictive
   * all other controllers with more axis or buttons are valid as well. If no minimum
   * configuration is set all pads are valid.
   */
  setMinimumGamepadConfiguration(t) {
    this._enableAndUpdate(), this._minimumConfiguration = t;
  }
  /**
   * When implicitly enabled, set the enabled flag and run an update so information is updated
   */
  _enableAndUpdate() {
    this.enabled || (this.enabled = !0, this.update());
  }
  /**
   * Checks a navigator gamepad against the minimum configuration if present.
   */
  _isGamepadValid(t) {
    if (!this._minimumConfiguration)
      return !0;
    if (!t)
      return !1;
    const e = t.axes.filter((s) => typeof s !== void 0).length, i = t.buttons.filter((s) => typeof s !== void 0).length;
    return e >= this._minimumConfiguration.axis && i >= this._minimumConfiguration.buttons && t.connected;
  }
  emit(t, e) {
    this.events.emit(t, e);
  }
  on(t, e) {
    return this._enableAndUpdate(), this.events.on(t, e);
  }
  once(t, e) {
    return this._enableAndUpdate(), this.events.once(t, e);
  }
  off(t, e) {
    this._enableAndUpdate(), this.events.off(t, e);
  }
  /**
   * Updates Gamepad state and publishes Gamepad events
   */
  update() {
    var t, e;
    if (!this.enabled || !this.supported || !this._enabled)
      return;
    this.init();
    const i = this._navigator.getGamepads();
    for (let s = 0; s < i.length; s++) {
      if (i[s]) {
        const o = this.at(s);
        !this.at(s).connected && this._isGamepadValid(i[s]) && (o.events.pipe(this.events), this.events.emit("connect", new In(s, this.at(s)))), this.at(s).connected = !0;
      } else {
        const o = this.at(s);
        o.connected && (this.events.emit("disconnect", new Rn(s, o)), o.events.unpipe(this.events)), o.connected = !1;
        continue;
      }
      if (this.at(s).update(), i[s].timestamp && i[s].timestamp === this._gamePadTimeStamps[s])
        continue;
      this._gamePadTimeStamps[s] = i[s].timestamp, this.at(s).navigatorGamepad = i[s];
      const n = i[s];
      if (n) {
        for (let o = 0; o < n.buttons.length; o++) {
          const a = n.buttons[o], h = a == null ? void 0 : a.value;
          h !== ((t = this._oldPads[s]) == null ? void 0 : t.getButton(o)) && (a != null && a.pressed ? (this.at(s).updateButton(o, h), this.at(s).events.emit(
            "button",
            new Mn(
              o in qr ? o : -1,
              o,
              h,
              this.at(s)
            )
          )) : this.at(s).updateButton(o, 0));
        }
        for (let o = 0; o < n.axes.length; o++) {
          const a = n.axes[o];
          a !== ((e = this._oldPads[s]) == null ? void 0 : e.getAxes(o)) && (this.at(s).updateAxes(o, a), this.at(s).events.emit("axis", new Fn(o, a, this.at(s))));
        }
      }
      this._oldPads[s] = this._clonePad(i[s]);
    }
  }
  /**
   * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist
   */
  at(t) {
    if (this._enableAndUpdate(), t >= this._pads.length)
      for (let e = this._pads.length - 1, i = t; e < i; e++)
        this._pads.push(new Vi()), this._oldPads.push(new Vi());
    return this._pads[t];
  }
  /**
   * Returns a list of all valid gamepads that meet the minimum configuration requirement.
   */
  getValidGamepads() {
    this._enableAndUpdate();
    const t = [];
    for (let e = 0; e < this._pads.length; e++)
      this._isGamepadValid(this.at(e).navigatorGamepad) && this.at(e).connected && t.push(this.at(e));
    return t;
  }
  /**
   * Gets the number of connected gamepads
   */
  count() {
    return this._pads.filter((t) => t.connected).length;
  }
  _clonePads(t) {
    const e = [];
    for (let i = 0, s = t.length; i < s; i++)
      e.push(this._clonePad(t[i]));
    return e;
  }
  /**
   * Fastest way to clone a known object is to do it yourself
   */
  _clonePad(t) {
    let e, i;
    const s = new Vi();
    if (!t)
      return s;
    for (e = 0, i = t.buttons.length; e < i; e++)
      t.buttons[e] && s.updateButton(e, t.buttons[e].value);
    for (e = 0, i = t.axes.length; e < i; e++)
      s.updateAxes(e, t.axes[e]);
    return s;
  }
}
Ps.MinAxisMoveThreshold = 0.05;
class Vi {
  constructor() {
    this.events = new X(), this.connected = !1, this._axes = new Array(4), this._buttons = new Array(16), this._buttonsUp = new Array(16), this._buttonsDown = new Array(16);
    for (let t = 0; t < this._buttons.length; t++)
      this._buttons[t] = 0;
    for (let t = 0; t < this._axes.length; t++)
      this._axes[t] = 0;
  }
  update() {
    this._buttonsDown = new Array(16), this._buttonsUp = new Array(16);
  }
  /**
   * Whether or not the given button is pressed
   * @deprecated will be removed in v0.28.0. Use isButtonHeld instead
   * @param button     The button to query
   * @param threshold  The threshold over which the button is considered to be pressed
   */
  isButtonPressed(t, e = 1) {
    return this._buttons[t] >= e;
  }
  /**
   * Tests if a certain button is held down. This is persisted between frames.
   * @param button     The button to query
   * @param threshold  The threshold over which the button is considered to be pressed
   */
  isButtonHeld(t, e = 1) {
    return this._buttons[t] >= e;
  }
  /**
   * Tests if a certain button was just pressed this frame. This is cleared at the end of the update frame.
   * @param button Test whether a button was just pressed
   * @param threshold  The threshold over which the button is considered to be pressed
   */
  wasButtonPressed(t, e = 1) {
    return this._buttonsDown[t] >= e;
  }
  /**
   * Tests if a certain button was just released this frame. This is cleared at the end of the update frame.
   * @param button  Test whether a button was just released
   */
  wasButtonReleased(t) {
    return !!this._buttonsUp[t];
  }
  /**
   * Gets the given button value between 0 and 1
   */
  getButton(t) {
    return this._buttons[t];
  }
  /**
   * Gets the given axis value between -1 and 1. Values below
   * {@apilink MinAxisMoveThreshold} are considered 0.
   */
  getAxes(t) {
    const e = this._axes[t];
    return Math.abs(e) < Ps.MinAxisMoveThreshold ? 0 : e;
  }
  updateButton(t, e) {
    e === 0 && this._buttons[t] ? this._buttonsUp[t] = 1 : this._buttonsDown[t] = e, this._buttons[t] = e;
  }
  updateAxes(t, e) {
    this._axes[t] = e;
  }
  emit(t, e) {
    this.events.emit(t, e);
  }
  on(t, e) {
    return this.events.on(t, e);
  }
  once(t, e) {
    return this.events.once(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
}
var qr = /* @__PURE__ */ ((r) => (r[r.Unknown = -1] = "Unknown", r[r.Face1 = 0] = "Face1", r[r.Face2 = 1] = "Face2", r[r.Face3 = 2] = "Face3", r[r.Face4 = 3] = "Face4", r[r.LeftBumper = 4] = "LeftBumper", r[r.RightBumper = 5] = "RightBumper", r[r.LeftTrigger = 6] = "LeftTrigger", r[r.RightTrigger = 7] = "RightTrigger", r[r.Select = 8] = "Select", r[r.Start = 9] = "Start", r[r.LeftStick = 10] = "LeftStick", r[r.RightStick = 11] = "RightStick", r[r.DpadUp = 12] = "DpadUp", r[r.DpadDown = 13] = "DpadDown", r[r.DpadLeft = 14] = "DpadLeft", r[r.DpadRight = 15] = "DpadRight", r[r.CenterButton = 16] = "CenterButton", r[r.MiscButton1 = 17] = "MiscButton1", r))(qr || {}), Th = /* @__PURE__ */ ((r) => (r[r.LeftStickX = 0] = "LeftStickX", r[r.LeftStickY = 1] = "LeftStickY", r[r.RightStickX = 2] = "RightStickX", r[r.RightStickY = 3] = "RightStickY", r))(Th || {});
class Sh {
  constructor(t) {
    this.inputs = t, this._handlers = /* @__PURE__ */ new Map();
  }
  /**
   * Executes the input map, called internally by Excalibur
   */
  execute() {
    for (const [t, e] of this._handlers.entries()) {
      const i = t(this.inputs);
      i && e(i);
    }
  }
  /**
   * This allows you to map multiple inputs to specific commands! This is useful
   *
   * The inputHandler should return a truthy value if you wish the commandHandler to fire.
   *
   * Example:
   * ```typescript
   * const moveRight = (amount: number) => { actor.vel.x = 100 * amount }
   * const moveLeft = (amount: number) => { actor.vel.x = -100 * amount }
   * const moveUp = (amount: number) => { actor.vel.y = -100 * amount }
   * const moveDown = (amount: number) => { actor.vel.y = 100 * amount }
   *
   * engine.inputMapper.on(({keyboard}) => keyboard.isHeld(ex.Keys.ArrowRight) ? 1 : 0, moveRight);
   * engine.inputMapper.on(({gamepads}) => gamepads.at(0).isButtonPressed(ex.Buttons.DpadRight) ? 1 : 0, moveRight);
   * engine.inputMapper.on(({gamepads}) => gamepads.at(0).getAxes(ex.Axes.LeftStickX) > 0 ?
   *  gamepads.at(0).getAxes(ex.Axes.LeftStickX) : 0, moveRight);
   * ```
   * @param inputHandler
   * @param commandHandler
   */
  on(t, e) {
    this._handlers.set(t, e);
  }
}
function Xr() {
  try {
    const r = () => {
    };
    window.top.addEventListener("blur", r), window.top.removeEventListener("blur", r);
  } catch (r) {
    return !0;
  }
  return !1;
}
function $r() {
  return window !== window.top;
}
function Yr() {
  let r;
  return Xr() ? (r = window, R.getInstance().warnOnce("Excalibur might be in a cross-origin iframe, in order to receive keyboard events it must be in focus")) : $r() ? (r = window, R.getInstance().warnOnce("Excalibur might be in a iframe, in order to receive keyboard events it must be in focus")) : r = window.top, r;
}
var Ah = /* @__PURE__ */ ((r) => (r.Backquote = "Backquote", r.Backslash = "Backslash", r.BracketLeft = "BracketLeft", r.BracketRight = "BracketRight", r.Comma = "Comma", r.Key0 = "Digit0", r.Key1 = "Digit1", r.Key2 = "Digit2", r.Key3 = "Digit3", r.Key4 = "Digit4", r.Key5 = "Digit5", r.Key6 = "Digit6", r.Key7 = "Digit7", r.Key8 = "Digit8", r.Key9 = "Digit9", r.Digit0 = "Digit0", r.Digit1 = "Digit1", r.Digit2 = "Digit2", r.Digit3 = "Digit3", r.Digit4 = "Digit4", r.Digit5 = "Digit5", r.Digit6 = "Digit6", r.Digit7 = "Digit7", r.Digit8 = "Digit8", r.Digit9 = "Digit9", r.Equal = "Equal", r.IntlBackslash = "IntlBackslash", r.IntlRo = "IntlRo", r.IntlYen = "IntlYen", r.A = "KeyA", r.B = "KeyB", r.C = "KeyC", r.D = "KeyD", r.E = "KeyE", r.F = "KeyF", r.G = "KeyG", r.H = "KeyH", r.I = "KeyI", r.J = "KeyJ", r.K = "KeyK", r.L = "KeyL", r.M = "KeyM", r.N = "KeyN", r.O = "KeyO", r.P = "KeyP", r.Q = "KeyQ", r.R = "KeyR", r.S = "KeyS", r.T = "KeyT", r.U = "KeyU", r.V = "KeyV", r.W = "KeyW", r.X = "KeyX", r.Y = "KeyY", r.Z = "KeyZ", r.KeyA = "KeyA", r.KeyB = "KeyB", r.KeyC = "KeyC", r.KeyD = "KeyD", r.KeyE = "KeyE", r.KeyF = "KeyF", r.KeyG = "KeyG", r.KeyH = "KeyH", r.KeyI = "KeyI", r.KeyJ = "KeyJ", r.KeyK = "KeyK", r.KeyL = "KeyL", r.KeyM = "KeyM", r.KeyN = "KeyN", r.KeyO = "KeyO", r.KeyP = "KeyP", r.KeyQ = "KeyQ", r.KeyR = "KeyR", r.KeyS = "KeyS", r.KeyT = "KeyT", r.KeyU = "KeyU", r.KeyV = "KeyV", r.KeyW = "KeyW", r.KeyX = "KeyX", r.KeyY = "KeyY", r.KeyZ = "KeyZ", r.Minus = "Minus", r.Period = "Period", r.Quote = "Quote", r.Semicolon = "Semicolon", r.Slash = "Slash", r.AltLeft = "AltLeft", r.AltRight = "AltRight", r.Alt = "Alt", r.AltGraph = "AltGraph", r.Backspace = "Backspace", r.CapsLock = "CapsLock", r.ContextMenu = "ContextMenu", r.ControlLeft = "ControlLeft", r.ControlRight = "ControlRight", r.Enter = "Enter", r.MetaLeft = "MetaLeft", r.MetaRight = "MetaRight", r.ShiftLeft = "ShiftLeft", r.ShiftRight = "ShiftRight", r.Space = "Space", r.Tab = "Tab", r.Convert = "Convert", r.KanaMode = "KanaMode", r.NonConvert = "NonConvert", r.Delete = "Delete", r.End = "End", r.Help = "Help", r.Home = "Home", r.Insert = "Insert", r.PageDown = "PageDown", r.PageUp = "PageUp", r.Up = "ArrowUp", r.Down = "ArrowDown", r.Left = "ArrowLeft", r.Right = "ArrowRight", r.ArrowUp = "ArrowUp", r.ArrowDown = "ArrowDown", r.ArrowLeft = "ArrowLeft", r.ArrowRight = "ArrowRight", r.NumLock = "NumLock", r.Numpad0 = "Numpad0", r.Numpad1 = "Numpad1", r.Numpad2 = "Numpad2", r.Numpad3 = "Numpad3", r.Numpad4 = "Numpad4", r.Numpad5 = "Numpad5", r.Numpad6 = "Numpad6", r.Numpad7 = "Numpad7", r.Numpad8 = "Numpad8", r.Numpad9 = "Numpad9", r.Num0 = "Numpad0", r.Num1 = "Numpad1", r.Num2 = "Numpad2", r.Num3 = "Numpad3", r.Num4 = "Numpad4", r.Num5 = "Numpad5", r.Num6 = "Numpad6", r.Num7 = "Numpad7", r.Num8 = "Numpad8", r.Num9 = "Numpad9", r.NumAdd = "NumpadAdd", r.NumpadAdd = "NumpadAdd", r.NumDecimal = "NumpadDecimal", r.NumpadDecimal = "NumpadDecimal", r.NumDivide = "NumpadDivide", r.NumpadDivide = "NumpadDivide", r.NumEnter = "NumpadEnter", r.NumpadEnter = "NumpadEnter", r.NumMultiply = "NumpadMultiply", r.NumpadMultiply = "NumpadMultiply", r.NumSubtract = "NumpadSubtract", r.NumpadSubtract = "NumpadSubtract", r.Esc = "Escape", r.Escape = "Escape", r.F1 = "F1", r.F2 = "F2", r.F3 = "F3", r.F4 = "F4", r.F5 = "F5", r.F6 = "F6", r.F7 = "F7", r.F8 = "F8", r.F9 = "F9", r.F10 = "F10", r.F11 = "F11", r.F12 = "F12", r.F13 = "F13", r.F14 = "F14", r.F15 = "F15", r.F16 = "F16", r.F17 = "F17", r.F18 = "F18", r.F19 = "F19", r.F20 = "F20", r.PrintScreen = "PrintScreen", r.ScrollLock = "ScrollLock", r.Pause = "Pause", r.Unidentified = "Unidentified", r))(Ah || {});
class oi extends B {
  /**
   * @param key  The key responsible for throwing the event
   * @param value The key's typed value the browser detected
   * @param originalEvent The original keyboard event that Excalibur handled
   */
  constructor(t, e, i) {
    super(), this.key = t, this.value = e, this.originalEvent = i;
  }
}
class Ph {
  constructor() {
    this.events = new X(), this._enabled = !0, this._keys = [], this._keysUp = [], this._keysDown = [], this._releaseAllKeys = (t) => {
      for (const e of this._keys) {
        const i = new oi(e, t.key, t);
        this.events.emit("up", i), this.events.emit("release", i);
      }
      this._keysUp = Array.from(new Set(this._keys.concat(this._keysUp))), this._keys.length = 0;
    }, this._handleKeyDown = (t) => {
      if (!this._enabled)
        return;
      !t.metaKey && (this._keys.includes(
        "MetaLeft"
        /* MetaLeft */
      ) || this._keys.includes(
        "MetaRight"
        /* MetaRight */
      )) && this._releaseAllKeys(t);
      const e = t.code;
      if (this._keys.indexOf(e) === -1) {
        this._keys.push(e), this._keysDown.push(e);
        const i = new oi(e, t.key, t);
        this.events.emit("down", i), this.events.emit("press", i);
      }
    }, this._handleKeyUp = (t) => {
      if (!this._enabled)
        return;
      const e = t.code, i = this._keys.indexOf(e);
      this._keys.splice(i, 1), this._keysUp.push(e);
      const s = new oi(e, t.key, t);
      this.events.emit("up", s), this.events.emit("release", s), t.key === "Meta" && this._releaseAllKeys(t);
    };
  }
  emit(t, e) {
    this.events.emit(t, e);
  }
  on(t, e) {
    return this.events.on(t, e);
  }
  once(t, e) {
    return this.events.once(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
  /**
   * Initialize Keyboard event listeners
   */
  init(t) {
    let { global: e } = t;
    const { grabWindowFocus: i } = t;
    e ? typeof e == "function" && (e = e()) : e = Yr(), i && e.focus(), e.addEventListener("blur", () => {
      this._keys.length = 0;
    }), e.addEventListener("keyup", this._handleKeyUp), e.addEventListener("keydown", this._handleKeyDown);
  }
  toggleEnabled(t) {
    this._enabled = t;
  }
  clear() {
    this._keysDown.length = 0, this._keysUp.length = 0, this._keys.length = 0;
  }
  update() {
    this._keysDown.length = 0, this._keysUp.length = 0;
    for (let t = 0; t < this._keys.length; t++)
      this.events.emit("hold", new oi(this._keys[t]));
  }
  /**
   * Gets list of keys being pressed down
   */
  getKeys() {
    return this._keys;
  }
  /**
   * Tests if a certain key was just pressed this frame. This is cleared at the end of the update frame.
   * @param key Test whether a key was just pressed
   */
  wasPressed(t) {
    return this._enabled ? this._keysDown.indexOf(t) > -1 : !1;
  }
  /**
   * Tests if a certain key is held down. This is persisted between frames.
   * @param key  Test whether a key is held down
   */
  isHeld(t) {
    return this._enabled ? this._keys.indexOf(t) > -1 : !1;
  }
  /**
   * Tests if a certain key was just released this frame. This is cleared at the end of the update frame.
   * @param key  Test whether a key was just released
   */
  wasReleased(t) {
    return this._enabled ? this._keysUp.indexOf(t) > -1 : !1;
  }
  /**
   * Trigger a manual key event
   * @param type
   * @param key
   * @param character
   */
  triggerEvent(t, e, i) {
    t === "down" && this._handleKeyDown(
      new KeyboardEvent("keydown", {
        code: e,
        key: i != null ? i : null
      })
    ), t === "up" && this._handleKeyUp(
      new KeyboardEvent("keyup", {
        code: e,
        key: i != null ? i : null
      })
    );
  }
}
class ai {
  constructor(t, e, i, s, n, o) {
    this.type = t, this.pointerId = e, this.button = i, this.pointerType = s, this.coordinates = n, this.nativeEvent = o, this.active = !0;
  }
  cancel() {
    this.active = !1;
  }
  get pagePos() {
    return this.coordinates.pagePos;
  }
  get screenPos() {
    return this.coordinates.screenPos;
  }
  get worldPos() {
    return this.coordinates.worldPos;
  }
}
class Eh {
  constructor(t, e, i, s, n, o, a, h, l, c, d, u) {
    this.x = t, this.y = e, this.pageX = i, this.pageY = s, this.screenX = n, this.screenY = o, this.index = a, this.deltaX = h, this.deltaY = l, this.deltaZ = c, this.deltaMode = d, this.ev = u, this.active = !0;
  }
  cancel() {
    this.active = !1;
  }
}
class tn {
  constructor() {
    this.events = new X(), this.lastPagePos = v.Zero, this.lastScreenPos = v.Zero, this.lastWorldPos = v.Zero, this._onPointerMove = (t) => {
      this.lastPagePos = new v(t.pagePos.x, t.pagePos.y), this.lastScreenPos = new v(t.screenPos.x, t.screenPos.y), this.lastWorldPos = new v(t.worldPos.x, t.worldPos.y);
    }, this._onPointerDown = (t) => {
      this.lastPagePos = new v(t.pagePos.x, t.pagePos.y), this.lastScreenPos = new v(t.screenPos.x, t.screenPos.y), this.lastWorldPos = new v(t.worldPos.x, t.worldPos.y);
    }, this.on("move", this._onPointerMove), this.on("down", this._onPointerDown);
  }
  emit(t, e) {
    this.events.emit(t, e);
  }
  on(t, e) {
    return this.events.on(t, e);
  }
  once(t, e) {
    return this.events.once(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
  /**
   * Called internally by excalibur to keep pointers up to date
   * @internal
   * @param engine
   */
  _updateWorldPosition(t) {
    const e = Ye.fromPagePosition(this.lastPagePos, t);
    this.lastScreenPos = e.screenPos, this.lastWorldPos = e.worldPos;
  }
}
var gi = /* @__PURE__ */ ((r) => (r.Pixel = "Pixel", r.Line = "Line", r.Page = "Page", r))(gi || {}), ye = /* @__PURE__ */ ((r) => (r[r.NoButton = -1] = "NoButton", r[r.Left = 0] = "Left", r[r.Middle = 1] = "Middle", r[r.Right = 2] = "Right", r[r.Unknown = 3] = "Unknown", r))(ye || {}), ce = /* @__PURE__ */ ((r) => (r.Left = "Left", r.Middle = "Middle", r.Right = "Right", r.Unknown = "Unknown", r.NoButton = "NoButton", r))(ce || {}), de = /* @__PURE__ */ ((r) => (r.Touch = "Touch", r.Mouse = "Mouse", r.Pen = "Pen", r.Unknown = "Unknown", r))(de || {});
function Ih(r) {
  return globalThis.TouchEvent && r instanceof globalThis.TouchEvent;
}
function Rh(r) {
  return globalThis.PointerEvent && r instanceof globalThis.PointerEvent;
}
class Es {
  constructor(t, e) {
    this.target = t, this.engine = e, this.events = new X(), this.primary = new tn(), this._activeNativePointerIdsToNormalized = /* @__PURE__ */ new Map(), this.lastFramePointerCoords = /* @__PURE__ */ new Map(), this.currentFramePointerCoords = /* @__PURE__ */ new Map(), this.currentFramePointerDown = /* @__PURE__ */ new Map(), this.lastFramePointerDown = /* @__PURE__ */ new Map(), this.currentFrameDown = [], this.currentFrameUp = [], this.currentFrameMove = [], this.currentFrameCancel = [], this.currentFrameWheel = [], this._enabled = !0, this._pointers = [this.primary], this._boundHandle = this._handle.bind(this), this._boundWheel = this._handleWheel.bind(this);
  }
  toggleEnabled(t) {
    this._enabled = t;
  }
  /**
   * Creates a new PointerEventReceiver with a new target and engine while preserving existing pointer event
   * handlers.
   * @param target
   * @param engine
   */
  recreate(t, e) {
    const i = new Es(t, e);
    return i.primary = this.primary, i._pointers = this._pointers, i;
  }
  /**
   * Locates a specific pointer by id, creates it if it doesn't exist
   * @param index
   */
  at(t) {
    if (t >= this._pointers.length)
      for (let e = this._pointers.length - 1, i = t; e < i; e++)
        this._pointers.push(new tn());
    return this._pointers[t];
  }
  /**
   * The number of pointers currently being tracked by excalibur
   */
  count() {
    return this._pointers.length;
  }
  /**
   * Is the specified pointer id down this frame
   * @param pointerId
   */
  isDown(t) {
    var e;
    return this._enabled && (e = this.currentFramePointerDown.get(t)) != null ? e : !1;
  }
  /**
   * Was the specified pointer id down last frame
   * @param pointerId
   */
  wasDown(t) {
    var e;
    return this._enabled && (e = this.lastFramePointerDown.get(t)) != null ? e : !1;
  }
  /**
   * Whether the Pointer is currently dragging.
   */
  isDragging(t) {
    return this._enabled ? this.isDown(t) : !1;
  }
  /**
   * Whether the Pointer just started dragging.
   */
  isDragStart(t) {
    return this._enabled ? this.isDown(t) && !this.wasDown(t) : !1;
  }
  /**
   * Whether the Pointer just ended dragging.
   */
  isDragEnd(t) {
    return this._enabled ? !this.isDown(t) && this.wasDown(t) : !1;
  }
  emit(t, e) {
    this.events.emit(t, e);
  }
  on(t, e) {
    return this.events.on(t, e);
  }
  once(t, e) {
    return this.events.once(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
  /**
   * Called internally by excalibur
   *
   * Updates the current frame pointer info and emits raw pointer events
   *
   * This does not emit events to entities, see PointerSystem
   * @internal
   */
  update() {
    this.lastFramePointerDown = new Map(this.currentFramePointerDown), this.lastFramePointerCoords = new Map(this.currentFramePointerCoords);
    for (const t of this.currentFrameDown) {
      if (!t.active)
        continue;
      this.emit("down", t), this.at(t.pointerId).emit("down", t), this.primary.emit("pointerdown", t);
    }
    for (const t of this.currentFrameUp) {
      if (!t.active)
        continue;
      this.emit("up", t), this.at(t.pointerId).emit("up", t);
    }
    for (const t of this.currentFrameMove) {
      if (!t.active)
        continue;
      this.emit("move", t), this.at(t.pointerId).emit("move", t);
    }
    for (const t of this.currentFrameCancel) {
      if (!t.active)
        continue;
      this.emit("cancel", t), this.at(t.pointerId).emit("cancel", t);
    }
    for (const t of this.currentFrameWheel)
      t.active && (this.emit("pointerwheel", t), this.emit("wheel", t), this.primary.emit("pointerwheel", t), this.primary.emit("wheel", t));
    if (this.engine.currentScene.camera.hasChanged())
      for (const t of this._pointers)
        t._updateWorldPosition(this.engine);
  }
  /**
   * Clears the current frame event and pointer data
   */
  clear() {
    for (const t of this.currentFrameUp) {
      this.currentFramePointerCoords.delete(t.pointerId);
      const e = this._activeNativePointerIdsToNormalized.entries();
      for (const [i, s] of e)
        s === t.pointerId && this._activeNativePointerIdsToNormalized.delete(i);
    }
    this.currentFrameDown.length = 0, this.currentFrameUp.length = 0, this.currentFrameMove.length = 0, this.currentFrameCancel.length = 0, this.currentFrameWheel.length = 0;
  }
  /**
   * Initializes the pointer event receiver so that it can start listening to native
   * browser events.
   */
  init(t) {
    var e;
    if (this.engine.isDisposed())
      return;
    this.target === this.engine.canvas ? this.engine.canvas.style.touchAction = "none" : document.body.style.touchAction = "none", window.PointerEvent ? (this.target.addEventListener("pointerdown", this._boundHandle), this.target.addEventListener("pointerup", this._boundHandle), this.target.addEventListener("pointermove", this._boundHandle), this.target.addEventListener("pointercancel", this._boundHandle)) : (this.target.addEventListener("touchstart", this._boundHandle), this.target.addEventListener("touchend", this._boundHandle), this.target.addEventListener("touchmove", this._boundHandle), this.target.addEventListener("touchcancel", this._boundHandle), this.target.addEventListener("mousedown", this._boundHandle), this.target.addEventListener("mouseup", this._boundHandle), this.target.addEventListener("mousemove", this._boundHandle));
    const i = {
      passive: !(this.engine.pageScrollPreventionMode === Ne.All || this.engine.pageScrollPreventionMode === Ne.Canvas)
    };
    if ("onwheel" in document.createElement("div") ? this.target.addEventListener("wheel", this._boundWheel, i) : document.onmousewheel !== void 0 ? this.target.addEventListener("mousewheel", this._boundWheel, i) : this.target.addEventListener("MozMousePixelScroll", this._boundWheel, i), ((e = t == null ? void 0 : t.grabWindowFocus) != null ? e : !0) && (Xr() || $r())) {
      const n = () => {
        window.focus();
      };
      window.PointerEvent ? this.target.addEventListener("pointerdown", n) : (this.target.addEventListener("touchstart", n), this.target.addEventListener("mousedown", n));
    }
  }
  detach() {
    window.PointerEvent ? (this.target.removeEventListener("pointerdown", this._boundHandle), this.target.removeEventListener("pointerup", this._boundHandle), this.target.removeEventListener("pointermove", this._boundHandle), this.target.removeEventListener("pointercancel", this._boundHandle)) : (this.target.removeEventListener("touchstart", this._boundHandle), this.target.removeEventListener("touchend", this._boundHandle), this.target.removeEventListener("touchmove", this._boundHandle), this.target.removeEventListener("touchcancel", this._boundHandle), this.target.removeEventListener("mousedown", this._boundHandle), this.target.removeEventListener("mouseup", this._boundHandle), this.target.removeEventListener("mousemove", this._boundHandle)), "onwheel" in document.createElement("div") ? this.target.removeEventListener("wheel", this._boundWheel) : document.onmousewheel !== void 0 ? this.target.addEventListener("mousewheel", this._boundWheel) : this.target.addEventListener("MozMousePixelScroll", this._boundWheel);
  }
  /**
   * Take native pointer id and map it to index in active pointers
   * @param nativePointerId
   */
  _normalizePointerId(t) {
    this._activeNativePointerIdsToNormalized.set(t, -1);
    const i = Array.from(this._activeNativePointerIdsToNormalized.keys()).sort((s, n) => s - n).findIndex((s) => s === t);
    return this._activeNativePointerIdsToNormalized.set(t, i), i;
  }
  /**
   * Responsible for handling and parsing pointer events
   */
  _handle(t) {
    if (!this._enabled)
      return;
    t.preventDefault();
    const e = /* @__PURE__ */ new Map();
    let i, s;
    if (Ih(t)) {
      i = ce.Unknown, s = de.Touch;
      for (let n = 0; n < t.changedTouches.length; n++) {
        const o = t.changedTouches[n], a = Ye.fromPagePosition(o.pageX, o.pageY, this.engine), h = n + 1, l = this._normalizePointerId(h);
        this.currentFramePointerCoords.set(l, a), e.set(l, a);
      }
    } else {
      i = this._nativeButtonToPointerButton(t.button), s = de.Mouse;
      const n = Ye.fromPagePosition(t.pageX, t.pageY, this.engine);
      let o = 1;
      Rh(t) && (o = t.pointerId, s = this._stringToPointerType(t.pointerType));
      const a = this._normalizePointerId(o);
      this.currentFramePointerCoords.set(a, n), e.set(a, n);
    }
    for (const [n, o] of e.entries())
      switch (t.type) {
        case "mousedown":
        case "pointerdown":
        case "touchstart":
          this.currentFrameDown.push(new ai("down", n, i, s, o, t)), this.currentFramePointerDown.set(n, !0);
          break;
        case "mouseup":
        case "pointerup":
        case "touchend":
          this.currentFrameUp.push(new ai("up", n, i, s, o, t)), this.currentFramePointerDown.set(n, !1);
          break;
        case "mousemove":
        case "pointermove":
        case "touchmove":
          this.currentFrameMove.push(new ai("move", n, i, s, o, t));
          break;
        case "touchcancel":
        case "pointercancel":
          this.currentFrameCancel.push(new ai("cancel", n, i, s, o, t));
          break;
      }
  }
  _handleWheel(t) {
    if (!this._enabled)
      return;
    (this.engine.pageScrollPreventionMode === Ne.All || this.engine.pageScrollPreventionMode === Ne.Canvas && t.target === this.engine.canvas) && t.preventDefault();
    const e = this.engine.screen.pageToScreenCoordinates(w(t.pageX, t.pageY)), i = this.engine.screen.screenToWorldCoordinates(e), s = -1 / 40, n = t.deltaX || t.wheelDeltaX * s || 0, o = t.deltaY || t.wheelDeltaY * s || t.wheelDelta * s || t.detail || 0, a = t.deltaZ || 0;
    let h = gi.Pixel;
    t.deltaMode && (t.deltaMode === 1 ? h = gi.Line : t.deltaMode === 2 && (h = gi.Page));
    const l = new Eh(i.x, i.y, t.pageX, t.pageY, e.x, e.y, 0, n, o, a, h, t);
    this.currentFrameWheel.push(l);
  }
  /**
   * Triggers an excalibur pointer event in a world space pos
   *
   * Useful for testing pointers in excalibur
   * @param type
   * @param pos
   */
  triggerEvent(t, e) {
    const i = this.engine.screen.worldToPageCoordinates(e);
    window.PointerEvent ? this._handle(
      new window.PointerEvent("pointer" + t, {
        pointerId: 0,
        clientX: i.x,
        clientY: i.y
      })
    ) : this._handle(
      new window.MouseEvent("mouse" + t, {
        clientX: i.x,
        clientY: i.y
      })
    );
    const s = this.engine.currentScene.world.get(As);
    s.preupdate(this.engine.currentScene, 1), s.update(1);
  }
  _nativeButtonToPointerButton(t) {
    switch (t) {
      case ye.NoButton:
        return ce.NoButton;
      case ye.Left:
        return ce.Left;
      case ye.Middle:
        return ce.Middle;
      case ye.Right:
        return ce.Right;
      case ye.Unknown:
        return ce.Unknown;
      default:
        return $n(t);
    }
  }
  _stringToPointerType(t) {
    switch (t) {
      case "touch":
        return de.Touch;
      case "mouse":
        return de.Mouse;
      case "pen":
        return de.Pen;
      default:
        return de.Unknown;
    }
  }
}
class Zr {
  constructor(t) {
    this._enabled = !0;
    const { pointerTarget: e, grabWindowFocus: i, engine: s, global: n } = t;
    this.keyboard = new Ph(), this.pointers = new Es(e, s), this.gamepads = new Ps(), this.keyboard.init({ global: n, grabWindowFocus: i }), this.pointers.init({ grabWindowFocus: i }), this.gamepads.init(), this.inputMapper = new Sh({
      keyboard: this.keyboard,
      pointers: this.pointers,
      gamepads: this.gamepads
    });
  }
  get enabled() {
    return this._enabled;
  }
  toggleEnabled(t) {
    this._enabled = t, this.keyboard.toggleEnabled(this._enabled), this.pointers.toggleEnabled(this._enabled), this.gamepads.toggleEnabled(this._enabled);
  }
  update() {
    this._enabled && (this.inputMapper.execute(), this.keyboard.update(), this.gamepads.update());
  }
  clear() {
    this.keyboard.clear(), this.pointers.clear();
  }
}
class Kl {
}
const tc = {
  Initialize: "initialize",
  Activate: "activate",
  Deactivate: "deactivate",
  PreUpdate: "preupdate",
  PostUpdate: "postupdate",
  PreDraw: "predraw",
  PostDraw: "postdraw",
  PreDebugDraw: "predebugdraw",
  PostDebugDraw: "postdebugdraw",
  PreLoad: "preload",
  TransitionStart: "transitionstart",
  TransitionEnd: "transitionend"
};
function Xt(r) {
  var t, e;
  return !!(r != null && r.prototype) && !!((e = (t = r == null ? void 0 : r.prototype) == null ? void 0 : t.constructor) != null && e.name);
}
class Et {
  constructor() {
    this._logger = R.getInstance(), this.events = new X(), this.camera = new yh(), this.world = new wo(this), this.physics = new th(ne()), this._isInitialized = !1, this._timers = [], this._cancelQueue = [], this.world.add(Gr), this.world.add(new ys(this.world, this.physics)), this.world.add(new Cs(this.world, this.physics)), this.world.add(As), this.world.add(Wr), this.world.add(mr), this.world.add(pr), this.world.add(Vr);
  }
  /**
   * The actors in the current scene
   */
  get actors() {
    return this.world.entityManager.entities.filter((t) => t instanceof Dt);
  }
  /**
   * The entities in the current scene
   */
  get entities() {
    return this.world.entityManager.entities;
  }
  /**
   * The triggers in the current scene
   */
  get triggers() {
    return this.world.entityManager.entities.filter((t) => t instanceof Ch);
  }
  /**
   * The {@apilink TileMap}s in the scene, if any
   */
  get tileMaps() {
    return this.world.entityManager.entities.filter((t) => t instanceof uh);
  }
  get timers() {
    return this._timers;
  }
  emit(t, e) {
    this.events.emit(t, e);
  }
  on(t, e) {
    return this.events.on(t, e);
  }
  once(t, e) {
    return this.events.once(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
  /**
   * Event hook to provide Scenes a way of loading scene specific resources.
   *
   * This is called before the Scene.onInitialize during scene transition. It will only ever fire once for a scene.
   * @param loader
   */
  onPreLoad(t) {
  }
  /**
   * Event hook fired directly before transition, either "in" or "out" of the scene
   *
   * This overrides the Engine scene definition. However transitions specified in goToScene take highest precedence
   *
   * ```typescript
   * // Overrides all
   * Engine.goToScene('scene', { destinationIn: ..., sourceOut: ... });
   * ```
   *
   * This can be used to configure custom transitions for a scene dynamically
   */
  onTransition(t) {
  }
  /**
   * This is called before the first update of the {@apilink Scene}. Initializes scene members like the camera. This method is meant to be
   * overridden. This is where initialization of child actors should take place.
   */
  onInitialize(t) {
  }
  /**
   * This is called when the scene is made active and started. It is meant to be overridden,
   * this is where you should setup any DOM UI or event handlers needed for the scene.
   */
  onActivate(t) {
  }
  /**
   * This is called when the scene is made transitioned away from and stopped. It is meant to be overridden,
   * this is where you should cleanup any DOM UI or event handlers needed for the scene.
   * @returns Either data to pass to the next scene activation context as `previousSceneData` or nothing
   */
  onDeactivate(t) {
  }
  /**
   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
   *
   * `onPreUpdate` is called directly before a scene is updated.
   * @param engine reference to the engine
   * @param elapsed  Number of milliseconds elapsed since the last draw.
   */
  onPreUpdate(t, e) {
  }
  /**
   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
   *
   * `onPostUpdate` is called directly after a scene is updated.
   * @param engine reference to the engine
   * @param elapsed  Number of milliseconds elapsed since the last draw.
   */
  onPostUpdate(t, e) {
  }
  /**
   * Safe to override onPreDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
   *
   * `onPreDraw` is called directly before a scene is drawn.
   *
   */
  onPreDraw(t, e) {
  }
  /**
   * Safe to override onPostDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
   *
   * `onPostDraw` is called directly after a scene is drawn.
   *
   */
  onPostDraw(t, e) {
  }
  /**
   * Initializes actors in the scene
   */
  _initializeChildren() {
    for (const t of this.entities)
      t._initialize(this.engine);
  }
  /**
   * Gets whether or not the {@apilink Scene} has been initialized
   */
  get isInitialized() {
    return this._isInitialized;
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Initializes the scene before the first update, meant to be called by engine not by users of
   * Excalibur
   * @internal
   */
  async _initialize(t) {
    var e;
    if (!this.isInitialized) {
      try {
        this.engine = t, this.physics.config = this.engine.physics, this.input = new Zr({
          global: t.global,
          pointerTarget: t.pointerScope === $e.Canvas ? t.canvas : document,
          grabWindowFocus: t.grabWindowFocus,
          engine: t
        }), this.camera._initialize(t), this.world.systemManager.initialize(), await this.onInitialize(t), this._initializeChildren(), this._logger.debug("Scene.onInitialize", this, t), this.events.emit("initialize", new Ke(t, this));
      } catch (i) {
        throw this._logger.error(`Error during scene initialization for scene ${(e = t.director) == null ? void 0 : e.getSceneName(this)}!`), i;
      }
      this._isInitialized = !0;
    }
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Activates the scene with the base behavior, then calls the overridable `onActivate` implementation.
   * @internal
   */
  async _activate(t) {
    var e, i;
    try {
      this._logger.debug("Scene.onActivate", this), this.input.toggleEnabled(!0), await this.onActivate(t);
    } catch (s) {
      throw this._logger.error(`Error during scene activation for scene ${(i = (e = this.engine) == null ? void 0 : e.director) == null ? void 0 : i.getSceneName(this)}!`), s;
    }
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Deactivates the scene with the base behavior, then calls the overridable `onDeactivate` implementation.
   * @internal
   */
  async _deactivate(t) {
    return this._logger.debug("Scene.onDeactivate", this), this.input.toggleEnabled(!1), await this.onDeactivate(t);
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _preupdate handler for {@apilink onPreUpdate} lifecycle event
   * @internal
   */
  _preupdate(t, e) {
    this.emit("preupdate", new pe(t, e, this)), this.onPreUpdate(t, e);
  }
  /**
   *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _preupdate handler for {@apilink onPostUpdate} lifecycle event
   * @internal
   */
  _postupdate(t, e) {
    this.emit("postupdate", new me(t, e, this)), this.onPostUpdate(t, e);
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _predraw handler for {@apilink onPreDraw} lifecycle event
   * @internal
   */
  _predraw(t, e) {
    this.emit("predraw", new Qe(t, e, this)), this.onPreDraw(t, e);
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _postdraw handler for {@apilink onPostDraw} lifecycle event
   * @internal
   */
  _postdraw(t, e) {
    this.emit("postdraw", new Je(t, e, this)), this.onPostDraw(t, e);
  }
  /**
   * Updates all the actors and timers in the scene. Called by the {@apilink Engine}.
   * @param engine  Reference to the current Engine
   * @param elapsed   The number of milliseconds since the last update
   */
  update(t, e) {
    var i;
    if (!this.isInitialized) {
      this._logger.warnOnce(`Scene update called before initialize for scene ${(i = t.director) == null ? void 0 : i.getSceneName(this)}!`);
      return;
    }
    this._preupdate(t, e);
    let s, n;
    for (s = 0, n = this._cancelQueue.length; s < n; s++)
      this.removeTimer(this._cancelQueue[s]);
    this._cancelQueue.length = 0;
    for (const o of this._timers)
      o.update(e);
    this.world.update(Mt.Update, e), this.camera && this.camera.update(t, e), this._collectActorStats(t), this._postupdate(t, e), this.input.update();
  }
  /**
   * Draws all the actors in the Scene. Called by the {@apilink Engine}.
   * @param ctx    The current rendering context
   * @param elapsed  The number of milliseconds since the last draw
   */
  draw(t, e) {
    var i;
    if (!this.isInitialized) {
      this._logger.warnOnce("Scene draw called before initialize!");
      return;
    }
    this._predraw(t, e), this.world.update(Mt.Draw, e), (i = this.engine) != null && i.isDebug && this.debugDraw(t), this._postdraw(t, e);
  }
  /**
   * Draws all the actors' debug information in the Scene. Called by the {@apilink Engine}.
   * @param ctx  The current rendering context
   */
  /* istanbul ignore next */
  debugDraw(t) {
    this.emit("predebugdraw", new Sn(t, this)), this.emit("postdebugdraw", new An(t, this));
  }
  /**
   * Checks whether an actor is contained in this scene or not
   */
  contains(t) {
    return this.actors.indexOf(t) > -1;
  }
  add(t) {
    if (this.emit("entityadded", { target: t }), t instanceof Wi) {
      Xn(this._timers, t) || this.addTimer(t);
      return;
    }
    this.world.add(t), t.scene = this;
  }
  /**
   * Removes an {@apilink Entity} (Actor, TileMap, Trigger, etc) or {@apilink Timer} from it's current scene
   * and adds it to this scene.
   *
   * Useful if you want to have an object be present in only 1 scene at a time.
   * @param entity
   */
  transfer(t) {
    let e;
    t instanceof Rt && t.scene && t.scene !== this && (e = t.scene, t.scene.world.remove(t, !1)), t instanceof Wi && t.scene && (e = t.scene, t.scene.removeTimer(t)), e == null || e.emit("entityremoved", { target: t }), this.add(t);
  }
  remove(t) {
    this.emit("entityremoved", { target: t }), t instanceof Rt && (t.isActive && t.kill(), this.world.remove(t)), t instanceof Wi && this.removeTimer(t);
  }
  /**
   * Removes all entities and timers from the scene, optionally indicate whether deferred should or shouldn't be used.
   *
   * By default entities use deferred removal
   * @param deferred
   */
  clear(t = !0) {
    for (let e = this.entities.length - 1; e >= 0; e--)
      this.world.remove(this.entities[e], t);
    for (let e = this.timers.length - 1; e >= 0; e--)
      this.removeTimer(this.timers[e]);
  }
  /**
   * Adds a {@apilink Timer} to the scene
   * @param timer  The timer to add
   */
  addTimer(t) {
    return this._timers.push(t), t.scene = this, t;
  }
  /**
   * Removes a {@apilink Timer} from the scene.
   * @warning Can be dangerous, use {@apilink cancelTimer} instead
   * @param timer  The timer to remove
   */
  removeTimer(t) {
    const e = this._timers.indexOf(t);
    return e !== -1 && this._timers.splice(e, 1), t;
  }
  /**
   * Cancels a {@apilink Timer}, removing it from the scene nicely
   * @param timer  The timer to cancel
   */
  cancelTimer(t) {
    return this._cancelQueue.push(t), t;
  }
  /**
   * Tests whether a {@apilink Timer} is active in the scene
   */
  isTimerActive(t) {
    return this._timers.indexOf(t) > -1 && !t.complete;
  }
  isCurrentScene() {
    return this.engine ? this.engine.currentScene === this : !1;
  }
  _collectActorStats(t) {
    const e = this.actors;
    for (let i = 0; i < e.length; i++) {
      const s = e[i];
      s instanceof Hr && t.stats.currFrame.actors.ui++, t.stats.currFrame.actors.alive++;
      for (let n = 0; n < s.children.length; n++) {
        const o = s.children[n];
        ch(o) ? t.stats.currFrame.actors.ui++ : t.stats.currFrame.actors.alive++;
      }
    }
  }
}
class Mh {
  constructor(t) {
    this._engine = t, this._colorBlindPostProcessor = new jo(qe.Protanope);
  }
  /**
   * Correct colors for a specified color blindness
   * @param colorBlindness
   */
  correct(t) {
    this._engine.graphicsContext instanceof Qt && (this.clear(), this._colorBlindPostProcessor.colorBlindnessMode = t, this._colorBlindPostProcessor.simulate = !1, this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor));
  }
  /**
   * Simulate colors for a specified color blindness
   * @param colorBlindness
   */
  simulate(t) {
    this._engine.graphicsContext instanceof Qt && (this.clear(), this._colorBlindPostProcessor.colorBlindnessMode = t, this._colorBlindPostProcessor.simulate = !0, this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor));
  }
  /**
   * Remove color blindness post processor
   */
  clear() {
    this._engine.graphicsContext.removePostProcessor(this._colorBlindPostProcessor);
  }
}
class Fh {
  constructor(t) {
    this.stats = {
      /**
       * Current frame statistics. Engine reuses this instance, use {@apilink FrameStats.clone} to copy frame stats.
       * Best accessed on {@apilink postframe} event. See {@apilink FrameStats}
       */
      currFrame: new Ti(),
      /**
       * Previous frame statistics. Engine reuses this instance, use {@apilink FrameStats.clone} to copy frame stats.
       * Best accessed on {@apilink preframe} event. Best inspected on engine event `preframe`. See {@apilink FrameStats}
       */
      prevFrame: new Ti()
    }, this.settings = {
      text: {
        foreground: T.Black,
        background: T.Transparent,
        border: T.Transparent
      },
      z: {
        text: Number.POSITIVE_INFINITY,
        point: Number.MAX_SAFE_INTEGER - 1,
        ray: Number.MAX_SAFE_INTEGER - 1,
        dashed: Number.MAX_SAFE_INTEGER - 2,
        solid: Number.MAX_SAFE_INTEGER - 3
      }
    }, this.filter = {
      /**
       * Toggle filter on or off (default off) must be on for DebugDraw to use filters
       */
      useFilter: !1,
      /**
       * Query for entities by name, if the entity name contains `nameQuery` it will be included
       */
      nameQuery: "",
      /**
       * Query for Entity ids, if the id matches it will be included
       */
      ids: []
    }, this.entity = {
      showAll: !1,
      showId: !1,
      showName: !1
    }, this.transform = {
      showAll: !1,
      showPosition: !1,
      showPositionLabel: !1,
      positionColor: T.Yellow,
      showZIndex: !1,
      showScale: !1,
      scaleColor: T.Green,
      showRotation: !1,
      rotationColor: T.Blue
    }, this.graphics = {
      showAll: !1,
      showBounds: !1,
      boundsColor: T.Yellow
    }, this.collider = {
      showAll: !1,
      showBounds: !1,
      boundsColor: T.Blue,
      showOwner: !1,
      showGeometry: !0,
      geometryColor: T.Green,
      geometryLineWidth: 2,
      geometryPointSize: 2
    }, this.physics = {
      showAll: !1,
      showBroadphaseSpacePartitionDebug: !1,
      showCollisionNormals: !1,
      collisionNormalColor: T.Cyan,
      showCollisionContacts: !0,
      contactSize: 10,
      collisionContactColor: T.Red
    }, this.motion = {
      showAll: !1,
      showVelocity: !1,
      velocityColor: T.Yellow,
      showAcceleration: !1,
      accelerationColor: T.Red
    }, this.body = {
      showAll: !1,
      showCollisionGroup: !1,
      showCollisionType: !1,
      showSleeping: !1,
      showMotion: !1,
      showMass: !1
    }, this.camera = {
      showAll: !1,
      showFocus: !1,
      focusColor: T.Red,
      showZoom: !1
    }, this.tilemap = {
      showAll: !1,
      showGrid: !1,
      gridColor: T.Red,
      gridWidth: 0.5,
      showSolidBounds: !1,
      solidBoundsColor: T.fromHex("#8080807F"),
      // grayish
      showColliderGeometry: !0
    }, this.isometric = {
      showAll: !1,
      showPosition: !1,
      positionColor: T.Yellow,
      positionSize: 1,
      showGrid: !1,
      gridColor: T.Red,
      gridWidth: 1,
      showColliderGeometry: !0
    }, this._engine = t, this.colorBlindMode = new Mh(this._engine), St.registerDebugConfig(this);
  }
  /**
   * Switch the current excalibur clock with the {@apilink TestClock} and return
   * it in the same running state.
   *
   * This is useful when you need to debug frame by frame.
   */
  useTestClock() {
    const t = this._engine.clock, e = t.isRunning();
    t.stop();
    const i = t.toTestClock();
    return e && i.start(), this._engine.clock = i, i;
  }
  /**
   * Switch the current excalibur clock with the {@apilink StandardClock} and
   * return it in the same running state.
   *
   * This is useful when you need to switch back to normal mode after
   * debugging.
   */
  useStandardClock() {
    const t = this._engine.clock, e = t.isRunning();
    t.stop();
    const i = t.toStandardClock();
    return e && i.start(), this._engine.clock = i, i;
  }
}
class Ti {
  constructor() {
    this._id = 0, this._elapsedMs = 0, this._fps = 0, this._actorStats = {
      alive: 0,
      killed: 0,
      ui: 0,
      get remaining() {
        return this.alive - this.killed;
      },
      get total() {
        return this.remaining + this.ui;
      }
    }, this._durationStats = {
      update: 0,
      draw: 0,
      get total() {
        return this.update + this.draw;
      }
    }, this._physicsStats = new Is(), this._graphicsStats = {
      drawCalls: 0,
      drawnImages: 0,
      rendererSwaps: 0
    }, this.systemDuration = {};
  }
  /**
   * Zero out values or clone other IFrameStat stats. Allows instance reuse.
   * @param [otherStats] Optional stats to clone
   */
  reset(t) {
    if (t) {
      this.id = t.id, this.elapsedMs = t.elapsedMs, this.fps = t.fps, this.actors.alive = t.actors.alive, this.actors.killed = t.actors.killed, this.actors.ui = t.actors.ui, this.duration.update = t.duration.update, this.duration.draw = t.duration.draw;
      for (const e in t.systemDuration)
        this.systemDuration[e] = t.systemDuration[e];
      this._physicsStats.reset(t.physics), this.graphics.drawCalls = t.graphics.drawCalls, this.graphics.drawnImages = t.graphics.drawnImages, this.graphics.rendererSwaps = t.graphics.rendererSwaps;
    } else {
      this.id = this.elapsedMs = this.fps = 0, this.actors.alive = this.actors.killed = this.actors.ui = 0, this.duration.update = this.duration.draw = 0, this._physicsStats.reset(), this.graphics.drawnImages = this.graphics.drawCalls = this.graphics.rendererSwaps = 0;
      for (const e in this.systemDuration)
        this.systemDuration[e] = 0;
    }
  }
  /**
   * Provides a clone of this instance.
   */
  clone() {
    const t = new Ti();
    return t.reset(this), t;
  }
  /**
   * Gets the frame's id
   */
  get id() {
    return this._id;
  }
  /**
   * Sets the frame's id
   */
  set id(t) {
    this._id = t;
  }
  /**
   * Gets the frame's delta (time since last frame)
   */
  get elapsedMs() {
    return this._elapsedMs;
  }
  /**
   * Sets the frame's delta (time since last frame). Internal use only.
   * @internal
   */
  set elapsedMs(t) {
    this._elapsedMs = t;
  }
  /**
   * Gets the frame's frames-per-second (FPS)
   */
  get fps() {
    return this._fps;
  }
  /**
   * Sets the frame's frames-per-second (FPS). Internal use only.
   * @internal
   */
  set fps(t) {
    this._fps = t;
  }
  /**
   * Gets the frame's actor statistics
   */
  get actors() {
    return this._actorStats;
  }
  /**
   * Gets the frame's duration statistics
   */
  get duration() {
    return this._durationStats;
  }
  /**
   * Gets the frame's physics statistics
   */
  get physics() {
    return this._physicsStats;
  }
  /**
   * Gets the frame's graphics statistics
   */
  get graphics() {
    return this._graphicsStats;
  }
}
class Is {
  constructor() {
    this._pairs = 0, this._collisions = 0, this._contacts = /* @__PURE__ */ new Map(), this._fastBodies = 0, this._fastBodyCollisions = 0, this._broadphase = 0, this._narrowphase = 0;
  }
  /**
   * Zero out values or clone other IPhysicsStats stats. Allows instance reuse.
   * @param [otherStats] Optional stats to clone
   */
  reset(t) {
    t ? (this.pairs = t.pairs, this.collisions = t.collisions, this.contacts = t.contacts, this.fastBodies = t.fastBodies, this.fastBodyCollisions = t.fastBodyCollisions, this.broadphase = t.broadphase, this.narrowphase = t.narrowphase) : (this.pairs = this.collisions = this.fastBodies = 0, this.fastBodyCollisions = this.broadphase = this.narrowphase = 0, this.contacts.clear());
  }
  /**
   * Provides a clone of this instance.
   */
  clone() {
    const t = new Is();
    return t.reset(this), t;
  }
  get pairs() {
    return this._pairs;
  }
  set pairs(t) {
    this._pairs = t;
  }
  get collisions() {
    return this._collisions;
  }
  set collisions(t) {
    this._collisions = t;
  }
  get contacts() {
    return this._contacts;
  }
  set contacts(t) {
    this._contacts = t;
  }
  get fastBodies() {
    return this._fastBodies;
  }
  set fastBodies(t) {
    this._fastBodies = t;
  }
  get fastBodyCollisions() {
    return this._fastBodyCollisions;
  }
  set fastBodyCollisions(t) {
    this._fastBodyCollisions = t;
  }
  get broadphase() {
    return this._broadphase;
  }
  set broadphase(t) {
    this._broadphase = t;
  }
  get narrowphase() {
    return this._narrowphase;
  }
  set narrowphase(t) {
    this._narrowphase = t;
  }
}
class en {
  constructor(t) {
    this.nativeComponent = t, this._paused = !1, this._nativeHandlers = {};
  }
  on(t, e) {
    this._nativeHandlers[t] && this.off(t, this._nativeHandlers[t]), this._nativeHandlers[t] = this._decorate(e), this.nativeComponent.addEventListener(t, this._nativeHandlers[t]);
  }
  off(t, e) {
    e || (e = this._nativeHandlers[t]), this.nativeComponent.removeEventListener(t, e), this._nativeHandlers[t] = null;
  }
  _decorate(t) {
    return (e) => {
      this._paused || t(e);
    };
  }
  pause() {
    this._paused = !0;
  }
  resume() {
    this._paused = !1;
  }
  clear() {
    for (const t in this._nativeHandlers)
      this.off(t);
  }
}
class Dh {
  constructor(t, e) {
    this._windowGlobal = t, this._documentGlobal = e, this._windowComponent = new en(this._windowGlobal), this._documentComponent = new en(this._documentGlobal);
  }
  get window() {
    return this._windowComponent;
  }
  get document() {
    return this._documentComponent;
  }
  pause() {
    this.window.pause(), this.document.pause();
  }
  resume() {
    this.window.resume(), this.document.resume();
  }
  clear() {
    this.window.clear(), this.document.clear();
  }
}
class Bh {
  constructor(t) {
    this._samplePeriod = 100, this._currentFrameTime = 0, this._frames = 0, this._previousSampleTime = 0, this._beginFrameTime = 0;
    var e;
    this._fps = t.initialFps, this._samplePeriod = (e = t.samplePeriod) != null ? e : this._samplePeriod, this._currentFrameTime = 1e3 / t.initialFps, this._nowFn = t.nowFn, this._previousSampleTime = this._nowFn();
  }
  /**
   * Start of code block to sample FPS for
   */
  start() {
    this._beginFrameTime = this._nowFn();
  }
  /**
   * End of code block to sample FPS for
   */
  end() {
    this._frames++;
    const t = this._nowFn();
    this._currentFrameTime = t - this._beginFrameTime, t >= this._previousSampleTime + this._samplePeriod && (this._fps = this._frames * 1e3 / (t - this._previousSampleTime), this._previousSampleTime = t, this._frames = 0);
  }
  /**
   * Return the currently sampled fps over the last sample period, by default every 100ms
   */
  get fps() {
    return this._fps;
  }
  /**
   * Return the instantaneous fps, this can be less useful because it will fluctuate given the current frames time
   */
  get instant() {
    return 1e3 / this._currentFrameTime;
  }
}
class jr {
  constructor(t) {
    this._onFatalException = () => {
    }, this._maxFps = 1 / 0, this._lastTime = 0, this._elapsed = 1, this._scheduledCbs = [], this._totalElapsed = 0, this._nextScheduleId = 0, this._idsToRemove = [];
    var e, i, s;
    this._options = t, this.tick = t.tick, this._lastTime = (e = this.now()) != null ? e : 0, this._maxFps = (i = t.maxFps) != null ? i : this._maxFps, this._onFatalException = (s = t.onFatalException) != null ? s : this._onFatalException, this.fpsSampler = new Bh({
      initialFps: 60,
      nowFn: () => this.now()
    });
  }
  /**
   * Get the elapsed time for the last completed frame
   */
  elapsed() {
    return this._elapsed;
  }
  /**
   * Get the current time in milliseconds
   */
  now() {
    return performance.now();
  }
  toTestClock() {
    return new kh({
      ...this._options,
      defaultUpdateMs: 16.6
    });
  }
  toStandardClock() {
    return new Qr({
      ...this._options
    });
  }
  setFatalExceptionHandler(t) {
    this._onFatalException = t;
  }
  /**
   * Schedule a callback to fire given a timeout in milliseconds using the excalibur {@apilink Clock}
   *
   * This is useful to use over the built in browser `setTimeout` because callbacks will be tied to the
   * excalibur update clock, instead of browser time, this means that callbacks wont fire if the game is
   * stopped or paused.
   * @param cb callback to fire
   * @param timeoutMs Optionally specify a timeout in milliseconds from now, default is 0ms which means the next possible tick
   * @param timing Optionally specify a timeout in milliseconds from now, default is 0ms which means the next possible tick
   * @returns A unique identifier that can be used to clear the scheduled callback with {@apilink clearSchedule}
   */
  schedule(t, e = 0, i = "preframe") {
    const s = this._totalElapsed + e, n = this._nextScheduleId++;
    return this._scheduledCbs.push([n, t, s, i]), n;
  }
  /**
   * Clears a scheduled callback using the ID returned from {@apilink schedule}
   * @param id The ID of the scheduled callback to clear
   */
  clearSchedule(t) {
    this._idsToRemove.push(t);
  }
  /**
   * Called internally to trigger scheduled callbacks in the clock
   * @param timing
   * @internal
   */
  __runScheduledCbs(t = "preframe") {
    for (let e = this._scheduledCbs.length - 1; e > -1; e--) {
      const [i, s, n, o] = this._scheduledCbs[e];
      this._idsToRemove.includes(i) || t === o && n <= this._totalElapsed && (s(this._elapsed), this._scheduledCbs.splice(e, 1));
    }
    for (const e of this._idsToRemove) {
      const i = this._scheduledCbs.findIndex(([s]) => s === e);
      i !== -1 && this._scheduledCbs.splice(i, 1);
    }
  }
  update(t) {
    try {
      this.fpsSampler.start();
      const e = this.now();
      let i = e - this._lastTime || 1;
      const s = 1e3 / this._maxFps;
      if (i >= s) {
        let n = 0;
        s !== 0 && (n = i % s, i = i - n), i > 200 && (i = 1), this._elapsed = t || i, this._totalElapsed += this._elapsed, this.__runScheduledCbs("preframe"), this.tick(t || i), this.__runScheduledCbs("postframe"), s !== 0 ? this._lastTime = e - n : this._lastTime = e, this.fpsSampler.end();
      }
    } catch (e) {
      this._onFatalException(e), this.stop();
    }
  }
}
class Qr extends jr {
  constructor(t) {
    super(t), this._running = !1;
  }
  isRunning() {
    return this._running;
  }
  start() {
    if (this._running)
      return;
    this._running = !0;
    const t = () => {
      if (this._running)
        try {
          this._requestId = window.requestAnimationFrame(t), this.update();
        } catch (e) {
          throw window.cancelAnimationFrame(this._requestId), e;
        }
    };
    t();
  }
  stop() {
    window.cancelAnimationFrame(this._requestId), this._running = !1;
  }
}
class kh extends jr {
  constructor(t) {
    super({
      ...t
    }), this._logger = R.getInstance(), this._running = !1, this._currentTime = 0, this._updateMs = t.defaultUpdateMs;
  }
  /**
   * Get the current time in milliseconds
   */
  now() {
    var t;
    return (t = this._currentTime) != null ? t : 0;
  }
  isRunning() {
    return this._running;
  }
  start() {
    this._running = !0;
  }
  stop() {
    this._running = !1;
  }
  /**
   * Manually step the clock forward 1 tick, optionally specify an elapsed time in milliseconds
   * @param overrideUpdateMs
   */
  step(t) {
    const e = t != null ? t : this._updateMs;
    this._running ? (this.update(e), this._currentTime += e) : this._logger.warn("The clock is not running, no step will be performed");
  }
  /**
   * Run a number of steps that tick the clock, optionally specify an elapsed time in milliseconds
   * @param numberOfSteps
   * @param overrideUpdateMs
   */
  run(t, e) {
    for (let i = 0; i < t; i++)
      this.step(e != null ? e : this._updateMs);
  }
}
const Lh = "#ex-toast-container{position:absolute;height:0;min-width:50%;left:50%;top:0}.ex-toast-message{left:-50%;position:relative;display:flex;justify-content:space-between;padding:10px;margin-top:5px;font-size:18px;font-family:sans-serif;border-radius:6px;border:3px solid #b7b779;background-color:#fdfdc0}.ex-toast-message button{align-self:flex-start}";
class Uh {
  constructor() {
    this._toasterCss = Lh, this._isInitialized = !1;
  }
  _initialize() {
    this._isInitialized || (this._container = document.createElement("div"), this._container.id = "ex-toast-container", document.body.appendChild(this._container), this._isInitialized = !0, this._styleBlock = document.createElement("style"), this._styleBlock.textContent = this._toasterCss, document.head.appendChild(this._styleBlock));
  }
  dispose() {
    this._container.parentElement.removeChild(this._container), this._styleBlock.parentElement.removeChild(this._styleBlock), this._isInitialized = !1;
  }
  _createFragment(t) {
    const e = document.createElement("span");
    return e.innerText = t, e;
  }
  /**
   * Display a toast message to a player
   * @param message Text of the message, messages may have a single "[LINK]" to influence placement
   * @param linkTarget Optionally specify a link location
   * @param linkName Optionally specify a name for that link location
   */
  toast(t, e, i) {
    this._initialize();
    const s = document.createElement("div");
    s.className = "ex-toast-message";
    const n = t.split("[LINK]").map((c) => this._createFragment(c));
    if (e) {
      const c = document.createElement("a");
      c.href = e, i ? c.innerText = i : c.innerText = e, n.splice(1, 0, c);
    }
    const o = document.createElement("div");
    n.forEach((c) => {
      o.appendChild(c);
    }), s.appendChild(o);
    const a = document.createElement("button");
    a.innerText = "x", a.addEventListener("click", () => {
      this._container.removeChild(s);
    }), s.appendChild(a);
    const h = (c) => {
      if (c.key === "Escape")
        try {
          this._container.removeChild(s);
        } catch (d) {
        }
      document.removeEventListener("keydown", h);
    };
    document.addEventListener("keydown", h);
    const l = this._container.firstChild;
    this._container.insertBefore(s, l);
  }
}
const zh = {
  NavigationStart: "navigationstart",
  Navigation: "navigation",
  NavigationEnd: "navigationend"
};
class Hh {
  constructor(t, e) {
    this._engine = t, this.events = new X(), this._logger = R.getInstance(), this._initialized = !1, this.scenes = {}, this._sceneToInstance = /* @__PURE__ */ new Map(), this._sceneToLoader = /* @__PURE__ */ new Map(), this._sceneToTransition = /* @__PURE__ */ new Map(), this._loadedScenes = /* @__PURE__ */ new Set(), this._isTransitioning = !1, this.rootScene = this.currentScene = new Et(), this.add("root", this.rootScene), this.currentScene = this.rootScene, this.currentSceneName = "root";
    for (const i in e) {
      const s = e[i];
      this.add(i, s), i === "root" && (this.rootScene = this.getSceneInstance("root"), this.currentScene = this.rootScene);
    }
  }
  /**
   * Gets whether the director currently transitioning between scenes
   *
   * Useful if you need to block behavior during transition
   */
  get isTransitioning() {
    return this._isTransitioning;
  }
  /**
   * Initialize the director's internal state
   */
  async onInitialize() {
    if (!this._initialized)
      if (this._initialized = !0, this._deferredGoto) {
        const t = this._deferredGoto;
        this._deferredGoto = void 0;
        const e = this._deferredTransition;
        this._deferredTransition = void 0;
        const i = this.getSceneInstance(t);
        i && e && e._addToTargetScene(this._engine, i);
        const s = this._getInTransition(t), n = s == null ? void 0 : s.hideLoader;
        this.maybeLoadScene(t, n), await this.swapScene(t), i && e && await this.playTransition(e, i);
      } else
        await this.swapScene("root");
  }
  get isInitialized() {
    return this._initialized;
  }
  /**
   * Configures the start scene, and optionally the transition & loader for the director
   *
   * Typically this is called at the beginning of the game to the start scene and transition and never again.
   * @param startScene
   * @param options
   */
  configureStart(t, e) {
    var i, s;
    const n = e == null ? void 0 : e.loader;
    n instanceof yi ? this.mainLoader = n : Qs(n) ? this.mainLoader = new n() : this.mainLoader = new as();
    let o;
    if (e != null && e.inTransition) {
      const { inTransition: h } = e;
      o = h;
    }
    this.startScene = t;
    const a = (s = (i = e == null ? void 0 : e.inTransition) == null ? void 0 : i.hideLoader) != null ? s : !1;
    if (this.maybeLoadScene(t, a), o) {
      const h = this.getSceneInstance(t);
      h && (o._addToTargetScene(this._engine, h), this.swapScene(t).then(() => (h.onTransition("in"), this.playTransition(o, h))));
    } else
      this.swapScene(t);
    this.currentSceneName = this.startScene;
  }
  _getLoader(t) {
    return this._sceneToLoader.get(t);
  }
  _getInTransition(t) {
    var e;
    const i = this.scenes[t];
    if (!(i instanceof Et || Xt(i)))
      return (e = i == null ? void 0 : i.transitions) == null ? void 0 : e.in;
  }
  _getOutTransition(t) {
    var e;
    const i = this.scenes[t];
    if (!(i instanceof Et || Xt(i)))
      return (e = i == null ? void 0 : i.transitions) == null ? void 0 : e.out;
  }
  getDeferredScene() {
    const t = this.getSceneDefinition(this._deferredGoto);
    return this._deferredGoto && t ? t : null;
  }
  /**
   * Returns a scene by name if it exists, might be the constructor and not the instance of a scene
   * @param name
   */
  getSceneDefinition(t) {
    const e = this.scenes[t];
    if (e instanceof Et || Xt(e))
      return e;
    if (e)
      return e.scene;
  }
  /**
   * Returns the name of the registered scene, null if none can be found
   * @param scene
   */
  getSceneName(t) {
    for (const [e, i] of Object.entries(this.scenes))
      if (i instanceof Et) {
        if (t === i)
          return e;
      } else if (!Xt(i) && t === i.scene)
        return e;
    for (const [e, i] of Object.entries(this.scenes))
      if (Xt(i)) {
        if (t.constructor === i)
          return e;
      } else if (!(i instanceof Et) && t.constructor === i.scene)
        return e;
    return null;
  }
  /**
   * Returns the same Director, but asserts a scene DOES exist to the type system
   * @param name
   */
  assertAdded(t) {
    return this;
  }
  /**
   * Returns the same Director, but asserts a scene DOES NOT exist to the type system
   * @param name
   */
  assertRemoved(t) {
    return this;
  }
  /**
   * Adds additional Scenes to the game!
   * @param name
   * @param sceneOrRoute
   */
  add(t, e) {
    if (!(e instanceof Et) && !Xt(e)) {
      const { loader: i, transitions: s } = e, { in: n, out: o } = s != null ? s : {};
      this._sceneToTransition.set(t, { in: n, out: o }), Qs(i) ? this._sceneToLoader.set(t, new i()) : i && this._sceneToLoader.set(t, i);
    }
    return this.scenes[t] && this._logger.warn("Scene", t, "already exists overwriting"), this.scenes[t] = e, this.assertAdded(t);
  }
  remove(t) {
    if (t instanceof Et || Xt(t)) {
      const e = t;
      for (const i in this.scenes)
        if (this.scenes.hasOwnProperty(i)) {
          const s = this.scenes[i];
          let n;
          if (s instanceof Et || Xt(s) ? n = s : n = s.scene, n === e) {
            if (i === this.currentSceneName)
              throw new Error(`Cannot remove a currently active scene: ${i}`);
            this._sceneToInstance.delete(i), this._sceneToTransition.delete(i), this._sceneToLoader.delete(i), delete this.scenes[i];
          }
        }
    }
    if (typeof t == "string") {
      if (t === this.currentSceneName)
        throw new Error(`Cannot remove a currently active scene: ${t}`);
      this._sceneToInstance.delete(t), this._sceneToTransition.delete(t), this._sceneToLoader.delete(t), delete this.scenes[t];
    }
  }
  /**
   * Go to a specific scene, and optionally override loaders and transitions
   * @param destinationScene
   * @param options
   */
  async goToScene(t, e) {
    var i, s, n, o, a, h;
    const l = this.getSceneInstance(t);
    if (!l) {
      this._logger.warn(`Scene ${t} does not exist! Check the name, are you sure you added it?`);
      return;
    }
    const c = this.currentScene, d = this.currentSceneName, u = (s = (i = this._engine.input) == null ? void 0 : i.enabled) != null ? s : !0;
    this._isTransitioning = !0;
    const _ = (n = this.getSceneInstance(d)) == null ? void 0 : n.onTransition("out"), p = l == null ? void 0 : l.onTransition("in");
    e = {
      sourceOut: (o = this._getOutTransition(this.currentSceneName)) != null ? o : _,
      destinationIn: (a = this._getInTransition(t)) != null ? a : p,
      // Goto options
      ...e
    };
    const { sourceOut: g, destinationIn: x, sceneActivationData: m } = e, f = g != null ? g : this._getOutTransition(this.currentSceneName), b = x != null ? x : this._getInTransition(t), C = (f == null ? void 0 : f.hideLoader) || (b == null ? void 0 : b.hideLoader);
    C && this.maybeLoadScene(t, C), this._emitEvent("navigationstart", d, t), f && await this.playTransition(f, c), await this.maybeLoadScene(t, C), b && await b.onPreviousSceneDeactivate(this.currentScene), b && b._addToTargetScene(this._engine, l), await this.swapScene(t, m), this._emitEvent("navigation", d, t), b && await this.playTransition(b, l), this._emitEvent("navigationend", d, t), (h = this._engine.input) == null || h.toggleEnabled(u), this._isTransitioning = !1;
  }
  /**
   * Retrieves a scene instance by key if it's registered.
   *
   * This will call any constructors that were given as a definition
   * @param scene
   */
  getSceneInstance(t) {
    const e = this.getSceneDefinition(t);
    if (!e)
      return;
    if (this._sceneToInstance.has(t))
      return this._sceneToInstance.get(t);
    if (e instanceof Et)
      return this._sceneToInstance.set(t, e), e;
    const i = new e();
    return this._sceneToInstance.set(t, i), i;
  }
  /**
   * Triggers scene loading if has not already been loaded
   * @param scene
   * @param hideLoader
   */
  async maybeLoadScene(t, e = !1) {
    var i;
    const s = (i = this._getLoader(t)) != null ? i : new yi(), n = this.getSceneDefinition(t), o = this.getSceneInstance(t);
    n && o && !this._loadedScenes.has(o) && (o.onPreLoad(s), o.events.emit("preload", { loader: s }), e ? this._engine.load(s, e) : await this._engine.load(s), this._loadedScenes.add(o));
  }
  /**
   * Plays a transition in the current scene and does book keeping for input.
   * @param transition
   */
  async playTransition(t, e) {
    var i, s, n, o, a, h, l;
    if (!this.isInitialized) {
      this._deferredTransition = t;
      return;
    }
    if (t) {
      this.currentTransition = t;
      const c = (s = (i = e.input) == null ? void 0 : i.enabled) != null ? s : !0;
      (n = e.input) == null || n.toggleEnabled(!t.blockInput), (o = this._engine.input) == null || o.toggleEnabled(!t.blockInput), e.events.emit("transitionstart", t), this.currentTransition._addToTargetScene(this._engine, e), await this.currentTransition._play(), e.events.emit("transitionend", t), (a = e.input) == null || a.toggleEnabled(c);
    }
    (h = this.currentTransition) == null || h.kill(), (l = this.currentTransition) == null || l.reset(), this.currentTransition = void 0;
  }
  /**
   * Swaps the current and destination scene after performing required lifecycle events
   *
   * Note: swap scene will wait for any pending loader on the destination scene
   * @param destinationScene
   * @param data
   */
  async swapScene(t, e) {
    const i = this._engine;
    if (!this.isInitialized) {
      this._deferredGoto = t;
      return;
    }
    const s = this.getSceneInstance(t);
    if (s) {
      const n = this.currentScene, o = s;
      let a;
      if (this._logger.debug("Going to scene:", t), this.currentScene.isInitialized) {
        const c = { engine: i, previousScene: n, nextScene: o };
        a = await this.currentScene._deactivate(c), this.currentScene.events.emit("deactivate", new Ln(c, this.currentScene)), this.currentScene.input.clear();
      }
      const h = this._sceneToLoader.get(t);
      await (h == null ? void 0 : h.areResourcesLoaded()), this.currentScene = o, this.currentSceneName = t, i.screen.setCurrentCamera(o.camera), await this.currentScene._initialize(i);
      const l = { engine: i, previousScene: n, previousSceneData: a, nextScene: o, data: e };
      await this.currentScene._activate(l), this.currentScene.events.emit("activate", new kn(l, this.currentScene));
    } else
      this._logger.error("Scene", t, "does not exist!");
  }
  _emitEvent(t, e, i) {
    const s = this.getSceneDefinition(e), n = this.getSceneDefinition(i);
    this.events.emit(t, {
      sourceScene: s,
      sourceName: e,
      destinationScene: n,
      destinationName: i
    });
  }
}
function Jr() {
  const r = {
    scope: (t, e) => {
      const i = r.value;
      r.value = t;
      try {
        const s = e();
        return s && typeof s.then == "function" ? s.finally(() => {
          r.value = i;
        }) : s;
      } catch (s) {
        throw s;
      } finally {
        r.value = i;
      }
    },
    value: void 0
  };
  return r;
}
function Kr(r) {
  return r.value;
}
const sn = {
  textureCollectInterval: 6e4
  // TODO future work to integrate the font and text configuration, refactor existing collection mechanism
  // fontCollectInterval: 60_000,
  // textMeasurementCollectInterval: 60_000,
};
class Oh {
  constructor(t) {
    this.options = t, this._running = !1, this._collectionMap = /* @__PURE__ */ new Map(), this._collectors = /* @__PURE__ */ new Map(), this.collectStaleResources = (e) => {
      if (this._running) {
        for (const [i, [s, n]] of this._collectors.entries()) {
          const o = this.options.getTimestamp();
          for (const [a, [h, l]] of this._collectionMap.entries()) {
            if (i !== h || l + n >= o)
              continue;
            s(a) && this._collectionMap.delete(a);
          }
        }
        this._collectHandle = requestIdleCallback(this.collectStaleResources);
      }
    };
  }
  /**
   *
   * @param type Resource type
   * @param timeoutInterval If resource type exceeds interval in milliseconds collect() is called
   * @param collect Collection implementation, returns true if collected
   */
  registerCollector(t, e, i) {
    this._collectors.set(t, [i, e]);
  }
  /**
   * Add a resource to be tracked for collection
   * @param type
   * @param resource
   */
  addCollectableResource(t, e) {
    this._collectionMap.set(e, [t, this.options.getTimestamp()]);
  }
  /**
   * Update the resource last used timestamp preventing collection
   * @param resource
   */
  touch(t) {
    const e = this._collectionMap.get(t);
    e && this._collectionMap.set(t, [e[0], this.options.getTimestamp()]);
  }
  /**
   * Force collect all resources, useful for shutting down a game
   * or if you know that you will not use anything you've allocated before now
   */
  forceCollectAll() {
    for (const [t, [e]] of this._collectors.entries())
      for (const [i] of this._collectionMap.entries())
        e(i) && this._collectionMap.delete(i);
  }
  running() {
    return this._running;
  }
  /**
   * Starts the garbage collection loop
   */
  start() {
    this._running = !0, this.collectStaleResources();
  }
  /**
   * Stops the garbage collection loop
   */
  stop() {
    this._running = !1, cancelIdleCallback(this._collectHandle);
  }
}
hn();
const ec = {
  FallbackGraphicsContext: "fallbackgraphicscontext",
  Initialize: "initialize",
  Visible: "visible",
  Hidden: "hidden",
  Start: "start",
  Stop: "stop",
  PreUpdate: "preupdate",
  PostUpdate: "postupdate",
  PreFrame: "preframe",
  PostFrame: "postframe",
  PreDraw: "predraw",
  PostDraw: "postdraw",
  ...zh
};
var Ne = /* @__PURE__ */ ((r) => (r[r.None = 0] = "None", r[r.Canvas = 1] = "Canvas", r[r.All = 2] = "All", r))(Ne || {});
const Li = class ie {
  /**
   * Creates a new game using the given {@apilink EngineOptions}. By default, if no options are provided,
   * the game will be rendered full screen (taking up all available browser window space).
   * You can customize the game rendering through {@apilink EngineOptions}.
   *
   * Example:
   *
   * ```js
   * var game = new ex.Engine({
   *   width: 0, // the width of the canvas
   *   height: 0, // the height of the canvas
   *   enableCanvasTransparency: true, // the transparencySection of the canvas
   *   canvasElementId: '', // the DOM canvas element ID, if you are providing your own
   *   displayMode: ex.DisplayMode.FullScreen, // the display mode
   *   pointerScope: ex.PointerScope.Document, // the scope of capturing pointer (mouse/touch) events
   *   backgroundColor: ex.Color.fromHex('#2185d0') // background color of the engine
   * });
   *
   * // call game.start, which is a Promise
   * game.start().then(function () {
   *   // ready, set, go!
   * });
   * ```
   */
  constructor(t) {
    this.scope = (S) => ie.Context.scope(this, S), this.version = an, this.events = new X(), this.maxFps = Number.POSITIVE_INFINITY, this._inputEnabled = !0, this._suppressPlayButton = !1, this.pauseAudioWhenHidden = !0, this._isDebug = !1, this.enableCanvasTransparency = !0, this.onFatalException = (S) => {
      R.getInstance().fatal(S, S.stack);
    }, this._toaster = new Uh(), this._timescale = 1, this._isInitialized = !1, this._hasCreatedCanvas = !1, this._originalOptions = {}, this._handleWebGLContextLost = (S) => {
      var I;
      S.preventDefault(), this.clock.stop(), this._logger.fatalOnce("WebGL Graphics Lost", S);
      const y = document.createElement("div");
      y.id = "ex-webgl-graphics-context-lost", y.style.position = "absolute", y.style.zIndex = "99", y.style.left = "50%", y.style.top = "50%", y.style.display = "flex", y.style.flexDirection = "column", y.style.transform = "translate(-50%, -50%)", y.style.backgroundColor = "white", y.style.padding = "10px", y.style.borderStyle = "solid 1px";
      const k = document.createElement("div");
      if (k.innerHTML = `
      <h1>There was an issue rendering, please refresh the page.</h1>
      <div>
        <p>WebGL Graphics Context Lost</p>

        <button id="ex-webgl-graphics-reload">Refresh Page</button>

        <p>There are a few reasons this might happen:</p>
        <ul>
          <li>Two or more pages are placing a high demand on the GPU</li>
          <li>Another page or operation has stalled the GPU and the browser has decided to reset the GPU</li>
          <li>The computer has multiple GPUs and the user has switched between them</li>
          <li>Graphics driver has crashed or restarted</li>
          <li>Graphics driver was updated</li>
        </ul>
      </div>
    `, y.appendChild(k), (I = this.canvas) != null && I.parentElement) {
        this.canvas.parentElement.appendChild(y);
        const L = k.querySelector("#ex-webgl-graphics-reload");
        L == null || L.addEventListener("click", () => location.reload());
      }
    }, this._performanceThresholdTriggered = !1, this._fpsSamples = [], this._disposed = !1, this._isLoading = !1, this._hideLoader = !1, this._isReadyFuture = new yt(), this.currentFrameElapsedMs = 0, this.currentFrameLagMs = 0, this._lagMs = 0, this._screenShotRequests = [];
    var e, i, s, n, o, a, h, l, c;
    t = { ...ie._DEFAULT_ENGINE_OPTIONS, ...t }, this._originalOptions = t, We.freeze(), this.browser = new Dh(window, document);
    const d = new lh();
    if (!t.suppressMinimumBrowserFeatureDetection && !(this._compatible = d.test())) {
      const S = document.createElement("div");
      if (S.innerText = "Sorry, your browser does not support all the features needed for Excalibur", document.body.appendChild(S), d.failedTests.forEach(function(I) {
        const y = document.createElement("div");
        y.innerText = "Browser feature missing " + I, document.body.appendChild(y);
      }), t.canvasElementId) {
        const I = document.getElementById(t.canvasElementId);
        I && I.parentElement.removeChild(I);
      }
      return;
    } else
      this._compatible = !0;
    if (console.log && !t.suppressConsoleBootMessage && (console.log(
      `%cPowered by Excalibur.js (v${an})`,
      "background: #176BAA; color: white; border-radius: 5px; padding: 15px; font-size: 1.5em; line-height: 80px;"
    ), console.log(
      `
      /| ________________
O|===|* >________________>
      \\|`
    ), console.log("Visit", "http://excaliburjs.com", "for more information")), t.suppressPlayButton && (this._suppressPlayButton = !0), this._logger = R.getInstance(), this.debug = new Fh(this), this._logger.defaultLevel === je.Debug && d.logBrowserFeatures(), this._logger.debug("Building engine..."), t.garbageCollection === !0 ? this.garbageCollectorConfig = {
      ...sn
    } : t.garbageCollection === !1 ? (this._logger.warn(
      "WebGL Garbage Collection Disabled!!! If you leak any images over time your game will crash when GPU memory is exhausted"
    ), this.garbageCollectorConfig = null) : this.garbageCollectorConfig = {
      ...sn,
      ...t.garbageCollection
    }, this._garbageCollector = new Oh({ getTimestamp: Date.now }), this.canvasElementId = t.canvasElementId, t.canvasElementId) {
      if (this._logger.debug("Using Canvas element specified: " + t.canvasElementId), document.getElementById(t.canvasElementId) === null)
        throw new Error("Cannot find existing element in the DOM, please ensure element is created prior to engine creation.");
      this.canvas = document.getElementById(t.canvasElementId), this._hasCreatedCanvas = !1;
    } else t.canvasElement ? (this._logger.debug("Using Canvas element specified:", t.canvasElement), this.canvas = t.canvasElement, this._hasCreatedCanvas = !1) : (this._logger.debug("Using generated canvas element"), this.canvas = document.createElement("canvas"), this._hasCreatedCanvas = !0);
    this.canvas && !t.enableCanvasContextMenu && this.canvas.addEventListener("contextmenu", (S) => {
      S.preventDefault();
    });
    let u = (e = t.displayMode) != null ? e : _i.Fixed;
    t.width && t.height || t.viewport ? (t.displayMode === void 0 && (u = _i.Fixed), this._logger.debug("Engine viewport is size " + t.width + " x " + t.height)) : t.displayMode || (this._logger.debug("Engine viewport is fit"), u = _i.FitScreen);
    const _ = t.global && typeof t.global == "function" ? t.global() : t.global;
    this.global = _ != null ? _ : Yr(), this.grabWindowFocus = t.grabWindowFocus, this.pointerScope = t.pointerScope, this._originalDisplayMode = u;
    let p, g, x, m, f, b;
    typeof t.antialiasing == "object" ? { pixelArtSampler: p, nativeContextAntialiasing: x, multiSampleAntialiasing: b, filtering: f, canvasImageRendering: m } = {
      ...t.pixelArt ? No : Oo,
      ...t.antialiasing
    } : (p = !!t.pixelArt, x = !1, b = t.antialiasing, m = t.antialiasing ? "auto" : "pixelated", f = t.antialiasing ? wt.Blended : wt.Pixel), x && b && this._logger.warnOnce(
      "Cannot use antialias setting nativeContextAntialiasing and multiSampleAntialiasing at the same time, they are incompatible settings. If you aren't sure use multiSampleAntialiasing"
    ), t.pixelArt && (g = 0.25), (!t.antialiasing || f === wt.Pixel) && (g = 0), g = (s = (i = t.uvPadding) != null ? i : g) != null ? s : 0.01;
    let C = We.isEnabled("use-canvas-context");
    if (!C)
      try {
        this.graphicsContext = new Qt({
          canvasElement: this.canvas,
          enableTransparency: this.enableCanvasTransparency,
          pixelArtSampler: p,
          antialiasing: x,
          multiSampleAntialiasing: b,
          uvPadding: g,
          powerPreference: t.powerPreference,
          backgroundColor: t.backgroundColor,
          snapToPixel: t.snapToPixel,
          useDrawSorting: t.useDrawSorting,
          garbageCollector: this.garbageCollectorConfig ? {
            garbageCollector: this._garbageCollector,
            collectionInterval: this.garbageCollectorConfig.textureCollectInterval
          } : null,
          handleContextLost: (n = t.handleContextLost) != null ? n : this._handleWebGLContextLost,
          handleContextRestored: t.handleContextRestored
        });
      } catch (S) {
        this._logger.warn(
          `Excalibur could not load webgl for some reason (${S.message}) and loaded a Canvas 2D fallback. Some features of Excalibur will not work in this mode. 

Read more about this issue at https://excaliburjs.com/docs/performance`
        ), C = !0;
      }
    C && (this.graphicsContext = new ns({
      canvasElement: this.canvas,
      enableTransparency: this.enableCanvasTransparency,
      antialiasing: x,
      backgroundColor: t.backgroundColor,
      snapToPixel: t.snapToPixel,
      useDrawSorting: t.useDrawSorting
    })), this.screen = new js({
      canvas: this.canvas,
      context: this.graphicsContext,
      antialiasing: x,
      canvasImageRendering: m,
      browser: this.browser,
      viewport: (o = t.viewport) != null ? o : t.width && t.height ? { width: t.width, height: t.height } : Zs.SVGA,
      resolution: t.resolution,
      displayMode: u,
      pixelRatio: t.suppressHiDPIScaling ? 1 : (a = t.pixelRatio) != null ? a : null
    }), Ge.filtering = f, t.backgroundColor && (this.backgroundColor = t.backgroundColor.clone()), this.maxFps = (h = t.maxFps) != null ? h : this.maxFps, this.fixedUpdateTimestep = (l = t.fixedUpdateTimestep) != null ? l : this.fixedUpdateTimestep, this.fixedUpdateFps = (c = t.fixedUpdateFps) != null ? c : this.fixedUpdateFps, this.fixedUpdateTimestep = this.fixedUpdateTimestep || 1e3 / this.fixedUpdateFps, this.clock = new Qr({
      maxFps: this.maxFps,
      tick: this._mainloop.bind(this),
      onFatalException: (S) => this.onFatalException(S)
    }), this.enableCanvasTransparency = t.enableCanvasTransparency, typeof t.physics == "boolean" ? this.physics = {
      ...ne(),
      enabled: t.physics
    } : (this.physics = {
      ...ne()
    }, vi(this.physics, t.physics)), this.director = new Hh(this, t.scenes), this.director.events.pipe(this.events), this._initialize(t), window.___EXCALIBUR_DEVTOOL = this, ie.InstanceCount++;
  }
  static useEngine() {
    const t = Kr(ie.Context);
    if (!t)
      throw new Error("Cannot inject engine with `useEngine()`, `useEngine()` was called outside of Engine lifecycle scope.");
    return t;
  }
  /**
   * The width of the game canvas in pixels (physical width component of the
   * resolution of the canvas element)
   */
  get canvasWidth() {
    return this.screen.canvasWidth;
  }
  /**
   * Returns half width of the game canvas in pixels (half physical width component)
   */
  get halfCanvasWidth() {
    return this.screen.halfCanvasWidth;
  }
  /**
   * The height of the game canvas in pixels, (physical height component of
   * the resolution of the canvas element)
   */
  get canvasHeight() {
    return this.screen.canvasHeight;
  }
  /**
   * Returns half height of the game canvas in pixels (half physical height component)
   */
  get halfCanvasHeight() {
    return this.screen.halfCanvasHeight;
  }
  /**
   * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
   */
  get drawWidth() {
    return this.screen.drawWidth;
  }
  /**
   * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
   */
  get halfDrawWidth() {
    return this.screen.halfDrawWidth;
  }
  /**
   * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
   */
  get drawHeight() {
    return this.screen.drawHeight;
  }
  /**
   * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
   */
  get halfDrawHeight() {
    return this.screen.halfDrawHeight;
  }
  /**
   * Returns whether excalibur detects the current screen to be HiDPI
   */
  get isHiDpi() {
    return this.screen.isHiDpi;
  }
  /**
   * Access {@apilink stats} that holds frame statistics.
   */
  get stats() {
    return this.debug.stats;
  }
  /**
   * The current {@apilink Scene} being drawn and updated on screen
   */
  get currentScene() {
    return this.director.currentScene;
  }
  /**
   * The current {@apilink Scene} being drawn and updated on screen
   */
  get currentSceneName() {
    return this.director.currentSceneName;
  }
  /**
   * The default {@apilink Scene} of the game, use {@apilink Engine.goToScene} to transition to different scenes.
   */
  get rootScene() {
    return this.director.rootScene;
  }
  /**
   * Contains all the scenes currently registered with Excalibur
   */
  get scenes() {
    return this.director.scenes;
  }
  /**
   * Indicates whether the engine is set to fullscreen or not
   */
  get isFullscreen() {
    return this.screen.isFullScreen;
  }
  /**
   * Indicates the current {@apilink DisplayMode} of the engine.
   */
  get displayMode() {
    return this.screen.displayMode;
  }
  /**
   * Returns the calculated pixel ration for use in rendering
   */
  get pixelRatio() {
    return this.screen.pixelRatio;
  }
  get isDebug() {
    return this._isDebug;
  }
  /**
   * Hints the graphics context to truncate fractional world space coordinates
   */
  get snapToPixel() {
    return this.graphicsContext.snapToPixel;
  }
  set snapToPixel(t) {
    this.graphicsContext.snapToPixel = t;
  }
  emit(t, e) {
    this.events.emit(t, e);
  }
  on(t, e) {
    return this.events.on(t, e);
  }
  once(t, e) {
    return this.events.once(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
  _monitorPerformanceThresholdAndTriggerFallback() {
    const { allow: t } = this._originalOptions.configurePerformanceCanvas2DFallback;
    let { threshold: e, showPlayerMessage: i } = this._originalOptions.configurePerformanceCanvas2DFallback;
    if (e === void 0 && (e = ie._DEFAULT_ENGINE_OPTIONS.configurePerformanceCanvas2DFallback.threshold), i === void 0 && (i = ie._DEFAULT_ENGINE_OPTIONS.configurePerformanceCanvas2DFallback.showPlayerMessage), !We.isEnabled("use-canvas-context") && t && this.ready && !this._performanceThresholdTriggered) {
      this._fpsSamples.length === e.numberOfFrames && this._fpsSamples.splice(0, 1), this._fpsSamples.push(this.clock.fpsSampler.fps);
      let s = 0;
      for (let o = 0; o < this._fpsSamples.length; o++)
        s += this._fpsSamples[o];
      const n = s / this._fpsSamples.length;
      this._fpsSamples.length === e.numberOfFrames && n <= e.fps && (this._performanceThresholdTriggered = !0, this._logger.warn(
        `Switching to browser 2D Canvas fallback due to performance. Some features of Excalibur will not work in this mode.
this might mean your browser doesn't have webgl enabled or hardware acceleration is unavailable.

If in Chrome:
  * Visit Settings > Advanced > System, and ensure "Use Hardware Acceleration" is checked.
  * Visit chrome://flags/#ignore-gpu-blocklist and ensure "Override software rendering list" is "enabled"
If in Firefox, visit about:config
  * Ensure webgl.disabled = false
  * Ensure webgl.force-enabled = true
  * Ensure layers.acceleration.force-enabled = true

Read more about this issue at https://excaliburjs.com/docs/performance`
      ), i && this._toaster.toast(
        "Excalibur is encountering performance issues. It's possible that your browser doesn't have hardware acceleration enabled. Visit [LINK] for more information and potential solutions.",
        "https://excaliburjs.com/docs/performance"
      ), this.useCanvas2DFallback(), this.emit("fallbackgraphicscontext", this.graphicsContext));
    }
  }
  /**
   * Switches the engine's graphics context to the 2D Canvas.
   * @warning Some features of Excalibur will not work in this mode.
   */
  useCanvas2DFallback() {
    var t, e, i;
    const s = this.canvas.cloneNode(!1);
    this.canvas.parentNode.replaceChild(s, this.canvas), this.canvas = s;
    const n = { ...this._originalOptions, antialiasing: this.screen.antialiasing }, o = this._originalDisplayMode;
    this.graphicsContext = new ns({
      canvasElement: this.canvas,
      enableTransparency: this.enableCanvasTransparency,
      antialiasing: n.antialiasing,
      backgroundColor: n.backgroundColor,
      snapToPixel: n.snapToPixel,
      useDrawSorting: n.useDrawSorting
    }), this.screen && this.screen.dispose(), this.screen = new js({
      canvas: this.canvas,
      context: this.graphicsContext,
      antialiasing: (t = n.antialiasing) != null ? t : !0,
      browser: this.browser,
      viewport: (e = n.viewport) != null ? e : n.width && n.height ? { width: n.width, height: n.height } : Zs.SVGA,
      resolution: n.resolution,
      displayMode: o,
      pixelRatio: n.suppressHiDPIScaling ? 1 : (i = n.pixelRatio) != null ? i : null
    }), this.screen.setCurrentCamera(this.currentScene.camera), this.input.pointers.detach();
    const a = n && n.pointerScope === $e.Document ? document : this.canvas;
    this.input.pointers = this.input.pointers.recreate(a, this), this.input.pointers.init();
  }
  /**
   * Attempts to completely clean up excalibur resources, including removing the canvas from the dom.
   *
   * To start again you will need to new up an Engine.
   */
  dispose() {
    this._disposed || (this._disposed = !0, this.stop(), this._garbageCollector.forceCollectAll(), this.input.toggleEnabled(!1), this._hasCreatedCanvas && this.canvas.parentNode.removeChild(this.canvas), this.canvas = null, this.screen.dispose(), this.graphicsContext.dispose(), this.graphicsContext = null, ie.InstanceCount--);
  }
  isDisposed() {
    return this._disposed;
  }
  /**
   * Returns a BoundingBox of the top left corner of the screen
   * and the bottom right corner of the screen.
   */
  getWorldBounds() {
    return this.screen.getWorldBounds();
  }
  /**
   * Gets the current engine timescale factor (default is 1.0 which is 1:1 time)
   */
  get timescale() {
    return this._timescale;
  }
  /**
   * Sets the current engine timescale factor. Useful for creating slow-motion effects or fast-forward effects
   * when using time-based movement.
   */
  set timescale(t) {
    if (t < 0) {
      R.getInstance().warnOnce("engine.timescale to a value less than 0 are ignored");
      return;
    }
    this._timescale = t;
  }
  /**
   * Adds a {@apilink Timer} to the {@apilink currentScene}.
   * @param timer  The timer to add to the {@apilink currentScene}.
   */
  addTimer(t) {
    return this.currentScene.addTimer(t);
  }
  /**
   * Removes a {@apilink Timer} from the {@apilink currentScene}.
   * @param timer  The timer to remove to the {@apilink currentScene}.
   */
  removeTimer(t) {
    return this.currentScene.removeTimer(t);
  }
  /**
   * Adds a {@apilink Scene} to the engine, think of scenes in Excalibur as you
   * would levels or menus.
   * @param key  The name of the scene, must be unique
   * @param scene The scene to add to the engine
   */
  addScene(t, e) {
    return this.director.add(t, e), this;
  }
  /**
   * @internal
   */
  removeScene(t) {
    this.director.remove(t);
  }
  add(t) {
    if (arguments.length === 2) {
      this.director.add(arguments[0], arguments[1]);
      return;
    }
    const e = this.director.getDeferredScene();
    e instanceof Et ? e.add(t) : this.currentScene.add(t);
  }
  remove(t) {
    t instanceof Rt && this.currentScene.remove(t), (t instanceof Et || Xt(t)) && this.removeScene(t), typeof t == "string" && this.removeScene(t);
  }
  /**
   * Changes the current scene with optionally supplied:
   * * Activation data
   * * Transitions
   * * Loaders
   *
   * Example:
   * ```typescript
   * game.goToScene('myScene', {
   *   sceneActivationData: {any: 'thing at all'},
   *   destinationIn: new FadeInOut({duration: 1000, direction: 'in'}),
   *   sourceOut: new FadeInOut({duration: 1000, direction: 'out'}),
   *   loader: MyLoader
   * });
   * ```
   *
   * Scenes are defined in the Engine constructor
   * ```typescript
   * const engine = new ex.Engine({
      scenes: {...}
    });
   * ```
   * Or by adding dynamically
   *
   * ```typescript
   * engine.addScene('myScene', new ex.Scene());
   * ```
   * @param destinationScene
   * @param options
   */
  async goToScene(t, e) {
    await this.scope(async () => {
      await this.director.goToScene(t, e);
    });
  }
  /**
   * Transforms the current x, y from screen coordinates to world coordinates
   * @param point  Screen coordinate to convert
   */
  screenToWorldCoordinates(t) {
    return this.screen.screenToWorldCoordinates(t);
  }
  /**
   * Transforms a world coordinate, to a screen coordinate
   * @param point  World coordinate to convert
   */
  worldToScreenCoordinates(t) {
    return this.screen.worldToScreenCoordinates(t);
  }
  /**
   * Initializes the internal canvas, rendering context, display mode, and native event listeners
   */
  _initialize(t) {
    var e, i;
    this.pageScrollPreventionMode = t.scrollPreventionMode;
    const s = t && t.pointerScope === $e.Document ? document : this.canvas, n = (i = (e = this._originalOptions) == null ? void 0 : e.grabWindowFocus) != null ? i : !0;
    this.input = new Zr({
      global: this.global,
      pointerTarget: s,
      grabWindowFocus: n,
      engine: this
    }), this.inputMapper = this.input.inputMapper, this.browser.document.on("visibilitychange", () => {
      document.visibilityState === "hidden" ? (this.events.emit("hidden", new Bn(this)), this._logger.debug("Window hidden")) : document.visibilityState === "visible" && (this.events.emit("visible", new Dn(this)), this._logger.debug("Window visible"));
    }), !this.canvasElementId && !t.canvasElement && document.body.appendChild(this.canvas);
  }
  toggleInputEnabled(t) {
    this._inputEnabled = t, this.input.toggleEnabled(this._inputEnabled);
  }
  onInitialize(t) {
  }
  /**
   * Gets whether the actor is Initialized
   */
  get isInitialized() {
    return this._isInitialized;
  }
  async _overrideInitialize(t) {
    this.isInitialized || (await this.director.onInitialize(), await this.onInitialize(t), this.events.emit("initialize", new Ke(t, this)), this._isInitialized = !0);
  }
  /**
   * Updates the entire state of the game
   * @param elapsed  Number of milliseconds elapsed since the last update.
   */
  _update(t) {
    var e;
    if (this._isLoading) {
      (e = this._loader) == null || e.onUpdate(this, t), this.input.update();
      return;
    }
    this.clock.__runScheduledCbs("preupdate"), this._preupdate(t), this.currentScene.update(this, t), this.graphicsContext.updatePostProcessors(t), this.clock.__runScheduledCbs("postupdate"), this._postupdate(t), this.input.update();
  }
  /**
   * @internal
   */
  _preupdate(t) {
    this.emit("preupdate", new pe(this, t, this)), this.onPreUpdate(this, t);
  }
  /**
   * Safe to override method
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   */
  onPreUpdate(t, e) {
  }
  /**
   * @internal
   */
  _postupdate(t) {
    this.emit("postupdate", new me(this, t, this)), this.onPostUpdate(this, t);
  }
  /**
   * Safe to override method
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   */
  onPostUpdate(t, e) {
  }
  /**
   * Draws the entire game
   * @param elapsed  Number of milliseconds elapsed since the last draw.
   */
  _draw(t) {
    var e, i;
    if (this.graphicsContext.backgroundColor = (e = this.currentScene.backgroundColor) != null ? e : this.backgroundColor, this.graphicsContext.beginDrawLifecycle(), this.graphicsContext.clear(), this.clock.__runScheduledCbs("predraw"), this._predraw(this.graphicsContext, t), this._isLoading) {
      this._hideLoader || ((i = this._loader) == null || i.canvas.draw(this.graphicsContext, 0, 0), this.clock.__runScheduledCbs("postdraw"), this.graphicsContext.flush(), this.graphicsContext.endDrawLifecycle());
      return;
    }
    this.currentScene.draw(this.graphicsContext, t), this.clock.__runScheduledCbs("postdraw"), this._postdraw(this.graphicsContext, t), this.graphicsContext.flush(), this.graphicsContext.endDrawLifecycle(), this._checkForScreenShots();
  }
  /**
   * @internal
   */
  _predraw(t, e) {
    this.emit("predraw", new Qe(t, e, this)), this.onPreDraw(t, e);
  }
  /**
   * Safe to override method to hook into pre draw
   * @param ctx {@link ExcaliburGraphicsContext} for drawing
   * @param elapsed  Number of milliseconds elapsed since the last draw.
   */
  onPreDraw(t, e) {
  }
  /**
   * @internal
   */
  _postdraw(t, e) {
    this.emit("postdraw", new Je(t, e, this)), this.onPostDraw(t, e);
  }
  /**
   * Safe to override method to hook into pre draw
   * @param ctx {@link ExcaliburGraphicsContext} for drawing
   * @param elapsed  Number of milliseconds elapsed since the last draw.
   */
  onPostDraw(t, e) {
  }
  /**
   * Enable or disable Excalibur debugging functionality.
   * @param toggle a value that debug drawing will be changed to
   */
  showDebug(t) {
    this._isDebug = t;
  }
  /**
   * Toggle Excalibur debugging functionality.
   */
  toggleDebug() {
    return this._isDebug = !this._isDebug, this._isDebug;
  }
  /**
   * Returns true when loading is totally complete and the player has clicked start
   */
  get loadingComplete() {
    return !this._isLoading;
  }
  get ready() {
    return this._isReadyFuture.isCompleted;
  }
  isReady() {
    return this._isReadyFuture.promise;
  }
  async start(t, e) {
    await this.scope(async () => {
      if (!this._compatible)
        throw new Error("Excalibur is incompatible with your browser");
      this._isLoading = !0;
      let i;
      return t instanceof yi ? i = t : typeof t == "string" && (this.director.configureStart(t, e), i = this.director.mainLoader), this._logger.debug("Starting game clock..."), this.browser.resume(), this.clock.start(), this.garbageCollectorConfig && this._garbageCollector.start(), this._logger.debug("Game clock started"), await this.load(i != null ? i : new as()), await this._overrideInitialize(this), this._isReadyFuture.resolve(), this.emit("start", new bn(this)), this._isReadyFuture.promise;
    });
  }
  _mainloop(t) {
    this.scope(() => {
      this.emit("preframe", new Pn(this, this.stats.prevFrame));
      const e = t * this.timescale;
      this.currentFrameElapsedMs = e;
      const i = this.stats.prevFrame.id + 1;
      this.stats.currFrame.reset(), this.stats.currFrame.id = i, this.stats.currFrame.elapsedMs = e, this.stats.currFrame.fps = this.clock.fpsSampler.fps, Z.clear();
      const s = this.clock.now(), n = this.fixedUpdateTimestep;
      if (this.fixedUpdateTimestep)
        for (this._lagMs += e; this._lagMs >= n; )
          this._update(n), this._lagMs -= n;
      else
        this._update(e);
      const o = this.clock.now();
      this.currentFrameLagMs = this._lagMs, this._draw(e);
      const a = this.clock.now();
      this.stats.currFrame.duration.update = o - s, this.stats.currFrame.duration.draw = a - o, this.stats.currFrame.graphics.drawnImages = Z.DrawnImagesCount, this.stats.currFrame.graphics.drawCalls = Z.DrawCallCount, this.stats.currFrame.graphics.rendererSwaps = Z.RendererSwaps, this.emit("postframe", new En(this, this.stats.currFrame)), this.stats.prevFrame.reset(this.stats.currFrame), this._monitorPerformanceThresholdAndTriggerFallback();
    });
  }
  /**
   * Stops Excalibur's main loop, useful for pausing the game.
   */
  stop() {
    this.clock.isRunning() && (this.emit("stop", new yn(this)), this.browser.pause(), this.clock.stop(), this._garbageCollector.stop(), this._logger.debug("Game stopped"));
  }
  /**
   * Returns the Engine's running status, Useful for checking whether engine is running or paused.
   */
  isRunning() {
    return this.clock.isRunning();
  }
  /**
   * Takes a screen shot of the current viewport and returns it as an
   * HTML Image Element.
   * @param preserveHiDPIResolution in the case of HiDPI return the full scaled backing image, by default false
   */
  screenshot(t = !1) {
    return new Promise((i) => {
      this._screenShotRequests.push({ preserveHiDPIResolution: t, resolve: i });
    });
  }
  _checkForScreenShots() {
    for (const t of this._screenShotRequests) {
      const e = t.preserveHiDPIResolution ? this.canvas.width : this.screen.resolution.width, i = t.preserveHiDPIResolution ? this.canvas.height : this.screen.resolution.height, s = document.createElement("canvas");
      s.width = e, s.height = i;
      const n = s.getContext("2d");
      n.imageSmoothingEnabled = this.screen.antialiasing, n.drawImage(this.canvas, 0, 0, e, i);
      const o = new Image(), a = s.toDataURL("image/png");
      o.onload = () => {
        t.resolve(o);
      }, o.src = a;
    }
    this._screenShotRequests.length = 0;
  }
  /**
   * Another option available to you to load resources into the game.
   * Immediately after calling this the game will pause and the loading screen
   * will appear.
   * @param loader  Some {@apilink Loadable} such as a {@apilink Loader} collection, {@apilink Sound}, or {@apilink Texture}.
   */
  async load(t, e = !1) {
    await this.scope(async () => {
      try {
        if (t.isLoaded())
          return;
        this._loader = t, this._isLoading = !0, this._hideLoader = e, t instanceof as && (t.suppressPlayButton = t.suppressPlayButton || this._suppressPlayButton), this._loader.onInitialize(this), await t.load();
      } catch (i) {
        this._logger.error("Error loading resources, things may not behave properly", i), await Promise.resolve();
      } finally {
        this._isLoading = !1, this._hideLoader = !1, this._loader = null;
      }
    });
  }
};
Li.Context = Jr();
Li.InstanceCount = 0;
Li._DEFAULT_ENGINE_OPTIONS = {
  width: 0,
  height: 0,
  enableCanvasTransparency: !0,
  useDrawSorting: !0,
  configurePerformanceCanvas2DFallback: {
    allow: !1,
    showPlayerMessage: !1,
    threshold: { fps: 20, numberOfFrames: 100 }
  },
  canvasElementId: "",
  canvasElement: void 0,
  enableCanvasContextMenu: !1,
  snapToPixel: !1,
  antialiasing: !0,
  pixelArt: !1,
  garbageCollection: !0,
  powerPreference: "high-performance",
  pointerScope: $e.Canvas,
  suppressConsoleBootMessage: null,
  suppressMinimumBrowserFeatureDetection: null,
  suppressHiDPIScaling: null,
  suppressPlayButton: null,
  grabWindowFocus: !0,
  scrollPreventionMode: 1,
  backgroundColor: T.fromHex("#2185d0")
  // Excalibur blue
};
let Gi = Li;
class ic extends Dt {
  /**
   * Build a new label
   * @param options
   */
  constructor(t) {
    super(t), this._font = new Me(), this._text = new Bi({ text: "", font: this._font });
    const { text: e, pos: i, x: s, y: n, spriteFont: o, font: a, color: h, maxWidth: l } = { text: "", ...t };
    this.pos = i != null ? i : s && n ? w(s, n) : this.pos, this.text = e != null ? e : this.text, this.font = a != null ? a : this.font, this.maxWidth = l != null ? l : this.maxWidth, this.spriteFont = o != null ? o : this.spriteFont, this._text.color = h != null ? h : this.color;
    const c = this.get(tt);
    c.anchor = v.Zero, c.use(this._text);
  }
  set maxWidth(t) {
    this._text.maxWidth = t;
  }
  get maxWidth() {
    return this._text.maxWidth;
  }
  get font() {
    return this._font;
  }
  set font(t) {
    this._font = t, this._text.font = t;
  }
  /**
   * The text to draw.
   */
  get text() {
    return this._text.text;
  }
  set text(t) {
    this._text.text = t;
  }
  get color() {
    return this._text.color;
  }
  set color(t) {
    this._text && (this._text.color = t);
  }
  get opacity() {
    return this.graphics.opacity;
  }
  set opacity(t) {
    this.graphics.opacity = t;
  }
  /**
   * The {@apilink SpriteFont} to use, if any. Overrides {@apilink Font | `font`} if present.
   */
  get spriteFont() {
    return this._spriteFont;
  }
  set spriteFont(t) {
    t && (this._spriteFont = t, this._text.font = this._spriteFont);
  }
  _initialize(t) {
    super._initialize(t);
  }
  /**
   * Returns the width of the text in the label (in pixels);
   */
  getTextWidth() {
    return this._text.width;
  }
}
var Ae = /* @__PURE__ */ ((r) => (r.Circle = "circle", r.Rectangle = "rectangle", r))(Ae || {});
class sc extends Dt {
  /**
   * @param config particle emitter options bag
   */
  constructor(t) {
    var e, i;
    super({ width: (e = t.width) != null ? e : 0, height: (i = t.height) != null ? i : 0 }), this._particlesToEmit = 0, this._particlePool = new ii(
      () => new ws({}),
      (p) => p,
      500
    ), this.numParticles = 0, this.isEmitting = !0, this.deadParticles = [], this.emitRate = 1, this.emitterType = Ae.Rectangle, this.radius = 0, this.particle = {
      /**
       * Gets or sets the life of each particle in milliseconds
       */
      life: 2e3,
      transform: jt.Global,
      graphic: void 0,
      opacity: 1,
      angularVelocity: 0,
      focus: void 0,
      focusAccel: void 0,
      randomRotation: !1
    }, this._activeParticles = [];
    const { particle: s, x: n, y: o, z: a, pos: h, isEmitting: l, emitRate: c, emitterType: d, radius: u, random: _ } = { ...t };
    this.particle = { ...this.particle, ...s }, this.pos = h != null ? h : w(n != null ? n : 0, o != null ? o : 0), this.z = a != null ? a : 0, this.isEmitting = l != null ? l : this.isEmitting, this.emitRate = c != null ? c : this.emitRate, this.emitterType = d != null ? d : this.emitterType, this.radius = u != null ? u : this.radius, this.body.collisionType = E.PreventCollision, this.random = _ != null ? _ : new ge();
  }
  removeParticle(t) {
    this.deadParticles.push(t);
  }
  /**
   * Causes the emitter to emit particles
   * @param particleCount  Number of particles to emit right now
   */
  emitParticles(t) {
    var e;
    if (!(t <= 0)) {
      t = t | 0;
      for (let i = 0; i < t; i++) {
        const s = this._createParticle();
        (e = this == null ? void 0 : this.scene) != null && e.world && (this.particle.transform === jt.Global ? this.scene.world.add(s) : this.addChild(s)), this._activeParticles.push(s);
      }
    }
  }
  clearParticles() {
    for (let t = 0; t < this._activeParticles.length; t++)
      this.removeParticle(this._activeParticles[t]);
  }
  // Creates a new particle given the constraints of the emitter
  _createParticle() {
    let t = 0, e = 0;
    const i = $t(this.particle.minAngle || 0, this.particle.maxAngle || Math.PI * 2, this.random), s = $t(this.particle.minSpeed || 0, this.particle.maxSpeed || 0, this.random), n = this.particle.startSize || $t(this.particle.minSize || 5, this.particle.maxSize || 5, this.random), o = s * Math.cos(i), a = s * Math.sin(i);
    if (this.emitterType === Ae.Rectangle)
      t = $t(0, this.width, this.random), e = $t(0, this.height, this.random);
    else if (this.emitterType === Ae.Circle) {
      const l = $t(0, this.radius, this.random);
      t = l * Math.cos(i), e = l * Math.sin(i);
    }
    const h = this._particlePool.rent();
    return h.unparent(), h.configure({
      transform: this.particle.transform,
      life: this.particle.life,
      opacity: this.particle.opacity,
      beginColor: this.particle.beginColor,
      endColor: this.particle.endColor,
      pos: w(t, e),
      z: this.particle.transform === jt.Global ? this.z : void 0,
      vel: w(o, a),
      acc: this.particle.acc,
      angularVelocity: this.particle.angularVelocity,
      startSize: this.particle.startSize,
      endSize: this.particle.endSize,
      size: n,
      graphic: this.particle.graphic,
      fade: this.particle.fade
    }), h.registerEmitter(this), this.particle.randomRotation && (h.transform.rotation = $t(0, Math.PI * 2, this.random)), this.particle.focus && (h.focus = this.particle.focus.add(w(this.pos.x, this.pos.y)), h.focusAccel = this.particle.focusAccel), h;
  }
  update(t, e) {
    var i;
    super.update(t, e), this.isEmitting && (this._particlesToEmit += this.emitRate * (e / 1e3), this._particlesToEmit > 1 && (this.emitParticles(Math.floor(this._particlesToEmit)), this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit)));
    for (let s = 0; s < this.deadParticles.length; s++) {
      (i = this == null ? void 0 : this.scene) != null && i.world && (this.scene.world.remove(this.deadParticles[s], !1), this._particlePool.return(this.deadParticles[s]));
      const n = this._activeParticles.indexOf(this.deadParticles[s]);
      n > -1 && this._activeParticles.splice(n, 1);
    }
    this.deadParticles.length = 0;
  }
}
function nn(r, t) {
  if (!t())
    throw new Error(r);
}
class hs {
  constructor(t, e, i) {
    this.emitRate = 1, this._initialized = !1, this._vaos = [], this._buffers = [], this._drawIndex = 0, this._numInputFloats = 7, this._particleIndex = 0, this._uploadIndex = 0, this._wrappedLife = 0, this._wrappedParticles = 0, this._particleLife = 0, this._clearRequested = !1, this._emitted = [];
    var s;
    this.emitter = t, this.particle = i, this._particleData = new Float32Array(this.emitter.maxParticles * this._numInputFloats), this._random = e, this._particleLife = (s = this.particle.life) != null ? s : 2e3;
  }
  get isInitialized() {
    return this._initialized;
  }
  get maxParticles() {
    return this.emitter.maxParticles;
  }
  initialize(t, e) {
    if (this._initialized)
      return;
    const i = this.emitter.maxParticles, s = this._numInputFloats, n = this._particleData, o = 4, a = t.createBuffer(), h = t.createVertexArray();
    t.bindVertexArray(h), t.bindBuffer(t.ARRAY_BUFFER, a), t.bufferData(t.ARRAY_BUFFER, i * s * o, t.DYNAMIC_DRAW), t.bufferSubData(t.ARRAY_BUFFER, 0, n);
    let l = 0;
    t.vertexAttribPointer(0, 2, t.FLOAT, !1, s * o, 0), l += o * 2, t.vertexAttribPointer(1, 2, t.FLOAT, !1, s * o, l), l += o * 2, t.vertexAttribPointer(2, 1, t.FLOAT, !1, s * o, l), l += o * 1, t.vertexAttribPointer(3, 1, t.FLOAT, !1, s * o, l), l += o * 1, t.vertexAttribPointer(4, 1, t.FLOAT, !1, s * o, l), l += o * 1, t.enableVertexAttribArray(0), t.enableVertexAttribArray(1), t.enableVertexAttribArray(2), t.enableVertexAttribArray(3), t.enableVertexAttribArray(4), this._vaos.push(h), this._buffers.push(a), t.bindVertexArray(null), t.bindBuffer(t.ARRAY_BUFFER, null);
    const c = t.createBuffer(), d = t.createVertexArray();
    t.bindVertexArray(d), t.bindBuffer(t.ARRAY_BUFFER, c), t.bufferData(t.ARRAY_BUFFER, i * s * o, t.DYNAMIC_DRAW), l = 0, t.vertexAttribPointer(0, 2, t.FLOAT, !1, s * o, 0), l += o * 2, t.vertexAttribPointer(1, 2, t.FLOAT, !1, s * o, l), l += o * 2, t.vertexAttribPointer(2, 1, t.FLOAT, !1, s * o, l), l += o * 1, t.vertexAttribPointer(3, 1, t.FLOAT, !1, s * o, l), l += o * 1, t.vertexAttribPointer(4, 1, t.FLOAT, !1, s * o, l), l += o * 1, t.enableVertexAttribArray(0), t.enableVertexAttribArray(1), t.enableVertexAttribArray(2), t.enableVertexAttribArray(3), t.enableVertexAttribArray(4), this._vaos.push(d), this._buffers.push(c), t.bindVertexArray(null), t.bindBuffer(t.ARRAY_BUFFER, null), this._currentVao = this._vaos[this._drawIndex % 2], this._currentBuffer = this._buffers[(this._drawIndex + 1) % 2], this._initialized = !0;
  }
  clearParticles() {
    this._particleData.fill(0), this._clearRequested = !0;
  }
  emitParticles(t) {
    const e = this._particleIndex, i = this.maxParticles * this._numInputFloats, s = t * this._numInputFloats + e;
    for (let n = e; n < s; n += this._numInputFloats) {
      let o = this._random.floating(this.particle.minAngle || 0, this.particle.maxAngle || vt);
      o += this.particle.transform === jt.Local ? this.emitter.transform.rotation : this.emitter.transform.globalRotation;
      const a = this._random.floating(this.particle.minSpeed || 0, this.particle.maxSpeed || 0), h = this._random.floating(this.particle.minSpeed || 0, this.particle.maxSpeed || 0), l = a * Math.cos(o), c = h * Math.sin(o);
      let d = 0, u = 0;
      if (this.emitter.emitterType === Ae.Rectangle)
        d = this._random.floating(-0.5, 0.5) * this.emitter.width, u = this._random.floating(-0.5, 0.5) * this.emitter.height;
      else {
        const g = this._random.floating(0, this.emitter.radius);
        d = g * Math.cos(o), u = g * Math.sin(o);
      }
      const _ = this.emitter.transform.apply(w(d, u)), p = [
        this.particle.transform === jt.Local ? d : _.x,
        this.particle.transform === jt.Local ? u : _.y,
        // pos in world space
        l,
        c,
        // velocity
        this.particle.randomRotation ? $t(0, vt, this._random) : this.particle.rotation || 0,
        // rotation
        this.particle.angularVelocity || 0,
        // angular velocity
        this._particleLife
        // life
      ];
      this._particleData.set(p, n % this._particleData.length);
    }
    s >= i ? (this._wrappedParticles += (s - i) / this._numInputFloats, this._wrappedLife = this._particleLife) : this._wrappedLife > 0 && (this._wrappedParticles += t), this._particleIndex = s % i, this._emitted.push([this._particleLife, e]);
  }
  _uploadEmitted(t) {
    this._particleIndex !== this._uploadIndex && (t.bindBuffer(t.ARRAY_BUFFER, this._buffers[(this._drawIndex + 1) % 2]), this._particleIndex >= this._uploadIndex ? t.bufferSubData(
      t.ARRAY_BUFFER,
      this._uploadIndex * 4,
      // dst byte offset 4 bytes per float
      this._particleData,
      this._uploadIndex,
      this._particleIndex - this._uploadIndex
    ) : (t.bufferSubData(
      t.ARRAY_BUFFER,
      this._uploadIndex * 4,
      this._particleData,
      this._uploadIndex,
      this._particleData.length - this._uploadIndex
    ), this._wrappedParticles && t.bufferSubData(
      t.ARRAY_BUFFER,
      0,
      this._particleData,
      0,
      this._wrappedParticles * this._numInputFloats
    ), this._wrappedLife = this._particleLife), t.bindBuffer(t.ARRAY_BUFFER, null)), this._uploadIndex = this._particleIndex % (this.maxParticles * this._numInputFloats);
  }
  update(t) {
    var e;
    if (this._particleLife = (e = this.particle.life) != null ? e : this._particleLife, this._wrappedLife > 0 ? this._wrappedLife -= t : (this._wrappedLife = 0, this._wrappedParticles = 0), !!this._emitted.length) {
      for (let i = this._emitted.length - 1; i >= 0; i--) {
        const s = this._emitted[i];
        s[0] -= t, s[0] <= 0 && this._emitted.splice(i, 1);
      }
      this._emitted.sort((i, s) => i[0] - s[0]);
    }
  }
  draw(t) {
    if (this._initialized) {
      if (this._clearRequested ? (t.bindBuffer(t.ARRAY_BUFFER, this._buffers[(this._drawIndex + 1) % 2]), t.bufferSubData(t.ARRAY_BUFFER, 0, this._particleData), t.bindBuffer(t.ARRAY_BUFFER, null), this._clearRequested = !1) : this._uploadEmitted(t), t.bindVertexArray(this._currentVao), t.bindBufferBase(t.TRANSFORM_FEEDBACK_BUFFER, 0, this._currentBuffer), this._wrappedLife && this._emitted[0] && this._emitted[0][1] > 0) {
        const e = this._emitted[0][1] / this._numInputFloats;
        nn(`midpoint greater than 0, actual: ${e}`, () => e > 0), nn(`midpoint is less than max, actual: ${e}`, () => e < this.maxParticles), t.bindBufferRange(
          t.TRANSFORM_FEEDBACK_BUFFER,
          0,
          this._currentBuffer,
          this._emitted[0][1] * 4,
          (this.maxParticles - e) * this._numInputFloats * 4
        ), t.beginTransformFeedback(t.POINTS), t.drawArrays(t.POINTS, e, this.maxParticles - e), t.endTransformFeedback(), t.bindBufferRange(t.TRANSFORM_FEEDBACK_BUFFER, 0, this._currentBuffer, 0, this._emitted[0][1] * 4), t.beginTransformFeedback(t.POINTS), t.drawArrays(t.POINTS, 0, e), t.endTransformFeedback();
      } else
        t.bindBufferRange(t.TRANSFORM_FEEDBACK_BUFFER, 0, this._currentBuffer, 0, this._particleData.length * 4), t.beginTransformFeedback(t.POINTS), t.drawArrays(t.POINTS, 0, this.maxParticles), t.endTransformFeedback();
      t.bindVertexArray(null), t.bindBufferBase(t.TRANSFORM_FEEDBACK_BUFFER, 0, null), this._currentVao = this._vaos[this._drawIndex % 2], this._currentBuffer = this._buffers[(this._drawIndex + 1) % 2], this._drawIndex = (this._drawIndex + 1) % 2;
    }
  }
}
hs.GPU_MAX_PARTICLES = 1e5;
class nc extends Dt {
  constructor(t) {
    super({ name: "GpuParticleEmitter", width: t.width, height: t.height }), this.particle = {
      /**
       * Gets or sets the life of each particle in milliseconds
       */
      life: 2e3,
      transform: jt.Global,
      graphic: void 0,
      opacity: 1,
      angularVelocity: 0,
      focus: void 0,
      focusAccel: void 0,
      randomRotation: !1
    }, this.graphics = new tt(), this.isEmitting = !1, this.emitRate = 1, this.emitterType = Ae.Rectangle, this.radius = 0, this.maxParticles = 2e3, this._particlesToEmit = 0, this.addComponent(this.graphics, !0), this.graphics.onPostDraw = this.draw.bind(this);
    const { particle: e, maxParticles: i, x: s, y: n, z: o, pos: a, isEmitting: h, emitRate: l, emitterType: c, radius: d, random: u } = { ...t };
    this.maxParticles = D(i != null ? i : this.maxParticles, 0, hs.GPU_MAX_PARTICLES), this.pos = a != null ? a : w(s != null ? s : 0, n != null ? n : 0), this.z = o != null ? o : 0, this.isEmitting = h != null ? h : this.isEmitting, this.emitRate = l != null ? l : this.emitRate, this.emitterType = c != null ? c : this.emitterType, this.radius = d != null ? d : this.radius, this.particle = { ...this.particle, ...e }, this.random = u != null ? u : new ge(), this.renderer = new hs(this, this.random, this.particle);
  }
  get pos() {
    return this.transform.pos;
  }
  set pos(t) {
    this.transform.pos = t;
  }
  get z() {
    return this.transform.z;
  }
  set z(t) {
    this.transform.z = t;
  }
  _initialize(t) {
    super._initialize(t);
    const e = t.graphicsContext;
    this.renderer.initialize(e.__gl, e);
  }
  update(t, e) {
    super.update(t, e), this.isEmitting && (this._particlesToEmit += this.emitRate * (e / 1e3), this._particlesToEmit > 1 && (this.emitParticles(Math.floor(this._particlesToEmit)), this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit))), this.renderer.update(e);
  }
  emitParticles(t) {
    t <= 0 || this.renderer.emitParticles(t | 0);
  }
  clearParticles() {
    this.renderer.clearParticles();
  }
  draw(t, e) {
    t.draw("ex.particle", this.renderer, e);
  }
}
class to {
  constructor(t, e) {
    this.id = W(), this._stopped = !1, this._sequenceBuilder = e, this._sequenceContext = new ki(t), this._actionQueue = this._sequenceContext.getQueue(), this._sequenceBuilder(this._sequenceContext);
  }
  update(t) {
    this._actionQueue.update(t);
  }
  isComplete() {
    return this._stopped || this._actionQueue.isComplete();
  }
  stop() {
    this._stopped = !0;
  }
  reset() {
    this._stopped = !1, this._actionQueue.reset();
  }
  clone(t) {
    return new to(t, this._sequenceBuilder);
  }
}
class rc {
  constructor(t) {
    this.id = W(), this._actions = t;
  }
  update(t) {
    for (let e = 0; e < this._actions.length; e++)
      this._actions[e].update(t);
  }
  isComplete(t) {
    return this._actions.every((e) => e.isComplete(t));
  }
  reset() {
    this._actions.forEach((t) => t.reset());
  }
  stop() {
    this._actions.forEach((t) => t.stop());
  }
}
function oc(r) {
  return !!r._initialize;
}
function ac(r) {
  return !!r.onAdd;
}
function hc(r) {
  return !!r.onRemove;
}
function lc(r) {
  return !!r.onInitialize;
}
function cc(r) {
  return !!r._preupdate;
}
function dc(r) {
  return !!r.onPreUpdate;
}
function uc(r) {
  return !!r.onPostUpdate;
}
function _c(r) {
  return !!r.onPostUpdate;
}
function fc(r) {
  return !!r.onAdd;
}
function gc(r) {
  return !!r.onRemove;
}
function pc(r) {
  return !!r.onPreDraw;
}
function mc(r) {
  return !!r.onPostDraw;
}
class Nh {
  constructor(t, e) {
    this.soundManager = e;
  }
  stop(t) {
    if (!t)
      return;
    const e = this.soundManager.getSoundsForChannel(t);
    for (let i = 0; i < e.length; i++)
      e[i].stop();
  }
  setVolume(t, e) {
    const i = this.soundManager.getSoundsForChannel(t);
    for (const s of i)
      this.soundManager._isMuted(s) || this.soundManager.setVolume(t, e);
  }
  play(t, e) {
    e != null || (e = this.soundManager.defaultVolume);
    const i = [], s = /* @__PURE__ */ new Set(), n = this.soundManager.getSoundsForChannel(t);
    for (const o of n) {
      if (s.has(o) || this.soundManager._isMuted(o))
        continue;
      const a = this.soundManager._getEffectiveVolume(o);
      i.push(o.play(a * e)), s.add(o);
    }
    return Promise.all(i);
  }
  mute(t) {
    const e = this.soundManager.getSoundsForChannel(t);
    for (let i = 0; i < e.length; i++)
      this.soundManager._muted.add(e[i]), e[i].pause();
  }
  unmute(t) {
    const e = this.soundManager.getSoundsForChannel(t);
    for (let i = 0; i < e.length; i++)
      this.soundManager._muted.has(e[i]) && (e[i].play(), this.soundManager._muted.delete(e[i]));
  }
  toggle(t) {
    const e = this.soundManager.getSoundsForChannel(t);
    for (let i = 0; i < e.length; i++)
      this.soundManager._isMuted(e[i]) ? (e[i].play(), this.soundManager._muted.delete(e[i])) : (this.soundManager._muted.add(e[i]), e[i].pause());
  }
}
class xc {
  constructor(t) {
    this._channelToConfig = /* @__PURE__ */ new Map(), this._nameToConfig = /* @__PURE__ */ new Map(), this._mix = /* @__PURE__ */ new Map(), this._muted = /* @__PURE__ */ new Set(), this._all = /* @__PURE__ */ new Set(), this._defaultVolume = 1;
    var e;
    if (this._defaultVolume = (e = t.volume) != null ? e : 1, this.channel = new Nh(t, this), t.sounds)
      for (const [i, s] of Object.entries(t.sounds))
        this.track(i, s);
  }
  set defaultVolume(t) {
    this._defaultVolume = D(t, 0, 1);
  }
  get defaultVolume() {
    return this._defaultVolume;
  }
  getSounds() {
    return Array.from(this._all);
  }
  getSoundsForChannel(t) {
    const e = this._channelToConfig.get(t);
    return e ? e.sounds : [];
  }
  _isMuted(t) {
    return this._muted.has(t);
  }
  _getEffectiveVolume(t) {
    var e;
    if (this._isMuted(t))
      return 0;
    let i = this._defaultVolume;
    return this._mix.has(t) && (i *= (e = this._mix.get(t)) != null ? e : this._defaultVolume), i;
  }
  play(t, e = this._defaultVolume) {
    const i = this._nameToConfig.get(t);
    if (!i)
      return Promise.resolve();
    const { sound: s } = i;
    if (this._isMuted(s))
      return Promise.resolve();
    const n = e * this._getEffectiveVolume(s);
    return s.play(n);
  }
  getSound(t) {
    const e = this._nameToConfig.get(t);
    if (!e)
      return;
    const { sound: i } = e;
    return i;
  }
  setVolume(t, e = this._defaultVolume) {
    const i = this._nameToConfig.get(t);
    if (!i)
      return;
    const { sound: s } = i;
    this._setMix(s, e);
  }
  /**
   * Gets the volumn for a sound
   */
  getVolume(t) {
    var e;
    const i = this.getSound(t);
    return i && (e = this._mix.get(i)) != null ? e : 0;
  }
  /**
   * Set the maximum volume a sound, if not set assumed to be 1.0 (100% of the source volume)
   */
  _setMix(t, e) {
    this._mix.set(t, e), t.volume = e;
  }
  track(t, e) {
    let i, s, n;
    e instanceof Lr ? (i = e, s = this._defaultVolume, n = []) : { sound: i, volume: s, channels: n } = e, this._nameToConfig.set(t, { sound: i, volume: s, channels: n }), this._mix.set(i, s != null ? s : this._defaultVolume), this._all.add(i), n && this.addChannel(t, n);
  }
  /**
   * Remove the maximum volume for a sound, will be 100% of the source volume
   *
   * Untracks the Sound in the sound manager
   */
  untrack(t) {
    this._nameToConfig.delete(t);
    const e = this.getSound(t);
    e && (this._mix.delete(e), this._all.delete(e));
  }
  stop(t) {
    if (t) {
      const e = this._nameToConfig.get(t);
      if (!e)
        return;
      const { sound: i } = e;
      i.stop();
      return;
    }
    this._all.forEach((e) => e.stop());
  }
  mute(t) {
    if (t) {
      const e = this._nameToConfig.get(t);
      if (!e)
        return;
      const { sound: i } = e;
      this._muted.add(i), i.pause();
      return;
    }
    this._muted = new Set(this._all), this._muted.forEach((e) => e.pause());
  }
  unmute(t) {
    if (t) {
      const e = this._nameToConfig.get(t);
      if (!e)
        return;
      const { sound: i } = e;
      i.play(), this._muted.delete(i);
      return;
    }
    this._muted.forEach((e) => e.play()), this._muted.clear();
  }
  toggle(t) {
    if (t) {
      const e = this._nameToConfig.get(t);
      if (!e)
        return;
      const { sound: i } = e;
      this._isMuted(i) ? this.unmute(t) : this.mute(t);
      return;
    }
    this._muted.size > 0 ? (this._muted.forEach((e) => e.play()), this._muted.clear()) : (this._muted = new Set(this._all), this._muted.forEach((e) => e.pause()));
  }
  /**
   * Apply a list of channels to a sound instance
   */
  addChannel(t, e) {
    const i = this.getSound(t);
    if (!i)
      return;
    const s = this._mix.get(i);
    this._mix.set(i, s != null ? s : this._defaultVolume), this._all.add(i);
    for (const n of e) {
      let o = this._channelToConfig.get(n);
      o || (o = {
        sounds: [i]
      }), o.sounds.indexOf(i) === -1 && o.sounds.push(i), this._channelToConfig.set(n, o);
    }
  }
  removeChannel(t, e) {
    const i = this.getSound(t);
    if (i)
      for (const s of e) {
        const n = this._channelToConfig.get(s);
        if (!n)
          return;
        const o = n.sounds.indexOf(i);
        o >= -1 && n.sounds.splice(o, 1), this._channelToConfig.set(s, n);
      }
  }
}
class vc {
  /**
   * @param path       Path to the image resource
   * @param bustCache  Optionally load texture with cache busting
   */
  constructor(t, e = !1) {
    this.path = t, this.width = 0, this.height = 0, this._images = [], this.data = [], this._sprites = [], this._resource = new Ii(t, "arraybuffer", e);
  }
  /**
   * Should excalibur add a cache busting querystring? By default false.
   * Must be set before loading
   */
  get bustCache() {
    return this._resource.bustCache;
  }
  set bustCache(t) {
    this._resource.bustCache = t;
  }
  /**
   * Begins loading the texture and returns a promise to be resolved on completion
   */
  async load() {
    const t = await this._resource.load();
    this._stream = new Wh(t), this._gif = new Gh(this._stream);
    const e = this._gif.images.map((i) => new Nt(i.src, !1));
    return await Promise.all(e.map((i) => i.load())), this.data = this._images = e, this._sprites = this._images.map((i) => i.toSprite()), this.data;
  }
  isLoaded() {
    return !!this.data;
  }
  /**
   * Return a frame of the gif as a sprite by id
   * @param id
   */
  toSprite(t = 0) {
    var e;
    return (e = this._sprites[t]) != null ? e : null;
  }
  /**
   * Return the gif as a spritesheet
   */
  toSpriteSheet() {
    const t = this._sprites;
    return t.length ? new Te({ sprites: t }) : null;
  }
  /**
   * Transform the GIF into an animation with duration per frame
   * @param durationPerFrame Optionally override duration per frame
   */
  toAnimation(t) {
    var e;
    const i = (e = this._gif) == null ? void 0 : e.images;
    if (i != null && i.length) {
      const s = i.map((n, o) => {
        var a;
        return {
          graphic: this._sprites[o],
          duration: ((a = this._gif) == null ? void 0 : a.frames[o].delayMs) || void 0
        };
      });
      return this._animation = new _s({
        frames: s,
        frameDuration: t
      }), this._animation;
    }
    return null;
  }
  get readCheckBytes() {
    var t, e;
    return (e = (t = this._gif) == null ? void 0 : t.checkBytes) != null ? e : [];
  }
}
const hi = (r) => r.reduce(function(t, e) {
  return t * 2 + e;
}, 0), qi = (r) => {
  const t = [];
  for (let e = 7; e >= 0; e--)
    t.push(!!(r & 1 << e));
  return t;
};
class Wh {
  constructor(t) {
    if (this.len = 0, this.position = 0, this.readByte = () => {
      if (this.position >= this.data.byteLength)
        throw new Error("Attempted to read past end of stream.");
      return this.data[this.position++];
    }, this.readBytes = (e) => {
      const i = [];
      for (let s = 0; s < e; s++)
        i.push(this.readByte());
      return i;
    }, this.read = (e) => {
      let i = "";
      for (let s = 0; s < e; s++)
        i += String.fromCharCode(this.readByte());
      return i;
    }, this.readUnsigned = () => {
      const e = this.readBytes(2);
      return (e[1] << 8) + e[0];
    }, this.data = new Uint8Array(t), this.len = this.data.byteLength, this.len === 0)
      throw new Error("No data loaded from file");
  }
}
const Vh = function(r, t) {
  let e = 0;
  const i = function(u) {
    let _ = 0;
    for (let p = 0; p < u; p++)
      t.charCodeAt(e >> 3) & 1 << (e & 7) && (_ |= 1 << p), e++;
    return _;
  }, s = [], n = 1 << r, o = n + 1;
  let a = r + 1, h = [];
  const l = function() {
    h = [], a = r + 1;
    for (let u = 0; u < n; u++)
      h[u] = [u];
    h[n] = [], h[o] = null;
  };
  let c = 0, d = 0;
  for (; ; ) {
    if (d = c, c = i(a), c === n) {
      l();
      continue;
    }
    if (c === o)
      break;
    if (c < h.length)
      d !== n && h.push(h[d].concat(h[c][0]));
    else {
      if (c !== h.length)
        throw new Error("Invalid LZW code.");
      h.push(h[d].concat(h[d][0]));
    }
    s.push.apply(s, h[c]), h.length === 1 << a && a < 12 && a++;
  }
  return s;
};
class Gh {
  constructor(t) {
    this._handler = {}, this.frames = [], this.images = [], this.globalColorTableBytes = [], this.checkBytes = [], this.parseColorTableBytes = (e) => {
      const i = [];
      for (let s = 0; s < e; s++) {
        const n = this._st.readBytes(3);
        i.push(n);
      }
      return i;
    }, this.readSubBlocks = () => {
      let e, i;
      i = "";
      do
        e = this._st.readByte(), i += this._st.read(e);
      while (e !== 0);
      return i;
    }, this.parseHeader = () => {
      const e = {
        sig: "",
        ver: "",
        width: 0,
        height: 0,
        colorResolution: 0,
        globalColorTableSize: 0,
        gctFlag: !1,
        sortedFlag: !1,
        globalColorTable: [],
        backgroundColorIndex: 0,
        pixelAspectRatio: 0
        // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64
      };
      if (e.sig = this._st.read(3), e.ver = this._st.read(3), e.sig !== "GIF")
        throw new Error("Not a GIF file.");
      e.width = this._st.readUnsigned(), e.height = this._st.readUnsigned(), this._currentFrameCanvas.width = e.width, this._currentFrameCanvas.height = e.height;
      const i = qi(this._st.readByte());
      e.gctFlag = i.shift(), e.colorResolution = hi(i.splice(0, 3)), e.sortedFlag = i.shift(), e.globalColorTableSize = hi(i.splice(0, 3)), e.backgroundColorIndex = this._st.readByte(), e.pixelAspectRatio = this._st.readByte(), e.gctFlag && (this.globalColorTableBytes = this.parseColorTableBytes(1 << e.globalColorTableSize + 1)), this._handler.hdr && this._handler.hdr(e) && this.checkBytes.push(this._handler.hdr);
    }, this.parseExt = (e) => {
      const i = (h) => {
        this.checkBytes.push(this._st.readByte());
        const l = qi(this._st.readByte());
        return h.reserved = l.splice(0, 3), h.disposalMethod = hi(l.splice(0, 3)), h.userInputFlag = l.shift(), h.transparentColorFlag = l.shift(), h.delayTime = this._st.readUnsigned(), h.transparentColorIndex = this._st.readByte(), h.terminator = this._st.readByte(), this._handler.gce && this._handler.gce(h) && this.checkBytes.push(this._handler.gce), h;
      }, s = (h) => {
        h.comment = this.readSubBlocks(), this._handler.com && this._handler.com(h) && this.checkBytes.push(this._handler.com);
      }, n = (h) => {
        this.checkBytes.push(this._st.readByte()), h.ptHeader = this._st.readBytes(12), h.ptData = this.readSubBlocks(), this._handler.pte && this._handler.pte(h) && this.checkBytes.push(this._handler.pte);
      }, o = (h) => {
        const l = (d) => {
          this.checkBytes.push(this._st.readByte()), d.unknown = this._st.readByte(), d.iterations = this._st.readUnsigned(), d.terminator = this._st.readByte(), this._handler.app && this._handler.app.NETSCAPE && this._handler.app.NETSCAPE(d) && this.checkBytes.push(this._handler.app);
        }, c = (d) => {
          d.appData = this.readSubBlocks(), this._handler.app && this._handler.app[d.identifier] && this._handler.app[d.identifier](d) && this.checkBytes.push(this._handler.app[d.identifier]);
        };
        switch (this.checkBytes.push(this._st.readByte()), h.identifier = this._st.read(8), h.authCode = this._st.read(3), h.identifier) {
          case "NETSCAPE":
            l(h);
            break;
          default:
            c(h);
            break;
        }
      }, a = (h) => {
        h.data = this.readSubBlocks(), this._handler.unknown && this._handler.unknown(h) && this.checkBytes.push(this._handler.unknown);
      };
      switch (e.label = this._st.readByte(), e.label) {
        case 249:
          e.extType = "gce", this._gce = i(e);
          break;
        case 254:
          e.extType = "com", s(e);
          break;
        case 1:
          e.extType = "pte", n(e);
          break;
        case 255:
          e.extType = "app", o(e);
          break;
        default:
          e.extType = "unknown", a(e);
          break;
      }
    }, this.parseImg = (e) => {
      var i;
      const s = (a, h) => {
        const l = new Array(a.length), c = a.length / h, d = (g, x) => {
          const m = a.slice(x * h, (x + 1) * h);
          l.splice.apply(l, [g * h, h].concat(m));
        }, u = [0, 4, 2, 1], _ = [8, 8, 4, 2];
        let p = 0;
        for (let g = 0; g < 4; g++)
          for (let x = u[g]; x < c; x += _[g])
            d(x, p), p++;
        return l;
      };
      e.leftPos = this._st.readUnsigned(), e.topPos = this._st.readUnsigned(), e.width = this._st.readUnsigned(), e.height = this._st.readUnsigned();
      const n = qi(this._st.readByte());
      e.lctFlag = n.shift(), e.interlaced = n.shift(), e.sorted = n.shift(), e.reserved = n.splice(0, 2), e.lctSize = hi(n.splice(0, 3)), e.lctFlag && (e.lctBytes = this.parseColorTableBytes(1 << e.lctSize + 1)), e.lzwMinCodeSize = this._st.readByte();
      const o = this.readSubBlocks();
      e.pixels = Vh(e.lzwMinCodeSize, o), e.interlaced && (e.pixels = s(e.pixels, e.width)), (i = this._gce) != null && i.delayTime && (e.delayMs = this._gce.delayTime * 10), this.frames.push(e), this.arrayToImage(e, e.lctFlag ? e.lctBytes : this.globalColorTableBytes), this._handler.img && this._handler.img(e) && this.checkBytes.push(this._handler);
    }, this.parseBlocks = () => {
      const e = {
        sentinel: this._st.readByte(),
        type: ""
      };
      switch (String.fromCharCode(e.sentinel)) {
        case "!":
          e.type = "ext", this.parseExt(e);
          break;
        case ",":
          e.type = "img", this.parseImg(e);
          break;
        case ";":
          e.type = "eof", this._handler.eof && this._handler.eof(e) && this.checkBytes.push(this._handler.eof);
          break;
        default:
          throw new Error("Unknown block: 0x" + e.sentinel.toString(16));
      }
      e.type !== "eof" && this.parseBlocks();
    }, this.arrayToImage = (e, i) => {
      var s, n, o, a;
      const h = document.createElement("canvas");
      h.width = e.width, h.height = e.height;
      const l = h.getContext("2d"), c = l.getImageData(0, 0, h.width, h.height);
      let d = -1;
      (s = this._gce) != null && s.transparentColorFlag && (d = this._gce.transparentColorIndex);
      for (let _ = 0; _ < e.pixels.length; _++) {
        const p = e.pixels[_], g = i[p];
        p === d ? c.data.set([0, 0, 0, 0], _ * 4) : c.data.set([...g, 255], _ * 4);
      }
      if (l.putImageData(c, 0, 0), ((n = this._gce) == null ? void 0 : n.disposalMethod) === 1 && this.images.length)
        this._currentFrameContext.drawImage(this.images[this.images.length - 1], 0, 0);
      else if (((o = this._gce) == null ? void 0 : o.disposalMethod) === 2 && ((a = this._hdr) != null && a.gctFlag)) {
        const _ = i[this._hdr.backgroundColorIndex];
        this._currentFrameContext.fillStyle = `rgb(${_[0]}, ${_[1]}, ${_[2]})`, this._currentFrameContext.fillRect(0, 0, this._hdr.width, this._hdr.height);
      } else
        this._currentFrameContext.clearRect(0, 0, this._currentFrameCanvas.width, this._currentFrameCanvas.height);
      this._currentFrameContext.drawImage(h, e.leftPos, e.topPos, e.width, e.height);
      const u = new Image();
      u.src = this._currentFrameCanvas.toDataURL(), this.images.push(u);
    }, this._st = t, this._handler = {}, this._currentFrameCanvas = document.createElement("canvas"), this._currentFrameContext = this._currentFrameCanvas.getContext("2d"), this.parseHeader(), this.parseBlocks();
  }
}
class wc {
  constructor(t, e, { bustCache: i, ...s } = {}) {
    this.path = t, this.family = e, this._isLoaded = !1, this._resource = new Ii(t, "blob", i), this._options = s;
  }
  async load() {
    if (this.isLoaded())
      return this.data;
    try {
      const t = await this._resource.load(), e = URL.createObjectURL(t);
      this.data || (this.data = new FontFace(this.family, `url(${e})`), document.fonts.add(this.data)), await this.data.load(), this._isLoaded = !0;
    } catch (t) {
      throw `Error loading FontSource from path '${this.path}' with error [${t.message}]`;
    }
    return this.data;
  }
  isLoaded() {
    return this._isLoaded;
  }
  /**
   * Build a font from this FontSource.
   * @param options {FontOptions} Override the font options
   */
  toFont(t) {
    return new Me({ family: this.family, ...this._options, ...t });
  }
}
const rn = Jr(), qh = /^\s*(?:function)?\*/;
function on(r) {
  return typeof r != "function" ? !1 : qh.test(Function.prototype.toString.call(r)) ? !0 : Object.getPrototypeOf ? Object.getPrototypeOf(r) === Object.getPrototypeOf(new Function("return function * () {}")()) : !1;
}
function Xh(...r) {
  var t;
  const e = R.getInstance();
  let i, s, n, o;
  on(r[0]) && (s = globalThis, i = r[0], n = r[1]), on(r[1]) && (s = r[0], i = r[1], n = r[2]), r[1] instanceof Gi && (s = r[0], o = r[1], i = r[2], n = r[3]), r[0] instanceof Gi && (s = globalThis, o = r[0], i = r[1], n = r[2]);
  const a = Kr(rn), h = n == null ? void 0 : n.timing, l = a ? !1 : (t = n == null ? void 0 : n.autostart) != null ? t : !0;
  let c;
  try {
    c = o != null ? o : Gi.useEngine();
  } catch (b) {
    throw Error(
      `Cannot run coroutine without engine parameter outside of an excalibur lifecycle method.
Pass an engine parameter to ex.coroutine(engine, function * {...})`
    );
  }
  let d = !1, u = !1, _ = !1;
  const p = i.bind(s), g = p();
  let x;
  const m = new Promise((b, C) => {
    x = (S) => {
      try {
        if (_) {
          u = !0, b();
          return;
        }
        const { done: I, value: y } = rn.scope(!0, () => g.next(S));
        if (I || _) {
          u = !0, b();
          return;
        }
        y instanceof Promise ? y.then(() => {
          c.clock.schedule(x, 0, h);
        }) : y === void 0 || y === void 0 ? c.clock.schedule(x, 0, h) : c.clock.schedule(x, y || 0, h);
      } catch (I) {
        C(I);
        return;
      }
    }, l && (d = !0, x(c.clock.elapsed()));
  }), f = {
    isRunning: () => d && !_ && !u,
    isComplete: () => u,
    cancel: () => {
      _ = !0;
    },
    start: () => (d ? e.warn(
      `.start() was called on a coroutine that was already started, this is probably a bug:
`,
      Function.prototype.toString.call(p)
    ) : (d = !0, x(c.clock.elapsed())), f),
    generator: g,
    done: m,
    then: m.then.bind(m),
    [Symbol.iterator]: () => g
  };
  return f;
}
class Rs extends Rt {
  constructor(t) {
    var e, i, s, n, o;
    super(), this._logger = R.getInstance(), this.transform = new P(), this.graphics = new tt(), this._completeFuture = new yt(), this.started = !1, this._currentDistance = 0, this._currentProgress = 0, this.done = this._completeFuture.promise, this._useLegacyEasing = !1, this.name = `Transition#${this.id}`, this.duration = t.duration, Fe(t.easing) ? (this.legacyEasing = (e = t.easing) != null ? e : It.Linear, this._useLegacyEasing = !0) : this.easing = (i = t.easing) != null ? i : ds, this.direction = (s = t.direction) != null ? s : "out", this.hideLoader = (n = t.hideLoader) != null ? n : !1, this.blockInput = (o = t.blockInput) != null ? o : !1, this.transform.coordPlane = at.Screen, this.transform.pos = v.Zero, this.transform.z = 1 / 0, this.graphics.anchor = v.Zero, this.addComponent(this.transform), this.addComponent(this.graphics), this.direction === "out" ? this._currentProgress = 0 : this._currentProgress = 1;
  }
  /**
   * Returns a number between [0, 1] indicating what state the transition is in.
   *
   * * For 'out' direction transitions start at 0 and end at 1
   * * For 'in' direction transitions start at 1 and end at 0
   */
  get progress() {
    return this._currentProgress;
  }
  get distance() {
    return this._currentDistance;
  }
  get complete() {
    return this.direction === "out" ? this.progress >= 1 : this.progress <= 0;
  }
  /**
   * Overridable lifecycle method, called before each update.
   *
   * **WARNING BE SURE** to call `super.updateTransition()` if overriding in your own custom implementation
   * @param engine
   * @param elapsed
   */
  updateTransition(t, e) {
    this.complete || (this._currentDistance += D(e / this.duration, 0, 1), this._currentDistance >= 1 && (this._currentDistance = 1), this.direction === "out" ? this._useLegacyEasing ? this._currentProgress = D(this.legacyEasing(this._currentDistance, 0, 1, 1), 0, 1) : this._currentProgress = D(ot(0, 1, this.easing(this._currentDistance)), 0, 1) : this._useLegacyEasing ? this._currentProgress = D(this.legacyEasing(this._currentDistance, 1, 0, 1), 0, 1) : this._currentProgress = D(ot(1, 0, this.easing(this._currentDistance)), 0, 1));
  }
  /**
   * Overridable lifecycle method, called right before the previous scene has deactivated.
   *
   * This gives incoming transition a chance to grab info from previous scene if desired
   * @param scene
   */
  async onPreviousSceneDeactivate(t) {
  }
  /**
   * Overridable lifecycle method, called once at the beginning of the transition
   *
   * `progress` is given between 0 and 1
   * @param progress
   */
  onStart(t) {
  }
  /**
   * Overridable lifecycle method, called every frame of the transition
   *
   * `progress` is given between 0 and 1
   * @param progress
   */
  onUpdate(t) {
  }
  /**
   * Overridable lifecycle method, called at the end of the transition,
   *
   * `progress` is given between 0 and 1
   * @param progress
   */
  onEnd(t) {
  }
  /**
   * Overridable lifecycle method, called when the transition is reset
   *
   * Use this to override and provide your own reset logic for internal state in custom transition implementations
   */
  onReset() {
  }
  /**
   * reset() is called by the engine to reset transitions
   */
  reset() {
    this.started = !1, this._completeFuture = new yt(), this.done = this._completeFuture.promise, this._currentDistance = 0, this.direction === "out" ? this._currentProgress = 0 : this._currentProgress = 1, this.onReset();
  }
  /**
   * @internal
   */
  _addToTargetScene(t, e) {
    const i = e;
    if (this.started && this._logger.warn(`Attempted to add a transition ${this.name} that is already playing.`), i.world.entityManager.getById(this.id))
      return this._co;
    this._engine = t, i.add(this);
    const s = this;
    return this._co = Xh(
      t,
      function* () {
        for (; !s.complete; ) {
          const n = yield;
          s.updateTransition(s._engine, n), s._execute();
        }
      },
      {
        autostart: !1
      }
    ), this._co;
  }
  /**
   * Called internally by excalibur to swap scenes with transition
   * @internal
   */
  async _play() {
    this.started && (this.reset(), this._logger.warn(`Attempted to play a transition ${this.name} that is already playing, reset transition.`)), (!this._engine || !this._co) && (this.reset(), this._logger.warn(`Attempted to play a transition ${this.name} that hasn't been added`)), this._co && await this._co.start();
  }
  /**
   * execute() is called by the engine every frame to update the Transition lifecycle onStart/onUpdate/onEnd
   * @internal
   */
  _execute() {
    this.isInitialized && (this.started || (this.started = !0, this.onStart(this.progress)), this.onUpdate(this.progress), this.complete && !this._completeFuture.isCompleted && (this.onEnd(this.progress), this._completeFuture.resolve()));
  }
}
class bc extends Rs {
  constructor(t) {
    var e, i;
    super({
      ...t,
      duration: (e = t.duration) != null ? e : 2e3
    }), this.name = `FadeInOut#${this.id}`, this.color = (i = t.color) != null ? i : T.Black;
  }
  onInitialize(t) {
    this.transform.pos = t.screen.unsafeArea.topLeft, this.screenCover = new Fi({
      width: t.screen.resolution.width,
      height: t.screen.resolution.height,
      color: this.color
    }), this.graphics.add(this.screenCover), this.graphics.opacity = this.progress;
  }
  onReset() {
    this.graphics.opacity = this.progress;
  }
  onStart(t) {
    this.graphics.opacity = t;
  }
  onEnd(t) {
    this.graphics.opacity = t;
  }
  onUpdate(t) {
    this.graphics.opacity = t;
  }
}
class yc extends Rs {
  constructor(t) {
    super({ direction: "in", ...t }), this.name = `CrossFade#${this.id}`;
  }
  async onPreviousSceneDeactivate(t) {
    this.image = await t.engine.screenshot(!0), await this.image.decode();
  }
  onInitialize(t) {
    this.engine = t, this.transform.pos = t.screen.unsafeArea.topLeft, this.screenCover = Nt.fromHtmlImageElement(this.image).toSprite(), this.graphics.add(this.screenCover), this.transform.scale = w(1 / t.screen.pixelRatio, 1 / t.screen.pixelRatio), this.graphics.opacity = this.progress;
  }
  onStart(t) {
    this.graphics.opacity = this.progress;
  }
  onReset() {
    this.graphics.opacity = this.progress;
  }
  onEnd(t) {
    this.graphics.opacity = t;
  }
  onUpdate(t) {
    this.graphics.opacity = t;
  }
}
class Cc extends Rs {
  constructor(t) {
    var e;
    super({ direction: "in", ...t }), this._easing = It.Linear, this._start = v.Zero, this._end = v.Zero, this.name = `Slide#${this.id}`, this.slideDirection = t.slideDirection, this.transform.coordPlane = at.Screen, this.graphics.forceOnScreen = !0, this._easing = (e = t.easingFunction) != null ? e : this._easing;
  }
  async onPreviousSceneDeactivate(t) {
    this._image = await t.engine.screenshot(!0), await this._image.decode(), this._screenCover = Nt.fromHtmlImageElement(this._image).toSprite();
  }
  onInitialize(t) {
    this._engine = t;
    let e = t.screen.unsafeArea;
    switch (e.hasZeroDimensions() && (e = t.screen.contentArea), this.slideDirection) {
      case "up": {
        this._directionOffset = w(0, -e.height);
        break;
      }
      case "down": {
        this._directionOffset = w(0, e.height);
        break;
      }
      case "left": {
        this._directionOffset = w(-e.width, 0);
        break;
      }
      case "right": {
        this._directionOffset = w(e.width, 0);
        break;
      }
    }
    this._camera = this._engine.currentScene.camera, this._destinationCameraPosition = this._camera.pos.clone(), this._camera.pos = this._camera.pos.add(this._directionOffset), this.transform.pos = this.transform.pos.add(this._directionOffset), this._startCameraPosition = this._camera.pos.clone(), this._start = e.topLeft, this._end = this._start.add(this._directionOffset), this.transform.pos = this._start, this.graphics.use(this._screenCover), this.transform.scale = w(1 / t.screen.pixelRatio, 1 / t.screen.pixelRatio);
  }
  onStart(t) {
    const e = this._easing(this.distance, 0, 1, 1);
    this.transform.pos.x = ot(this._start.x, this._end.x, e), this.transform.pos.y = ot(this._start.y, this._end.y, e), this._camera.pos.x = ot(this._startCameraPosition.x, this._destinationCameraPosition.x, e), this._camera.pos.y = ot(this._startCameraPosition.y, this._destinationCameraPosition.y, e);
  }
  onUpdate(t) {
    const e = this._easing(this.distance, 0, 1, 1);
    this.transform.pos.x = ot(this._start.x, this._end.x, e), this.transform.pos.y = ot(this._start.y, this._end.y, e), this._camera.pos.x = ot(this._startCameraPosition.x, this._destinationCameraPosition.x, e), this._camera.pos.y = ot(this._startCameraPosition.y, this._destinationCameraPosition.y, e);
  }
}
const Tc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ConsoleAppender: pn,
  DrawUtil: Mo,
  EasingFunctions: It,
  LogLevel: je,
  Logger: R,
  Observable: mt,
  ScreenAppender: uo,
  addItemToArray: go,
  contains: Xn,
  delay: xi,
  fail: $n,
  getMinIndex: qn,
  getPosition: ze,
  isLegacyEasing: Fe,
  isObject: ci,
  mergeDeep: vi,
  omit: Yn,
  removeItemFromArray: ke
}, Symbol.toStringTag, { value: "Module" })), $h = 5, Be = {}, Sc = () => {
  for (const r in Be)
    Be[r] = 0;
}, li = (r, t) => {
  const e = We.isEnabled("suppress-obsolete-message");
  Be[r] < $h && !e && (R.getInstance().warn(r), console.trace && t.showStackTrace && console.trace()), Be[r]++;
};
function Ac(r) {
  return r = {
    message: "This feature will be removed in future versions of Excalibur.",
    alternateMethod: null,
    showStackTrace: !1,
    ...r
  }, function(t, e, i) {
    if (i && !(typeof i.value == "function" || typeof i.get == "function" || typeof i.set == "function"))
      throw new SyntaxError("Only classes/functions/getters/setters can be marked as obsolete");
    const n = `${`${t.name || ""}${t.name && e ? "." : ""}${e || ""}`} is marked obsolete: ${r.message}` + (r.alternateMethod ? ` Use ${r.alternateMethod} instead` : "");
    Be[n] || (Be[n] = 0);
    const o = i ? { ...i } : t;
    if (!i) {
      class a extends o {
        constructor(...l) {
          li(n, r), super(...l);
        }
      }
      return a;
    }
    return i && i.value ? (o.value = function() {
      return li(n, r), i.value.apply(this, arguments);
    }, o) : (i && i.get && (o.get = function() {
      return li(n, r), i.get.apply(this, arguments);
    }), i && i.set && (o.set = function() {
      return li(n, r), i.set.apply(this, arguments);
    }), o);
  };
}
class Yh {
  constructor() {
    this._queue = [];
  }
  get length() {
    return this._queue.length;
  }
  enqueue() {
    const t = new yt();
    return this._queue.push(t), t.promise;
  }
  dequeue(t) {
    this._queue.shift().resolve(t);
  }
}
class Pc {
  constructor(t) {
    this._count = t, this._waitQueue = new Yh();
  }
  get count() {
    return this._count;
  }
  get waiting() {
    return this._waitQueue.length;
  }
  // eslint-disable-next-line require-await
  async enter() {
    return this._count !== 0 ? (this._count--, Promise.resolve()) : this._waitQueue.enqueue();
  }
  exit(t = 1) {
    if (t !== 0) {
      for (; t !== 0 && this._waitQueue.length !== 0; )
        this._waitQueue.dequeue(null), t--;
      this._count += t;
    }
  }
}
const an = "0.32.0";
hn();
export {
  Wn as ActionCompleteEvent,
  ki as ActionContext,
  Ca as ActionQueue,
  to as ActionSequence,
  Nn as ActionStartEvent,
  Xe as ActionsComponent,
  Gr as ActionsSystem,
  kn as ActivateEvent,
  Dt as Actor,
  Gl as ActorEvents,
  Vn as AddEvent,
  Fl as AddedComponent,
  j as AffineMatrix,
  _s as Animation,
  Ao as AnimationDirection,
  Ul as AnimationEvents,
  Po as AnimationStrategy,
  $s as ArcadeSolver,
  De as AudioContextFactory,
  Th as Axes,
  ph as Axis,
  cr as BaseAlign,
  Pi as BezierCurve,
  Va as Blink,
  U as BodyComponent,
  F as BoundingBox,
  en as BrowserComponent,
  Dh as BrowserEvents,
  qr as Buttons,
  yh as Camera,
  Ql as CameraEvents,
  xs as Canvas,
  Nh as ChannelCollection,
  ms as Circle,
  ut as CircleCollider,
  jr as Clock,
  Zt as ClosestLineJumpTable,
  Ei as Collider,
  it as ColliderComponent,
  we as CollisionContact,
  mi as CollisionEndEvent,
  Ee as CollisionGroup,
  Hi as CollisionGroupManager,
  Ot as CollisionJumpTable,
  Qi as CollisionPostSolveEvent,
  ji as CollisionPreSolveEvent,
  pi as CollisionStartEvent,
  Cs as CollisionSystem,
  E as CollisionType,
  T as Color,
  Mh as ColorBlindFlags,
  qe as ColorBlindnessMode,
  jo as ColorBlindnessPostProcessor,
  kt as Component,
  ht as CompositeCollider,
  pn as ConsoleAppender,
  Qa as ContactConstraintPoint,
  Zi as ContactEndEvent,
  _e as ContactSolveBias,
  Yi as ContactStartEvent,
  at as CoordPlane,
  yc as CrossFade,
  Za as CurveBy,
  Ya as CurveTo,
  Ln as DeactivateEvent,
  St as Debug,
  Fh as DebugConfig,
  gs as DebugGraphicsComponent,
  Vr as DebugSystem,
  fr as DebugText,
  Oo as DefaultAntialiasOptions,
  sn as DefaultGarbageCollectionOptions,
  yi as DefaultLoader,
  No as DefaultPixelArtOptions,
  le as DegreeOfFreedom,
  qa as Delay,
  lh as Detector,
  Xa as Die,
  ur as Direction,
  Hh as Director,
  zh as DirectorEvents,
  _i as DisplayMode,
  Jn as DynamicTree,
  Ki as DynamicTreeCollisionProcessor,
  an as EX_VERSION,
  Wa as EaseBy,
  Na as EaseTo,
  It as EasingFunctions,
  zs as Edge,
  At as EdgeCollider,
  vh as ElasticToActorStrategy,
  Ae as EmitterType,
  Gi as Engine,
  ec as EngineEvents,
  Hn as EnterTriggerEvent,
  zn as EnterViewPortEvent,
  Rt as Entity,
  Ll as EntityEvents,
  po as EntityManager,
  X as EventEmitter,
  mn as EventTypes,
  Ml as Events,
  Br as ExResponse,
  ns as ExcaliburGraphicsContext2DCanvas,
  Qt as ExcaliburGraphicsContextWebGL,
  On as ExitTriggerEvent,
  Un as ExitViewPortEvent,
  Ga as Fade,
  bc as FadeInOut,
  We as Flags,
  $a as Flash,
  qs as Follow,
  Me as Font,
  ss as FontCache,
  wc as FontSource,
  dr as FontStyle,
  hr as FontUnit,
  Bh as FpsSampler,
  Ti as FrameStats,
  yt as Future,
  B as GameEvent,
  bn as GameStartEvent,
  yn as GameStopEvent,
  Vi as Gamepad,
  Fn as GamepadAxisEvent,
  Mn as GamepadButtonEvent,
  In as GamepadConnectEvent,
  Rn as GamepadDisconnectEvent,
  Ps as Gamepads,
  Oh as GarbageCollector,
  vc as Gif,
  Gh as GifParser,
  Ye as GlobalCoordinates,
  nc as GpuParticleEmitter,
  hs as GpuParticleRenderer,
  dn as Graph,
  nt as Graphic,
  tt as GraphicsComponent,
  Ze as GraphicsGroup,
  pr as GraphicsSystem,
  ja as HashColliderProxy,
  Yt as HashGridCell,
  Mr as HashGridProxy,
  Bn as HiddenEvent,
  ir as HorizontalFirst,
  wt as ImageFiltering,
  Nt as ImageSource,
  z as ImageSourceAttributeConstants,
  ft as ImageWrapping,
  Ke as InitializeEvent,
  Zr as InputHost,
  Sh as InputMapper,
  Ci as IsometricEntityComponent,
  Wr as IsometricEntitySystem,
  jl as IsometricMap,
  fh as IsometricTile,
  oi as KeyEvent,
  Ph as Keyboard,
  Ah as Keys,
  xn as KillEvent,
  ic as Label,
  bh as LimitCameraBoundsStrategy,
  gr as Line,
  K as LineSegment,
  as as Loader,
  $l as LoaderEvents,
  xh as LockCameraToActorAxisStrategy,
  mh as LockCameraToActorStrategy,
  je as LogLevel,
  R as Logger,
  Jo as Material,
  Tt as Matrix,
  oo as MatrixLocations,
  kr as MediaEvent,
  Ni as Meet,
  N as MotionComponent,
  ys as MotionSystem,
  Ws as MoveBy,
  Ea as MoveByWithOptions,
  Vs as MoveTo,
  Ra as MoveToWithOptions,
  ye as NativePointerButton,
  be as NativeSoundEvent,
  nh as NativeSoundProcessedEvent,
  vr as NineSlice,
  Ho as NineSliceStretch,
  Xi as Node,
  sr as None,
  mt as Observable,
  mr as OffscreenSystem,
  xt as Pair,
  ps as ParallaxComponent,
  rc as ParallelActions,
  ws as Particle,
  sc as ParticleEmitter,
  $o as ParticleRenderer,
  jt as ParticleTransform,
  Is as PhysicsStats,
  th as PhysicsWorld,
  tn as PointerAbstraction,
  ce as PointerButton,
  fe as PointerComponent,
  ai as PointerEvent,
  Es as PointerEventReceiver,
  $e as PointerScope,
  As as PointerSystem,
  de as PointerType,
  xr as Polygon,
  ct as PolygonCollider,
  us as Pool,
  lo as PositionNode,
  Re as PostCollisionEvent,
  An as PostDebugDrawEvent,
  Je as PostDrawEvent,
  En as PostFrameEvent,
  wn as PostKillEvent,
  Tn as PostTransformDrawEvent,
  me as PostUpdateEvent,
  Ie as PreCollisionEvent,
  Sn as PreDebugDrawEvent,
  Qe as PreDrawEvent,
  Pn as PreFrameEvent,
  vn as PreKillEvent,
  Kl as PreLoadEvent,
  Cn as PreTransformDrawEvent,
  pe as PreUpdateEvent,
  Si as Projection,
  ni as QuadIndexBuffer,
  Oe as QuadTree,
  zt as Query,
  mo as QueryManager,
  wh as RadiusAroundActorStrategy,
  ge as Random,
  ti as Raster,
  Ce as Ray,
  Ys as RealisticSolver,
  Fi as Rectangle,
  Gn as RemoveEvent,
  Bl as RemovedComponent,
  ii as RentalPool,
  Sa as Repeat,
  Aa as RepeatForever,
  Zs as Resolution,
  Ii as Resource,
  zl as ResourceEvents,
  Ba as RotateBy,
  Da as RotateByWithOptions,
  Fa as RotateTo,
  Ma as RotateToWithOptions,
  J as RotationType,
  Oa as ScaleBy,
  Ha as ScaleByWithOptions,
  Ua as ScaleTo,
  La as ScaleToWithOptions,
  Et as Scene,
  tc as SceneEvents,
  js as Screen,
  uo as ScreenAppender,
  Hr as ScreenElement,
  ql as ScreenEvents,
  Yo as ScreenShader,
  Ne as ScrollPreventionMode,
  Pc as Semaphore,
  Ve as SeparatingAxis,
  bo as SeparationInfo,
  Lt as Shader,
  _t as Shape,
  G as Side,
  Cc as Slide,
  wi as SolverStrategy,
  Lr as Sound,
  Xl as SoundEvents,
  xc as SoundManager,
  Fr as SparseHashGrid,
  Xs as SparseHashGridCollisionProcessor,
  bi as SpatialPartitionStrategy,
  Bt as Sprite,
  fs as SpriteFont,
  Te as SpriteSheet,
  Qr as StandardClock,
  Ts as StateMachine,
  gh as StrategyContainer,
  Wh as Stream,
  Ft as System,
  vo as SystemManager,
  Kt as SystemPriority,
  Mt as SystemType,
  jn as TagQuery,
  kh as TestClock,
  Bi as Text,
  lr as TextAlign,
  Ge as TextureLoader,
  _h as Tile,
  uh as TileMap,
  Zl as TileMapEvents,
  wr as TiledAnimation,
  Ri as TiledSprite,
  Wi as Timer,
  Yl as TimerEvents,
  Uh as Toaster,
  re as Transform,
  P as TransformComponent,
  Rs as Transition,
  Os as TreeNode,
  Ch as Trigger,
  Jl as TriggerEvents,
  vt as TwoPI,
  Vo as UniformBuffer,
  Tc as Util,
  v as Vector,
  Us as VectorView,
  Vt as VertexBuffer,
  te as VertexLayout,
  er as VerticalFirst,
  Dn as VisibleEvent,
  ih as WebAudio,
  sh as WebAudioInstance,
  gi as WheelDeltaMode,
  Eh as WheelEvent,
  wo as World,
  no as angleDifference,
  so as approximatelyEqual,
  nn as assert,
  Ht as canonicalizeAngle,
  D as clamp,
  Xh as coroutine,
  Pe as createId,
  yl as easeInBack,
  co as easeInBounce,
  vl as easeInCirc,
  hl as easeInCubic,
  Sl as easeInElastic,
  pl as easeInExpo,
  Tl as easeInOutBack,
  El as easeInOutBounce,
  bl as easeInOutCirc,
  Hs as easeInOutCubic,
  Pl as easeInOutElastic,
  xl as easeInOutExpo,
  al as easeInOutQuad,
  ul as easeInOutQuart,
  gl as easeInOutQuint,
  nl as easeInOutSine,
  rl as easeInQuad,
  cl as easeInQuart,
  _l as easeInQuint,
  il as easeInSine,
  Cl as easeOutBack,
  fn as easeOutBounce,
  wl as easeOutCirc,
  ll as easeOutCubic,
  Al as easeOutElastic,
  ml as easeOutExpo,
  ol as easeOutQuad,
  dl as easeOutQuart,
  fl as easeOutQuint,
  sl as easeOutSine,
  Zh as frac,
  ne as getDefaultPhysicsConfig,
  Go as glTypeToUniformTypeName,
  Ir as hasGraphicsTick,
  fc as hasOnAdd,
  lc as hasOnInitialize,
  _c as hasOnPostUpdate,
  dc as hasOnPreUpdate,
  gc as hasOnRemove,
  mc as hasPostDraw,
  pc as hasPreDraw,
  ac as has_add,
  oc as has_initialize,
  uc as has_postupdate,
  cc as has_preupdate,
  hc as has_remove,
  ao as inverseLerp,
  ho as inverseLerpVector,
  Vl as isActor,
  Dl as isAddedComponent,
  _o as isComponentCtor,
  Fe as isLegacyEasing,
  Qs as isLoaderConstructor,
  Pa as isMoveByOptions,
  Ia as isMoveToOptions,
  kl as isRemovedComponent,
  Wl as isRotateByOptions,
  Nl as isRotateToOptions,
  za as isScaleByOptions,
  ka as isScaleToOptions,
  Xt as isSceneConstructor,
  ch as isScreenElement,
  xo as isSystemConstructor,
  ot as lerp,
  cn as lerpAngle,
  Ai as lerpVector,
  ds as linear,
  $h as maxMessages,
  W as nextActionId,
  Ac as obsolete,
  ei as parseImageFiltering,
  Wt as parseImageWrapping,
  M as pixelSnapEpsilon,
  $t as randomInRange,
  Jh as randomIntInRange,
  Qh as range,
  Jt as remap,
  Kh as remapVector,
  Sc as resetObsoleteCounter,
  q as sign,
  el as smootherstep,
  tl as smoothstep,
  ro as toDegrees,
  jh as toRadians,
  w as vec,
  Hl as webgl
};
